
Graduation_Project.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003c7c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000076e  00800060  00003c7c  00003d10  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000028  008007ce  008007ce  0000447e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000447e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000044b0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000004b8  00000000  00000000  000044ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000087cb  00000000  00000000  000049a4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000016a3  00000000  00000000  0000d16f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003e66  00000000  00000000  0000e812  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000c18  00000000  00000000  00012678  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001088  00000000  00000000  00013290  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000039a4  00000000  00000000  00014318  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000003e8  00000000  00000000  00017cbc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 ec 04 	jmp	0x9d8	; 0x9d8 <__vector_1>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 9b 0f 	jmp	0x1f36	; 0x1f36 <__vector_4>
      14:	0c 94 47 0f 	jmp	0x1e8e	; 0x1e8e <__vector_5>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 80 0e 	jmp	0x1d00	; 0x1d00 <__vector_10>
      2c:	0c 94 3d 0e 	jmp	0x1c7a	; 0x1c7a <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 3b 10 	jmp	0x2076	; 0x2076 <__vector_13>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 97 1b 	jmp	0x372e	; 0x372e <__vector_15>
      40:	0c 94 6f 00 	jmp	0xde	; 0xde <__vector_16>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	17 e0       	ldi	r17, 0x07	; 7
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec e7       	ldi	r30, 0x7C	; 124
      68:	fc e3       	ldi	r31, 0x3C	; 60
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	ae 3c       	cpi	r26, 0xCE	; 206
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	27 e0       	ldi	r18, 0x07	; 7
      78:	ae ec       	ldi	r26, 0xCE	; 206
      7a:	b7 e0       	ldi	r27, 0x07	; 7
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a6 3f       	cpi	r26, 0xF6	; 246
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 2d 0d 	call	0x1a5a	; 0x1a5a <main>
      8a:	0c 94 3c 1e 	jmp	0x3c78	; 0x3c78 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <ADC_Init>:
	return Value;
}

void ADC_Disable(void)
{
	Clear_Bit(ADCSRA, 7);
      92:	87 b1       	in	r24, 0x07	; 7
      94:	8f 73       	andi	r24, 0x3F	; 63
      96:	80 64       	ori	r24, 0x40	; 64
      98:	87 b9       	out	0x07, r24	; 7
      9a:	87 b1       	in	r24, 0x07	; 7
      9c:	8f 7d       	andi	r24, 0xDF	; 223
      9e:	87 b9       	out	0x07, r24	; 7
      a0:	86 b1       	in	r24, 0x06	; 6
      a2:	80 62       	ori	r24, 0x20	; 32
      a4:	86 b9       	out	0x06, r24	; 6
      a6:	80 b7       	in	r24, 0x30	; 48
      a8:	8f 71       	andi	r24, 0x1F	; 31
      aa:	80 bf       	out	0x30, r24	; 48
      ac:	86 b1       	in	r24, 0x06	; 6
      ae:	87 60       	ori	r24, 0x07	; 7
      b0:	86 b9       	out	0x06, r24	; 6
      b2:	8f b7       	in	r24, 0x3f	; 63
      b4:	80 68       	ori	r24, 0x80	; 128
      b6:	8f bf       	out	0x3f, r24	; 63
      b8:	86 b1       	in	r24, 0x06	; 6
      ba:	88 60       	ori	r24, 0x08	; 8
      bc:	86 b9       	out	0x06, r24	; 6
      be:	86 b1       	in	r24, 0x06	; 6
      c0:	80 68       	ori	r24, 0x80	; 128
      c2:	86 b9       	out	0x06, r24	; 6
      c4:	08 95       	ret

000000c6 <ADC_Read>:
      c6:	97 b1       	in	r25, 0x07	; 7
      c8:	90 7e       	andi	r25, 0xE0	; 224
      ca:	89 2b       	or	r24, r25
      cc:	87 b9       	out	0x07, r24	; 7
      ce:	86 b1       	in	r24, 0x06	; 6
      d0:	80 64       	ori	r24, 0x40	; 64
      d2:	86 b9       	out	0x06, r24	; 6
      d4:	34 9b       	sbis	0x06, 4	; 6
      d6:	fe cf       	rjmp	.-4      	; 0xd4 <ADC_Read+0xe>
      d8:	84 b1       	in	r24, 0x04	; 4
      da:	95 b1       	in	r25, 0x05	; 5
      dc:	08 95       	ret

000000de <__vector_16>:
}

ISR(ADC_vect)
{
      de:	1f 92       	push	r1
      e0:	0f 92       	push	r0
      e2:	0f b6       	in	r0, 0x3f	; 63
      e4:	0f 92       	push	r0
      e6:	11 24       	eor	r1, r1
      e8:	2f 93       	push	r18
      ea:	3f 93       	push	r19
      ec:	4f 93       	push	r20
      ee:	5f 93       	push	r21
      f0:	6f 93       	push	r22
      f2:	7f 93       	push	r23
      f4:	8f 93       	push	r24
      f6:	9f 93       	push	r25
      f8:	af 93       	push	r26
      fa:	bf 93       	push	r27
      fc:	ef 93       	push	r30
      fe:	ff 93       	push	r31
	// Write the ADC handler here
	Temp = ADC_Read(PIN_7)*50/1024;
     100:	87 e0       	ldi	r24, 0x07	; 7
     102:	0e 94 63 00 	call	0xc6	; 0xc6 <ADC_Read>
     106:	22 e3       	ldi	r18, 0x32	; 50
     108:	ac 01       	movw	r20, r24
     10a:	24 9f       	mul	r18, r20
     10c:	c0 01       	movw	r24, r0
     10e:	25 9f       	mul	r18, r21
     110:	90 0d       	add	r25, r0
     112:	11 24       	eor	r1, r1
     114:	89 2f       	mov	r24, r25
     116:	99 27       	eor	r25, r25
     118:	86 95       	lsr	r24
     11a:	86 95       	lsr	r24
     11c:	90 93 cf 07 	sts	0x07CF, r25	; 0x8007cf <__data_end+0x1>
     120:	80 93 ce 07 	sts	0x07CE, r24	; 0x8007ce <__data_end>
	if(Temp >= 28)
     124:	4c 97       	sbiw	r24, 0x1c	; 28
     126:	38 f0       	brcs	.+14     	; 0x136 <__vector_16+0x58>
	DC_Motor1_START(100,Anti_Clock_Wise);
     128:	41 e0       	ldi	r20, 0x01	; 1
     12a:	60 e0       	ldi	r22, 0x00	; 0
     12c:	70 e0       	ldi	r23, 0x00	; 0
     12e:	88 ec       	ldi	r24, 0xC8	; 200
     130:	92 e4       	ldi	r25, 0x42	; 66
     132:	0e 94 fd 02 	call	0x5fa	; 0x5fa <DC_Motor1_START>
	if(Temp <= 21)
     136:	80 91 ce 07 	lds	r24, 0x07CE	; 0x8007ce <__data_end>
     13a:	90 91 cf 07 	lds	r25, 0x07CF	; 0x8007cf <__data_end+0x1>
     13e:	46 97       	sbiw	r24, 0x16	; 22
     140:	10 f4       	brcc	.+4      	; 0x146 <__vector_16+0x68>
	DC_Motor1_STOP();
     142:	0e 94 18 03 	call	0x630	; 0x630 <DC_Motor1_STOP>
}
     146:	ff 91       	pop	r31
     148:	ef 91       	pop	r30
     14a:	bf 91       	pop	r27
     14c:	af 91       	pop	r26
     14e:	9f 91       	pop	r25
     150:	8f 91       	pop	r24
     152:	7f 91       	pop	r23
     154:	6f 91       	pop	r22
     156:	5f 91       	pop	r21
     158:	4f 91       	pop	r20
     15a:	3f 91       	pop	r19
     15c:	2f 91       	pop	r18
     15e:	0f 90       	pop	r0
     160:	0f be       	out	0x3f, r0	; 63
     162:	0f 90       	pop	r0
     164:	1f 90       	pop	r1
     166:	18 95       	reti

00000168 <Buzzer_Init>:
     168:	41 e0       	ldi	r20, 0x01	; 1
     16a:	67 e0       	ldi	r22, 0x07	; 7
     16c:	82 e0       	ldi	r24, 0x02	; 2
     16e:	0e 94 23 03 	call	0x646	; 0x646 <DIO_SetPin_Dir>
     172:	41 e0       	ldi	r20, 0x01	; 1
     174:	67 e0       	ldi	r22, 0x07	; 7
     176:	82 e0       	ldi	r24, 0x02	; 2
     178:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
     17c:	08 95       	ret

0000017e <Buzzer_ON>:
     17e:	40 e0       	ldi	r20, 0x00	; 0
     180:	67 e0       	ldi	r22, 0x07	; 7
     182:	82 e0       	ldi	r24, 0x02	; 2
     184:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
     188:	08 95       	ret

0000018a <Buzzer_OFF>:
     18a:	41 e0       	ldi	r20, 0x01	; 1
     18c:	67 e0       	ldi	r22, 0x07	; 7
     18e:	82 e0       	ldi	r24, 0x02	; 2
     190:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
     194:	08 95       	ret

00000196 <Buzzer_Toggle>:
     196:	67 e0       	ldi	r22, 0x07	; 7
     198:	82 e0       	ldi	r24, 0x02	; 2
     19a:	0e 94 33 04 	call	0x866	; 0x866 <DIO_TogglePin_Value>
     19e:	08 95       	ret

000001a0 <emergency_case>:
extern Uint16 Temp;
extern f32 Dimmer_Value;
extern Uint8 Dimmer_Array[3];
extern Uint8 eme_check;

void emergency_case(void) {
     1a0:	cf 92       	push	r12
     1a2:	df 92       	push	r13
     1a4:	ef 92       	push	r14
     1a6:	ff 92       	push	r15
     1a8:	cf 93       	push	r28
     1aa:	df 93       	push	r29
        LCD_Clear(); // Clearing The LCD
     1ac:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
        LCD_Write_String("1.open lamps"); //Choosing 1 For Lamps
     1b0:	81 e7       	ldi	r24, 0x71	; 113
     1b2:	90 e0       	ldi	r25, 0x00	; 0
     1b4:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
        LCD_Goto(1, 0);
     1b8:	60 e0       	ldi	r22, 0x00	; 0
     1ba:	81 e0       	ldi	r24, 0x01	; 1
     1bc:	0e 94 83 0c 	call	0x1906	; 0x1906 <LCD_Goto>
        LCD_Write_String("2.more"); //Choosing 1 For more Options
     1c0:	8e e7       	ldi	r24, 0x7E	; 126
     1c2:	90 e0       	ldi	r25, 0x00	; 0
     1c4:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
        button = NULL_KEYPAD; // Initialize The Keypad button =0
     1c8:	10 92 d0 07 	sts	0x07D0, r1	; 0x8007d0 <button>

        while (!(button == '1' || button == '2') && eme_check) // Determine Our Choice (1 or 2)
     1cc:	04 c0       	rjmp	.+8      	; 0x1d6 <emergency_case+0x36>
                button = Keypad_GetValue();
     1ce:	0e 94 d7 0a 	call	0x15ae	; 0x15ae <Keypad_GetValue>
     1d2:	80 93 d0 07 	sts	0x07D0, r24	; 0x8007d0 <button>
        LCD_Write_String("1.open lamps"); //Choosing 1 For Lamps
        LCD_Goto(1, 0);
        LCD_Write_String("2.more"); //Choosing 1 For more Options
        button = NULL_KEYPAD; // Initialize The Keypad button =0

        while (!(button == '1' || button == '2') && eme_check) // Determine Our Choice (1 or 2)
     1d6:	80 91 d0 07 	lds	r24, 0x07D0	; 0x8007d0 <button>
     1da:	9f ec       	ldi	r25, 0xCF	; 207
     1dc:	98 0f       	add	r25, r24
     1de:	92 30       	cpi	r25, 0x02	; 2
     1e0:	20 f0       	brcs	.+8      	; 0x1ea <emergency_case+0x4a>
     1e2:	90 91 d1 07 	lds	r25, 0x07D1	; 0x8007d1 <eme_check>
     1e6:	91 11       	cpse	r25, r1
     1e8:	f2 cf       	rjmp	.-28     	; 0x1ce <emergency_case+0x2e>
                button = Keypad_GetValue();

        if (button == '1') { // If we Choose 1 in first we need to choose which lamp will open 
     1ea:	81 33       	cpi	r24, 0x31	; 49
     1ec:	09 f0       	breq	.+2      	; 0x1f0 <emergency_case+0x50>
     1ee:	68 c0       	rjmp	.+208    	; 0x2c0 <emergency_case+0x120>
                LCD_Clear();
     1f0:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                LCD_Write_String("1.lamp1  2.lamp2");
     1f4:	85 e8       	ldi	r24, 0x85	; 133
     1f6:	90 e0       	ldi	r25, 0x00	; 0
     1f8:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                LCD_Goto(1, 0);
     1fc:	60 e0       	ldi	r22, 0x00	; 0
     1fe:	81 e0       	ldi	r24, 0x01	; 1
     200:	0e 94 83 0c 	call	0x1906	; 0x1906 <LCD_Goto>
                LCD_Write_String("3.lamp3  4.more");
     204:	86 e9       	ldi	r24, 0x96	; 150
     206:	90 e0       	ldi	r25, 0x00	; 0
     208:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>

                button = NULL_KEYPAD;
     20c:	10 92 d0 07 	sts	0x07D0, r1	; 0x8007d0 <button>
                while (!(button == '1' || button == '2' || button == '3' || button == '4') && eme_check) // This For Choosing Which lamb to open
     210:	04 c0       	rjmp	.+8      	; 0x21a <emergency_case+0x7a>
                        button = Keypad_GetValue();
     212:	0e 94 d7 0a 	call	0x15ae	; 0x15ae <Keypad_GetValue>
     216:	80 93 d0 07 	sts	0x07D0, r24	; 0x8007d0 <button>
                LCD_Write_String("1.lamp1  2.lamp2");
                LCD_Goto(1, 0);
                LCD_Write_String("3.lamp3  4.more");

                button = NULL_KEYPAD;
                while (!(button == '1' || button == '2' || button == '3' || button == '4') && eme_check) // This For Choosing Which lamb to open
     21a:	80 91 d0 07 	lds	r24, 0x07D0	; 0x8007d0 <button>
     21e:	9f ec       	ldi	r25, 0xCF	; 207
     220:	98 0f       	add	r25, r24
     222:	94 30       	cpi	r25, 0x04	; 4
     224:	20 f0       	brcs	.+8      	; 0x22e <emergency_case+0x8e>
     226:	90 91 d1 07 	lds	r25, 0x07D1	; 0x8007d1 <eme_check>
     22a:	91 11       	cpse	r25, r1
     22c:	f2 cf       	rjmp	.-28     	; 0x212 <emergency_case+0x72>
                        button = Keypad_GetValue();
                /*   This Fuction For Opening Lambs   */
                if (button == '1') { // Lamb 1 will Open
     22e:	81 33       	cpi	r24, 0x31	; 49
     230:	19 f4       	brne	.+6      	; 0x238 <emergency_case+0x98>
                        LED0_ON();
     232:	0e 94 ac 0c 	call	0x1958	; 0x1958 <LED0_ON>
     236:	c5 c1       	rjmp	.+906    	; 0x5c2 <__EEPROM_REGION_LENGTH__+0x1c2>
                } else if (button == '2') { // Lamb 2 will Open
     238:	82 33       	cpi	r24, 0x32	; 50
     23a:	19 f4       	brne	.+6      	; 0x242 <emergency_case+0xa2>
                        LED1_ON();
     23c:	0e 94 c8 0c 	call	0x1990	; 0x1990 <LED1_ON>
     240:	c0 c1       	rjmp	.+896    	; 0x5c2 <__EEPROM_REGION_LENGTH__+0x1c2>
                } else if (button == '3') { // Lamb 3 will Open
     242:	83 33       	cpi	r24, 0x33	; 51
     244:	19 f4       	brne	.+6      	; 0x24c <emergency_case+0xac>
                        LED2_ON();
     246:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LED2_ON>
     24a:	bb c1       	rjmp	.+886    	; 0x5c2 <__EEPROM_REGION_LENGTH__+0x1c2>
                } else if (button == '4') { // Here to Show more options 
     24c:	84 33       	cpi	r24, 0x34	; 52
     24e:	09 f0       	breq	.+2      	; 0x252 <emergency_case+0xb2>
     250:	b8 c1       	rjmp	.+880    	; 0x5c2 <__EEPROM_REGION_LENGTH__+0x1c2>
                        LCD_Clear();
     252:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                        LCD_Write_String("1.lamp4  2.lamp5"); // The option is open Lamb 4 or 5 or all
     256:	86 ea       	ldi	r24, 0xA6	; 166
     258:	90 e0       	ldi	r25, 0x00	; 0
     25a:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                        LCD_Goto(1, 0);
     25e:	60 e0       	ldi	r22, 0x00	; 0
     260:	81 e0       	ldi	r24, 0x01	; 1
     262:	0e 94 83 0c 	call	0x1906	; 0x1906 <LCD_Goto>
                        LCD_Write_String("3.all lamps");
     266:	87 eb       	ldi	r24, 0xB7	; 183
     268:	90 e0       	ldi	r25, 0x00	; 0
     26a:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                        button = NULL_KEYPAD; // Initialize the keypad button =0
     26e:	10 92 d0 07 	sts	0x07D0, r1	; 0x8007d0 <button>
                        while (!(button == '1' || button == '2' || button == '3') && eme_check) // Choosing the Button To do The function
     272:	04 c0       	rjmp	.+8      	; 0x27c <emergency_case+0xdc>
                                button = Keypad_GetValue();
     274:	0e 94 d7 0a 	call	0x15ae	; 0x15ae <Keypad_GetValue>
     278:	80 93 d0 07 	sts	0x07D0, r24	; 0x8007d0 <button>
                        LCD_Clear();
                        LCD_Write_String("1.lamp4  2.lamp5"); // The option is open Lamb 4 or 5 or all
                        LCD_Goto(1, 0);
                        LCD_Write_String("3.all lamps");
                        button = NULL_KEYPAD; // Initialize the keypad button =0
                        while (!(button == '1' || button == '2' || button == '3') && eme_check) // Choosing the Button To do The function
     27c:	80 91 d0 07 	lds	r24, 0x07D0	; 0x8007d0 <button>
     280:	9f ec       	ldi	r25, 0xCF	; 207
     282:	98 0f       	add	r25, r24
     284:	93 30       	cpi	r25, 0x03	; 3
     286:	20 f0       	brcs	.+8      	; 0x290 <emergency_case+0xf0>
     288:	90 91 d1 07 	lds	r25, 0x07D1	; 0x8007d1 <eme_check>
     28c:	91 11       	cpse	r25, r1
     28e:	f2 cf       	rjmp	.-28     	; 0x274 <emergency_case+0xd4>
                                button = Keypad_GetValue();
                        if (button == '1') { // If We Choose 1 Lamb 4 Will open
     290:	81 33       	cpi	r24, 0x31	; 49
     292:	19 f4       	brne	.+6      	; 0x29a <emergency_case+0xfa>
                                LED3_ON();
     294:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <LED3_ON>
     298:	94 c1       	rjmp	.+808    	; 0x5c2 <__EEPROM_REGION_LENGTH__+0x1c2>
                        } else if (button == '2') { // If We Choose 2 Lamb 5 Will open
     29a:	82 33       	cpi	r24, 0x32	; 50
     29c:	19 f4       	brne	.+6      	; 0x2a4 <emergency_case+0x104>
                                LED4_ON();
     29e:	0e 94 1c 0d 	call	0x1a38	; 0x1a38 <LED4_ON>
     2a2:	8f c1       	rjmp	.+798    	; 0x5c2 <__EEPROM_REGION_LENGTH__+0x1c2>
                        } else if (button == '3') { // If We Choose 3 all Lambs Will open
     2a4:	83 33       	cpi	r24, 0x33	; 51
     2a6:	09 f0       	breq	.+2      	; 0x2aa <emergency_case+0x10a>
     2a8:	8c c1       	rjmp	.+792    	; 0x5c2 <__EEPROM_REGION_LENGTH__+0x1c2>
                                LED0_ON(); /* Opening all Lambs*/
     2aa:	0e 94 ac 0c 	call	0x1958	; 0x1958 <LED0_ON>
                                LED1_ON();
     2ae:	0e 94 c8 0c 	call	0x1990	; 0x1990 <LED1_ON>
                                LED2_ON();
     2b2:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LED2_ON>
                                LED3_ON();
     2b6:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <LED3_ON>
                                LED4_ON();
     2ba:	0e 94 1c 0d 	call	0x1a38	; 0x1a38 <LED4_ON>
     2be:	81 c1       	rjmp	.+770    	; 0x5c2 <__EEPROM_REGION_LENGTH__+0x1c2>
                        }
                }

        } else if (button == '2') // If We Choose 2 In first Choice This Will Open more Options
     2c0:	82 33       	cpi	r24, 0x32	; 50
     2c2:	09 f0       	breq	.+2      	; 0x2c6 <emergency_case+0x126>
     2c4:	7e c1       	rjmp	.+764    	; 0x5c2 <__EEPROM_REGION_LENGTH__+0x1c2>

        {
                LCD_Clear();
     2c6:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                LCD_Write_String("3.close lamps"); // Choosing 3 For Closing The Lambs
     2ca:	83 ec       	ldi	r24, 0xC3	; 195
     2cc:	90 e0       	ldi	r25, 0x00	; 0
     2ce:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                LCD_Goto(1, 0);
     2d2:	60 e0       	ldi	r22, 0x00	; 0
     2d4:	81 e0       	ldi	r24, 0x01	; 1
     2d6:	0e 94 83 0c 	call	0x1906	; 0x1906 <LCD_Goto>
                LCD_Write_String("4.more"); // Choosing 4 For more Options  
     2da:	8f e9       	ldi	r24, 0x9F	; 159
     2dc:	90 e0       	ldi	r25, 0x00	; 0
     2de:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                button = NULL_KEYPAD;
     2e2:	10 92 d0 07 	sts	0x07D0, r1	; 0x8007d0 <button>

                while (!(button == '3' || button == '4') && eme_check) // Determine Our Choice (3 or 4)
     2e6:	04 c0       	rjmp	.+8      	; 0x2f0 <emergency_case+0x150>
                        button = Keypad_GetValue();
     2e8:	0e 94 d7 0a 	call	0x15ae	; 0x15ae <Keypad_GetValue>
     2ec:	80 93 d0 07 	sts	0x07D0, r24	; 0x8007d0 <button>
                LCD_Write_String("3.close lamps"); // Choosing 3 For Closing The Lambs
                LCD_Goto(1, 0);
                LCD_Write_String("4.more"); // Choosing 4 For more Options  
                button = NULL_KEYPAD;

                while (!(button == '3' || button == '4') && eme_check) // Determine Our Choice (3 or 4)
     2f0:	80 91 d0 07 	lds	r24, 0x07D0	; 0x8007d0 <button>
     2f4:	9d ec       	ldi	r25, 0xCD	; 205
     2f6:	98 0f       	add	r25, r24
     2f8:	92 30       	cpi	r25, 0x02	; 2
     2fa:	20 f0       	brcs	.+8      	; 0x304 <emergency_case+0x164>
     2fc:	90 91 d1 07 	lds	r25, 0x07D1	; 0x8007d1 <eme_check>
     300:	91 11       	cpse	r25, r1
     302:	f2 cf       	rjmp	.-28     	; 0x2e8 <emergency_case+0x148>
                        button = Keypad_GetValue();

                if (button == '3') { // If We Choose 3 We Will Close Lambs
     304:	83 33       	cpi	r24, 0x33	; 51
     306:	09 f0       	breq	.+2      	; 0x30a <emergency_case+0x16a>
     308:	68 c0       	rjmp	.+208    	; 0x3da <emergency_case+0x23a>
                        LCD_Clear();
     30a:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                        LCD_Write_String("1.lamp1  2.lamp2");
     30e:	85 e8       	ldi	r24, 0x85	; 133
     310:	90 e0       	ldi	r25, 0x00	; 0
     312:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                        LCD_Goto(1, 0);
     316:	60 e0       	ldi	r22, 0x00	; 0
     318:	81 e0       	ldi	r24, 0x01	; 1
     31a:	0e 94 83 0c 	call	0x1906	; 0x1906 <LCD_Goto>
                        LCD_Write_String("3.lamp3  4.more");
     31e:	86 e9       	ldi	r24, 0x96	; 150
     320:	90 e0       	ldi	r25, 0x00	; 0
     322:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                        button = NULL_KEYPAD;
     326:	10 92 d0 07 	sts	0x07D0, r1	; 0x8007d0 <button>

                        while (!(button == '1' || button == '2' || button == '3' || button == '4') && eme_check) //This For Choosing Which lamb to Close
     32a:	04 c0       	rjmp	.+8      	; 0x334 <emergency_case+0x194>
                                button = Keypad_GetValue();
     32c:	0e 94 d7 0a 	call	0x15ae	; 0x15ae <Keypad_GetValue>
     330:	80 93 d0 07 	sts	0x07D0, r24	; 0x8007d0 <button>
                        LCD_Write_String("1.lamp1  2.lamp2");
                        LCD_Goto(1, 0);
                        LCD_Write_String("3.lamp3  4.more");
                        button = NULL_KEYPAD;

                        while (!(button == '1' || button == '2' || button == '3' || button == '4') && eme_check) //This For Choosing Which lamb to Close
     334:	80 91 d0 07 	lds	r24, 0x07D0	; 0x8007d0 <button>
     338:	9f ec       	ldi	r25, 0xCF	; 207
     33a:	98 0f       	add	r25, r24
     33c:	94 30       	cpi	r25, 0x04	; 4
     33e:	20 f0       	brcs	.+8      	; 0x348 <emergency_case+0x1a8>
     340:	90 91 d1 07 	lds	r25, 0x07D1	; 0x8007d1 <eme_check>
     344:	91 11       	cpse	r25, r1
     346:	f2 cf       	rjmp	.-28     	; 0x32c <emergency_case+0x18c>
                                button = Keypad_GetValue();

                        if (button == '1') { //Lamb 1 will Close
     348:	81 33       	cpi	r24, 0x31	; 49
     34a:	19 f4       	brne	.+6      	; 0x352 <emergency_case+0x1b2>
                                LED0_OFF();
     34c:	0e 94 b2 0c 	call	0x1964	; 0x1964 <LED0_OFF>
     350:	38 c1       	rjmp	.+624    	; 0x5c2 <__EEPROM_REGION_LENGTH__+0x1c2>
                        } else if (button == '2') { //Lamb 2 will Close
     352:	82 33       	cpi	r24, 0x32	; 50
     354:	19 f4       	brne	.+6      	; 0x35c <emergency_case+0x1bc>
                                LED1_OFF();
     356:	0e 94 ce 0c 	call	0x199c	; 0x199c <LED1_OFF>
     35a:	33 c1       	rjmp	.+614    	; 0x5c2 <__EEPROM_REGION_LENGTH__+0x1c2>
                        } else if (button == '3') { //Lamb 3 will Close
     35c:	83 33       	cpi	r24, 0x33	; 51
     35e:	19 f4       	brne	.+6      	; 0x366 <emergency_case+0x1c6>
                                LED2_OFF();
     360:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <LED2_OFF>
     364:	2e c1       	rjmp	.+604    	; 0x5c2 <__EEPROM_REGION_LENGTH__+0x1c2>
                        } else if (button == '4') { // Here to Show more options 
     366:	84 33       	cpi	r24, 0x34	; 52
     368:	09 f0       	breq	.+2      	; 0x36c <emergency_case+0x1cc>
     36a:	2b c1       	rjmp	.+598    	; 0x5c2 <__EEPROM_REGION_LENGTH__+0x1c2>
                                LCD_Clear();
     36c:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                LCD_Write_String("1.lamp4  2.lamp5"); // The option is Close Lamb 4 or 5 or all
     370:	86 ea       	ldi	r24, 0xA6	; 166
     372:	90 e0       	ldi	r25, 0x00	; 0
     374:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                                LCD_Goto(1, 0);
     378:	60 e0       	ldi	r22, 0x00	; 0
     37a:	81 e0       	ldi	r24, 0x01	; 1
     37c:	0e 94 83 0c 	call	0x1906	; 0x1906 <LCD_Goto>
                                LCD_Write_String("3.all lamps");
     380:	87 eb       	ldi	r24, 0xB7	; 183
     382:	90 e0       	ldi	r25, 0x00	; 0
     384:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                                button = NULL_KEYPAD;
     388:	10 92 d0 07 	sts	0x07D0, r1	; 0x8007d0 <button>

                                while (!(button == '1' || button == '2' || button == '3') && eme_check) // Choosing the Button To do The function
     38c:	04 c0       	rjmp	.+8      	; 0x396 <emergency_case+0x1f6>
                                        button = Keypad_GetValue();
     38e:	0e 94 d7 0a 	call	0x15ae	; 0x15ae <Keypad_GetValue>
     392:	80 93 d0 07 	sts	0x07D0, r24	; 0x8007d0 <button>
                                LCD_Write_String("1.lamp4  2.lamp5"); // The option is Close Lamb 4 or 5 or all
                                LCD_Goto(1, 0);
                                LCD_Write_String("3.all lamps");
                                button = NULL_KEYPAD;

                                while (!(button == '1' || button == '2' || button == '3') && eme_check) // Choosing the Button To do The function
     396:	80 91 d0 07 	lds	r24, 0x07D0	; 0x8007d0 <button>
     39a:	9f ec       	ldi	r25, 0xCF	; 207
     39c:	98 0f       	add	r25, r24
     39e:	93 30       	cpi	r25, 0x03	; 3
     3a0:	20 f0       	brcs	.+8      	; 0x3aa <emergency_case+0x20a>
     3a2:	90 91 d1 07 	lds	r25, 0x07D1	; 0x8007d1 <eme_check>
     3a6:	91 11       	cpse	r25, r1
     3a8:	f2 cf       	rjmp	.-28     	; 0x38e <emergency_case+0x1ee>
                                        button = Keypad_GetValue();

                                if (button == '1') { // If We Choose 1 Lamb 4 Will Close
     3aa:	81 33       	cpi	r24, 0x31	; 49
     3ac:	19 f4       	brne	.+6      	; 0x3b4 <emergency_case+0x214>
                                        LED3_OFF();
     3ae:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <LED3_OFF>
     3b2:	07 c1       	rjmp	.+526    	; 0x5c2 <__EEPROM_REGION_LENGTH__+0x1c2>
                                } else if (button == '2') { // If We Choose 2 Lamb 5 Will Close
     3b4:	82 33       	cpi	r24, 0x32	; 50
     3b6:	19 f4       	brne	.+6      	; 0x3be <emergency_case+0x21e>
                                        LED4_OFF();
     3b8:	0e 94 22 0d 	call	0x1a44	; 0x1a44 <LED4_OFF>
     3bc:	02 c1       	rjmp	.+516    	; 0x5c2 <__EEPROM_REGION_LENGTH__+0x1c2>
                                } else if (button == '3') { // If We Choose 3 all Lambs Will Close
     3be:	83 33       	cpi	r24, 0x33	; 51
     3c0:	09 f0       	breq	.+2      	; 0x3c4 <emergency_case+0x224>
     3c2:	ff c0       	rjmp	.+510    	; 0x5c2 <__EEPROM_REGION_LENGTH__+0x1c2>
                                        LED0_OFF();
     3c4:	0e 94 b2 0c 	call	0x1964	; 0x1964 <LED0_OFF>
                                        LED1_OFF();
     3c8:	0e 94 ce 0c 	call	0x199c	; 0x199c <LED1_OFF>
                                        LED2_OFF();
     3cc:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <LED2_OFF>
                                        LED3_OFF();
     3d0:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <LED3_OFF>
                                        LED4_OFF();
     3d4:	0e 94 22 0d 	call	0x1a44	; 0x1a44 <LED4_OFF>
     3d8:	f4 c0       	rjmp	.+488    	; 0x5c2 <__EEPROM_REGION_LENGTH__+0x1c2>
                                }
                        }

                } else if (button == '4') { // If We Choose 4 In Second Choice This Will Open more Options
     3da:	84 33       	cpi	r24, 0x34	; 52
     3dc:	09 f0       	breq	.+2      	; 0x3e0 <emergency_case+0x240>
     3de:	f1 c0       	rjmp	.+482    	; 0x5c2 <__EEPROM_REGION_LENGTH__+0x1c2>
                        LCD_Clear();
     3e0:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                        LCD_Write_String("5.variant lamp"); // Choosing 5 For Variant Lamb 
     3e4:	81 ed       	ldi	r24, 0xD1	; 209
     3e6:	90 e0       	ldi	r25, 0x00	; 0
     3e8:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                        LCD_Goto(1, 0);
     3ec:	60 e0       	ldi	r22, 0x00	; 0
     3ee:	81 e0       	ldi	r24, 0x01	; 1
     3f0:	0e 94 83 0c 	call	0x1906	; 0x1906 <LCD_Goto>
                        LCD_Write_String("6.Display temp"); // Choosing 6 For Display Temperature
     3f4:	80 ee       	ldi	r24, 0xE0	; 224
     3f6:	90 e0       	ldi	r25, 0x00	; 0
     3f8:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                        button = NULL_KEYPAD;
     3fc:	10 92 d0 07 	sts	0x07D0, r1	; 0x8007d0 <button>

                        while (!(button == '5' || button == '6') && eme_check) // Determine Our Choice (5 or 6)
     400:	04 c0       	rjmp	.+8      	; 0x40a <__EEPROM_REGION_LENGTH__+0xa>
                                button = Keypad_GetValue();
     402:	0e 94 d7 0a 	call	0x15ae	; 0x15ae <Keypad_GetValue>
     406:	80 93 d0 07 	sts	0x07D0, r24	; 0x8007d0 <button>
                        LCD_Write_String("5.variant lamp"); // Choosing 5 For Variant Lamb 
                        LCD_Goto(1, 0);
                        LCD_Write_String("6.Display temp"); // Choosing 6 For Display Temperature
                        button = NULL_KEYPAD;

                        while (!(button == '5' || button == '6') && eme_check) // Determine Our Choice (5 or 6)
     40a:	80 91 d0 07 	lds	r24, 0x07D0	; 0x8007d0 <button>
     40e:	9b ec       	ldi	r25, 0xCB	; 203
     410:	98 0f       	add	r25, r24
     412:	92 30       	cpi	r25, 0x02	; 2
     414:	20 f0       	brcs	.+8      	; 0x41e <__EEPROM_REGION_LENGTH__+0x1e>
     416:	90 91 d1 07 	lds	r25, 0x07D1	; 0x8007d1 <eme_check>
     41a:	91 11       	cpse	r25, r1
     41c:	f2 cf       	rjmp	.-28     	; 0x402 <__EEPROM_REGION_LENGTH__+0x2>
                                button = Keypad_GetValue();

                        if (button == '5') { // Choosing 5 for Determine The percentage of variant Lambs
     41e:	85 33       	cpi	r24, 0x35	; 53
     420:	09 f0       	breq	.+2      	; 0x424 <__EEPROM_REGION_LENGTH__+0x24>
     422:	b6 c0       	rjmp	.+364    	; 0x590 <__EEPROM_REGION_LENGTH__+0x190>
                                LCD_Clear();
     424:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                LCD_Write_String("Please enter the");
     428:	8f ee       	ldi	r24, 0xEF	; 239
     42a:	90 e0       	ldi	r25, 0x00	; 0
     42c:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                                LCD_Goto(1, 0);
     430:	60 e0       	ldi	r22, 0x00	; 0
     432:	81 e0       	ldi	r24, 0x01	; 1
     434:	0e 94 83 0c 	call	0x1906	; 0x1906 <LCD_Goto>
                                LCD_Write_String("% of the lamp");
     438:	80 e0       	ldi	r24, 0x00	; 0
     43a:	91 e0       	ldi	r25, 0x01	; 1
     43c:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                                button = NULL_KEYPAD;
     440:	10 92 d0 07 	sts	0x07D0, r1	; 0x8007d0 <button>
                                Dimmer_Value = 0; // Variable For Dimmer (Variant lamb)
     444:	10 92 e9 07 	sts	0x07E9, r1	; 0x8007e9 <Dimmer_Value>
     448:	10 92 ea 07 	sts	0x07EA, r1	; 0x8007ea <Dimmer_Value+0x1>
     44c:	10 92 eb 07 	sts	0x07EB, r1	; 0x8007eb <Dimmer_Value+0x2>
     450:	10 92 ec 07 	sts	0x07EC, r1	; 0x8007ec <Dimmer_Value+0x3>
                                /* Function For Determine The Percentage */
                                for (Uint8 i = 0; i < 3; i++) {
     454:	d0 e0       	ldi	r29, 0x00	; 0
     456:	45 c0       	rjmp	.+138    	; 0x4e2 <__EEPROM_REGION_LENGTH__+0xe2>
                                        button = NULL_KEYPAD;
     458:	10 92 d0 07 	sts	0x07D0, r1	; 0x8007d0 <button>

                                        while (!(button >= '0' && button <= '9' || button == '*' || button == '#') && eme_check) { // Clicking The Keypad Button For Determine The Percentage
     45c:	04 c0       	rjmp	.+8      	; 0x466 <__EEPROM_REGION_LENGTH__+0x66>
                                                button = Keypad_GetValue();
     45e:	0e 94 d7 0a 	call	0x15ae	; 0x15ae <Keypad_GetValue>
     462:	80 93 d0 07 	sts	0x07D0, r24	; 0x8007d0 <button>
                                Dimmer_Value = 0; // Variable For Dimmer (Variant lamb)
                                /* Function For Determine The Percentage */
                                for (Uint8 i = 0; i < 3; i++) {
                                        button = NULL_KEYPAD;

                                        while (!(button >= '0' && button <= '9' || button == '*' || button == '#') && eme_check) { // Clicking The Keypad Button For Determine The Percentage
     466:	c0 91 d0 07 	lds	r28, 0x07D0	; 0x8007d0 <button>
     46a:	80 ed       	ldi	r24, 0xD0	; 208
     46c:	8c 0f       	add	r24, r28
     46e:	8a 30       	cpi	r24, 0x0A	; 10
     470:	40 f0       	brcs	.+16     	; 0x482 <__EEPROM_REGION_LENGTH__+0x82>
     472:	ca 32       	cpi	r28, 0x2A	; 42
     474:	31 f0       	breq	.+12     	; 0x482 <__EEPROM_REGION_LENGTH__+0x82>
     476:	c3 32       	cpi	r28, 0x23	; 35
     478:	21 f0       	breq	.+8      	; 0x482 <__EEPROM_REGION_LENGTH__+0x82>
     47a:	90 91 d1 07 	lds	r25, 0x07D1	; 0x8007d1 <eme_check>
     47e:	91 11       	cpse	r25, r1
     480:	ee cf       	rjmp	.-36     	; 0x45e <__EEPROM_REGION_LENGTH__+0x5e>
                                                button = Keypad_GetValue();
                                        }

                                        Dimmer_Array[i] = button; // Equaling The Value of Keypad Button to An Array
     482:	ed 2f       	mov	r30, r29
     484:	f0 e0       	ldi	r31, 0x00	; 0
     486:	e3 51       	subi	r30, 0x13	; 19
     488:	f8 4f       	sbci	r31, 0xF8	; 248
     48a:	c0 83       	st	Z, r28

                                        if (Dimmer_Array[i] >= 48 && Dimmer_Array[i] <= 57) { // This for Choosing The Value from 0 to 9
     48c:	8a 30       	cpi	r24, 0x0A	; 10
     48e:	38 f5       	brcc	.+78     	; 0x4de <__EEPROM_REGION_LENGTH__+0xde>
                                                Dimmer_Value = Dimmer_Value * 10 + (Dimmer_Array[i] - 48); // Taking The value of dimmer and multiply by 10 the anding the value of dimmer array 
     490:	20 e0       	ldi	r18, 0x00	; 0
     492:	30 e0       	ldi	r19, 0x00	; 0
     494:	40 e2       	ldi	r20, 0x20	; 32
     496:	51 e4       	ldi	r21, 0x41	; 65
     498:	60 91 e9 07 	lds	r22, 0x07E9	; 0x8007e9 <Dimmer_Value>
     49c:	70 91 ea 07 	lds	r23, 0x07EA	; 0x8007ea <Dimmer_Value+0x1>
     4a0:	80 91 eb 07 	lds	r24, 0x07EB	; 0x8007eb <Dimmer_Value+0x2>
     4a4:	90 91 ec 07 	lds	r25, 0x07EC	; 0x8007ec <Dimmer_Value+0x3>
     4a8:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <__mulsf3>
     4ac:	6b 01       	movw	r12, r22
     4ae:	7c 01       	movw	r14, r24
     4b0:	6c 2f       	mov	r22, r28
     4b2:	70 e0       	ldi	r23, 0x00	; 0
     4b4:	60 53       	subi	r22, 0x30	; 48
     4b6:	71 09       	sbc	r23, r1
     4b8:	07 2e       	mov	r0, r23
     4ba:	00 0c       	add	r0, r0
     4bc:	88 0b       	sbc	r24, r24
     4be:	99 0b       	sbc	r25, r25
     4c0:	0e 94 b6 1c 	call	0x396c	; 0x396c <__floatsisf>
     4c4:	a7 01       	movw	r20, r14
     4c6:	96 01       	movw	r18, r12
     4c8:	0e 94 a2 1b 	call	0x3744	; 0x3744 <__addsf3>
     4cc:	60 93 e9 07 	sts	0x07E9, r22	; 0x8007e9 <Dimmer_Value>
     4d0:	70 93 ea 07 	sts	0x07EA, r23	; 0x8007ea <Dimmer_Value+0x1>
     4d4:	80 93 eb 07 	sts	0x07EB, r24	; 0x8007eb <Dimmer_Value+0x2>
     4d8:	90 93 ec 07 	sts	0x07EC, r25	; 0x8007ec <Dimmer_Value+0x3>
     4dc:	01 c0       	rjmp	.+2      	; 0x4e0 <__EEPROM_REGION_LENGTH__+0xe0>
                                        } else {
                                                i = 5;
     4de:	d5 e0       	ldi	r29, 0x05	; 5
                                LCD_Goto(1, 0);
                                LCD_Write_String("% of the lamp");
                                button = NULL_KEYPAD;
                                Dimmer_Value = 0; // Variable For Dimmer (Variant lamb)
                                /* Function For Determine The Percentage */
                                for (Uint8 i = 0; i < 3; i++) {
     4e0:	df 5f       	subi	r29, 0xFF	; 255
     4e2:	d3 30       	cpi	r29, 0x03	; 3
     4e4:	08 f4       	brcc	.+2      	; 0x4e8 <__EEPROM_REGION_LENGTH__+0xe8>
     4e6:	b8 cf       	rjmp	.-144    	; 0x458 <__EEPROM_REGION_LENGTH__+0x58>
                                        } else {
                                                i = 5;
                                        }
                                }
                                // To avoid twitch  of dimmer Lamb 
                                if (Dimmer_Value >= 58 && Dimmer_Value <= 60) {
     4e8:	c0 90 e9 07 	lds	r12, 0x07E9	; 0x8007e9 <Dimmer_Value>
     4ec:	d0 90 ea 07 	lds	r13, 0x07EA	; 0x8007ea <Dimmer_Value+0x1>
     4f0:	e0 90 eb 07 	lds	r14, 0x07EB	; 0x8007eb <Dimmer_Value+0x2>
     4f4:	f0 90 ec 07 	lds	r15, 0x07EC	; 0x8007ec <Dimmer_Value+0x3>
     4f8:	20 e0       	ldi	r18, 0x00	; 0
     4fa:	30 e0       	ldi	r19, 0x00	; 0
     4fc:	48 e6       	ldi	r20, 0x68	; 104
     4fe:	52 e4       	ldi	r21, 0x42	; 66
     500:	c7 01       	movw	r24, r14
     502:	b6 01       	movw	r22, r12
     504:	0e 94 66 1d 	call	0x3acc	; 0x3acc <__gesf2>
     508:	88 23       	and	r24, r24
     50a:	bc f0       	brlt	.+46     	; 0x53a <__EEPROM_REGION_LENGTH__+0x13a>
     50c:	20 e0       	ldi	r18, 0x00	; 0
     50e:	30 e0       	ldi	r19, 0x00	; 0
     510:	40 e7       	ldi	r20, 0x70	; 112
     512:	52 e4       	ldi	r21, 0x42	; 66
     514:	c7 01       	movw	r24, r14
     516:	b6 01       	movw	r22, r12
     518:	0e 94 0e 1c 	call	0x381c	; 0x381c <__cmpsf2>
     51c:	18 16       	cp	r1, r24
     51e:	6c f0       	brlt	.+26     	; 0x53a <__EEPROM_REGION_LENGTH__+0x13a>
                                        Dimmer_Value = 55;
     520:	80 e0       	ldi	r24, 0x00	; 0
     522:	90 e0       	ldi	r25, 0x00	; 0
     524:	ac e5       	ldi	r26, 0x5C	; 92
     526:	b2 e4       	ldi	r27, 0x42	; 66
     528:	80 93 e9 07 	sts	0x07E9, r24	; 0x8007e9 <Dimmer_Value>
     52c:	90 93 ea 07 	sts	0x07EA, r25	; 0x8007ea <Dimmer_Value+0x1>
     530:	a0 93 eb 07 	sts	0x07EB, r26	; 0x8007eb <Dimmer_Value+0x2>
     534:	b0 93 ec 07 	sts	0x07EC, r27	; 0x8007ec <Dimmer_Value+0x3>
     538:	20 c0       	rjmp	.+64     	; 0x57a <__EEPROM_REGION_LENGTH__+0x17a>
                                } else if (Dimmer_Value > 60 && Dimmer_Value <= 62) {
     53a:	20 e0       	ldi	r18, 0x00	; 0
     53c:	30 e0       	ldi	r19, 0x00	; 0
     53e:	40 e7       	ldi	r20, 0x70	; 112
     540:	52 e4       	ldi	r21, 0x42	; 66
     542:	c7 01       	movw	r24, r14
     544:	b6 01       	movw	r22, r12
     546:	0e 94 66 1d 	call	0x3acc	; 0x3acc <__gesf2>
     54a:	18 16       	cp	r1, r24
     54c:	b4 f4       	brge	.+44     	; 0x57a <__EEPROM_REGION_LENGTH__+0x17a>
     54e:	20 e0       	ldi	r18, 0x00	; 0
     550:	30 e0       	ldi	r19, 0x00	; 0
     552:	48 e7       	ldi	r20, 0x78	; 120
     554:	52 e4       	ldi	r21, 0x42	; 66
     556:	c7 01       	movw	r24, r14
     558:	b6 01       	movw	r22, r12
     55a:	0e 94 0e 1c 	call	0x381c	; 0x381c <__cmpsf2>
     55e:	18 16       	cp	r1, r24
     560:	64 f0       	brlt	.+24     	; 0x57a <__EEPROM_REGION_LENGTH__+0x17a>
                                        Dimmer_Value = 65;
     562:	80 e0       	ldi	r24, 0x00	; 0
     564:	90 e0       	ldi	r25, 0x00	; 0
     566:	a2 e8       	ldi	r26, 0x82	; 130
     568:	b2 e4       	ldi	r27, 0x42	; 66
     56a:	80 93 e9 07 	sts	0x07E9, r24	; 0x8007e9 <Dimmer_Value>
     56e:	90 93 ea 07 	sts	0x07EA, r25	; 0x8007ea <Dimmer_Value+0x1>
     572:	a0 93 eb 07 	sts	0x07EB, r26	; 0x8007eb <Dimmer_Value+0x2>
     576:	b0 93 ec 07 	sts	0x07EC, r27	; 0x8007ec <Dimmer_Value+0x3>
                                }

                                PWM0_Gen(Dimmer_Value);
     57a:	60 91 e9 07 	lds	r22, 0x07E9	; 0x8007e9 <Dimmer_Value>
     57e:	70 91 ea 07 	lds	r23, 0x07EA	; 0x8007ea <Dimmer_Value+0x1>
     582:	80 91 eb 07 	lds	r24, 0x07EB	; 0x8007eb <Dimmer_Value+0x2>
     586:	90 91 ec 07 	lds	r25, 0x07EC	; 0x8007ec <Dimmer_Value+0x3>
     58a:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <PWM0_Gen>
     58e:	19 c0       	rjmp	.+50     	; 0x5c2 <__EEPROM_REGION_LENGTH__+0x1c2>
                        } else if (button == '6') { // Choosing 6 Will Display The Temperature  
     590:	86 33       	cpi	r24, 0x36	; 54
     592:	b9 f4       	brne	.+46     	; 0x5c2 <__EEPROM_REGION_LENGTH__+0x1c2>
                                // Display temperature
                                LCD_Clear();
     594:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                LCD_Write_String("Temperature:");
     598:	8e e0       	ldi	r24, 0x0E	; 14
     59a:	91 e0       	ldi	r25, 0x01	; 1
     59c:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                                LCD_Write_Integer(Temp);
     5a0:	60 91 ce 07 	lds	r22, 0x07CE	; 0x8007ce <__data_end>
     5a4:	70 91 cf 07 	lds	r23, 0x07CF	; 0x8007cf <__data_end+0x1>
     5a8:	80 e0       	ldi	r24, 0x00	; 0
     5aa:	90 e0       	ldi	r25, 0x00	; 0
     5ac:	0e 94 0c 0c 	call	0x1818	; 0x1818 <LCD_Write_Integer>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     5b0:	2f ef       	ldi	r18, 0xFF	; 255
     5b2:	83 ed       	ldi	r24, 0xD3	; 211
     5b4:	90 e3       	ldi	r25, 0x30	; 48
     5b6:	21 50       	subi	r18, 0x01	; 1
     5b8:	80 40       	sbci	r24, 0x00	; 0
     5ba:	90 40       	sbci	r25, 0x00	; 0
     5bc:	e1 f7       	brne	.-8      	; 0x5b6 <__EEPROM_REGION_LENGTH__+0x1b6>
     5be:	00 c0       	rjmp	.+0      	; 0x5c0 <__EEPROM_REGION_LENGTH__+0x1c0>
     5c0:	00 00       	nop

                                _delay_ms(1000);
                        }
                }
        }
     5c2:	df 91       	pop	r29
     5c4:	cf 91       	pop	r28
     5c6:	ff 90       	pop	r15
     5c8:	ef 90       	pop	r14
     5ca:	df 90       	pop	r13
     5cc:	cf 90       	pop	r12
     5ce:	08 95       	ret

000005d0 <DC_Motor1_INIT>:
     5d0:	41 e0       	ldi	r20, 0x01	; 1
     5d2:	63 e0       	ldi	r22, 0x03	; 3
     5d4:	83 e0       	ldi	r24, 0x03	; 3
     5d6:	0e 94 23 03 	call	0x646	; 0x646 <DIO_SetPin_Dir>
     5da:	41 e0       	ldi	r20, 0x01	; 1
     5dc:	66 e0       	ldi	r22, 0x06	; 6
     5de:	83 e0       	ldi	r24, 0x03	; 3
     5e0:	0e 94 23 03 	call	0x646	; 0x646 <DIO_SetPin_Dir>
     5e4:	41 e0       	ldi	r20, 0x01	; 1
     5e6:	63 e0       	ldi	r22, 0x03	; 3
     5e8:	83 e0       	ldi	r24, 0x03	; 3
     5ea:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
     5ee:	41 e0       	ldi	r20, 0x01	; 1
     5f0:	66 e0       	ldi	r22, 0x06	; 6
     5f2:	83 e0       	ldi	r24, 0x03	; 3
     5f4:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
     5f8:	08 95       	ret

000005fa <DC_Motor1_START>:
     5fa:	44 23       	and	r20, r20
     5fc:	19 f0       	breq	.+6      	; 0x604 <DC_Motor1_START+0xa>
     5fe:	41 30       	cpi	r20, 0x01	; 1
     600:	61 f0       	breq	.+24     	; 0x61a <DC_Motor1_START+0x20>
     602:	08 95       	ret
     604:	40 e0       	ldi	r20, 0x00	; 0
     606:	63 e0       	ldi	r22, 0x03	; 3
     608:	83 e0       	ldi	r24, 0x03	; 3
     60a:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
     60e:	41 e0       	ldi	r20, 0x01	; 1
     610:	66 e0       	ldi	r22, 0x06	; 6
     612:	83 e0       	ldi	r24, 0x03	; 3
     614:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
     618:	08 95       	ret
     61a:	41 e0       	ldi	r20, 0x01	; 1
     61c:	63 e0       	ldi	r22, 0x03	; 3
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
     624:	40 e0       	ldi	r20, 0x00	; 0
     626:	66 e0       	ldi	r22, 0x06	; 6
     628:	83 e0       	ldi	r24, 0x03	; 3
     62a:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
     62e:	08 95       	ret

00000630 <DC_Motor1_STOP>:
     630:	41 e0       	ldi	r20, 0x01	; 1
     632:	63 e0       	ldi	r22, 0x03	; 3
     634:	83 e0       	ldi	r24, 0x03	; 3
     636:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
     63a:	41 e0       	ldi	r20, 0x01	; 1
     63c:	66 e0       	ldi	r22, 0x06	; 6
     63e:	83 e0       	ldi	r24, 0x03	; 3
     640:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
     644:	08 95       	ret

00000646 <DIO_SetPin_Dir>:
     646:	44 23       	and	r20, r20
     648:	19 f0       	breq	.+6      	; 0x650 <DIO_SetPin_Dir+0xa>
     64a:	41 30       	cpi	r20, 0x01	; 1
     64c:	c9 f1       	breq	.+114    	; 0x6c0 <DIO_SetPin_Dir+0x7a>
     64e:	08 95       	ret
     650:	81 30       	cpi	r24, 0x01	; 1
     652:	91 f0       	breq	.+36     	; 0x678 <DIO_SetPin_Dir+0x32>
     654:	28 f0       	brcs	.+10     	; 0x660 <DIO_SetPin_Dir+0x1a>
     656:	82 30       	cpi	r24, 0x02	; 2
     658:	d9 f0       	breq	.+54     	; 0x690 <DIO_SetPin_Dir+0x4a>
     65a:	83 30       	cpi	r24, 0x03	; 3
     65c:	29 f1       	breq	.+74     	; 0x6a8 <DIO_SetPin_Dir+0x62>
     65e:	08 95       	ret
     660:	2a b3       	in	r18, 0x1a	; 26
     662:	81 e0       	ldi	r24, 0x01	; 1
     664:	90 e0       	ldi	r25, 0x00	; 0
     666:	02 c0       	rjmp	.+4      	; 0x66c <DIO_SetPin_Dir+0x26>
     668:	88 0f       	add	r24, r24
     66a:	99 1f       	adc	r25, r25
     66c:	6a 95       	dec	r22
     66e:	e2 f7       	brpl	.-8      	; 0x668 <DIO_SetPin_Dir+0x22>
     670:	80 95       	com	r24
     672:	82 23       	and	r24, r18
     674:	8a bb       	out	0x1a, r24	; 26
     676:	08 95       	ret
     678:	27 b3       	in	r18, 0x17	; 23
     67a:	81 e0       	ldi	r24, 0x01	; 1
     67c:	90 e0       	ldi	r25, 0x00	; 0
     67e:	02 c0       	rjmp	.+4      	; 0x684 <DIO_SetPin_Dir+0x3e>
     680:	88 0f       	add	r24, r24
     682:	99 1f       	adc	r25, r25
     684:	6a 95       	dec	r22
     686:	e2 f7       	brpl	.-8      	; 0x680 <DIO_SetPin_Dir+0x3a>
     688:	80 95       	com	r24
     68a:	82 23       	and	r24, r18
     68c:	87 bb       	out	0x17, r24	; 23
     68e:	08 95       	ret
     690:	24 b3       	in	r18, 0x14	; 20
     692:	81 e0       	ldi	r24, 0x01	; 1
     694:	90 e0       	ldi	r25, 0x00	; 0
     696:	02 c0       	rjmp	.+4      	; 0x69c <DIO_SetPin_Dir+0x56>
     698:	88 0f       	add	r24, r24
     69a:	99 1f       	adc	r25, r25
     69c:	6a 95       	dec	r22
     69e:	e2 f7       	brpl	.-8      	; 0x698 <DIO_SetPin_Dir+0x52>
     6a0:	80 95       	com	r24
     6a2:	82 23       	and	r24, r18
     6a4:	84 bb       	out	0x14, r24	; 20
     6a6:	08 95       	ret
     6a8:	21 b3       	in	r18, 0x11	; 17
     6aa:	81 e0       	ldi	r24, 0x01	; 1
     6ac:	90 e0       	ldi	r25, 0x00	; 0
     6ae:	02 c0       	rjmp	.+4      	; 0x6b4 <DIO_SetPin_Dir+0x6e>
     6b0:	88 0f       	add	r24, r24
     6b2:	99 1f       	adc	r25, r25
     6b4:	6a 95       	dec	r22
     6b6:	e2 f7       	brpl	.-8      	; 0x6b0 <DIO_SetPin_Dir+0x6a>
     6b8:	80 95       	com	r24
     6ba:	82 23       	and	r24, r18
     6bc:	81 bb       	out	0x11, r24	; 17
     6be:	08 95       	ret
     6c0:	81 30       	cpi	r24, 0x01	; 1
     6c2:	89 f0       	breq	.+34     	; 0x6e6 <DIO_SetPin_Dir+0xa0>
     6c4:	28 f0       	brcs	.+10     	; 0x6d0 <DIO_SetPin_Dir+0x8a>
     6c6:	82 30       	cpi	r24, 0x02	; 2
     6c8:	c9 f0       	breq	.+50     	; 0x6fc <DIO_SetPin_Dir+0xb6>
     6ca:	83 30       	cpi	r24, 0x03	; 3
     6cc:	11 f1       	breq	.+68     	; 0x712 <DIO_SetPin_Dir+0xcc>
     6ce:	08 95       	ret
     6d0:	2a b3       	in	r18, 0x1a	; 26
     6d2:	81 e0       	ldi	r24, 0x01	; 1
     6d4:	90 e0       	ldi	r25, 0x00	; 0
     6d6:	02 c0       	rjmp	.+4      	; 0x6dc <DIO_SetPin_Dir+0x96>
     6d8:	88 0f       	add	r24, r24
     6da:	99 1f       	adc	r25, r25
     6dc:	6a 95       	dec	r22
     6de:	e2 f7       	brpl	.-8      	; 0x6d8 <DIO_SetPin_Dir+0x92>
     6e0:	82 2b       	or	r24, r18
     6e2:	8a bb       	out	0x1a, r24	; 26
     6e4:	08 95       	ret
     6e6:	27 b3       	in	r18, 0x17	; 23
     6e8:	81 e0       	ldi	r24, 0x01	; 1
     6ea:	90 e0       	ldi	r25, 0x00	; 0
     6ec:	02 c0       	rjmp	.+4      	; 0x6f2 <DIO_SetPin_Dir+0xac>
     6ee:	88 0f       	add	r24, r24
     6f0:	99 1f       	adc	r25, r25
     6f2:	6a 95       	dec	r22
     6f4:	e2 f7       	brpl	.-8      	; 0x6ee <DIO_SetPin_Dir+0xa8>
     6f6:	82 2b       	or	r24, r18
     6f8:	87 bb       	out	0x17, r24	; 23
     6fa:	08 95       	ret
     6fc:	24 b3       	in	r18, 0x14	; 20
     6fe:	81 e0       	ldi	r24, 0x01	; 1
     700:	90 e0       	ldi	r25, 0x00	; 0
     702:	02 c0       	rjmp	.+4      	; 0x708 <DIO_SetPin_Dir+0xc2>
     704:	88 0f       	add	r24, r24
     706:	99 1f       	adc	r25, r25
     708:	6a 95       	dec	r22
     70a:	e2 f7       	brpl	.-8      	; 0x704 <DIO_SetPin_Dir+0xbe>
     70c:	82 2b       	or	r24, r18
     70e:	84 bb       	out	0x14, r24	; 20
     710:	08 95       	ret
     712:	21 b3       	in	r18, 0x11	; 17
     714:	81 e0       	ldi	r24, 0x01	; 1
     716:	90 e0       	ldi	r25, 0x00	; 0
     718:	02 c0       	rjmp	.+4      	; 0x71e <DIO_SetPin_Dir+0xd8>
     71a:	88 0f       	add	r24, r24
     71c:	99 1f       	adc	r25, r25
     71e:	6a 95       	dec	r22
     720:	e2 f7       	brpl	.-8      	; 0x71a <DIO_SetPin_Dir+0xd4>
     722:	82 2b       	or	r24, r18
     724:	81 bb       	out	0x11, r24	; 17
     726:	08 95       	ret

00000728 <DIO_SetPin_Value>:
     728:	44 23       	and	r20, r20
     72a:	d9 f1       	breq	.+118    	; 0x7a2 <DIO_SetPin_Value+0x7a>
     72c:	41 30       	cpi	r20, 0x01	; 1
     72e:	09 f0       	breq	.+2      	; 0x732 <DIO_SetPin_Value+0xa>
     730:	6b c0       	rjmp	.+214    	; 0x808 <__DATA_REGION_LENGTH__+0x8>
     732:	81 30       	cpi	r24, 0x01	; 1
     734:	91 f0       	breq	.+36     	; 0x75a <DIO_SetPin_Value+0x32>
     736:	28 f0       	brcs	.+10     	; 0x742 <DIO_SetPin_Value+0x1a>
     738:	82 30       	cpi	r24, 0x02	; 2
     73a:	d9 f0       	breq	.+54     	; 0x772 <DIO_SetPin_Value+0x4a>
     73c:	83 30       	cpi	r24, 0x03	; 3
     73e:	29 f1       	breq	.+74     	; 0x78a <DIO_SetPin_Value+0x62>
     740:	08 95       	ret
     742:	2b b3       	in	r18, 0x1b	; 27
     744:	81 e0       	ldi	r24, 0x01	; 1
     746:	90 e0       	ldi	r25, 0x00	; 0
     748:	02 c0       	rjmp	.+4      	; 0x74e <DIO_SetPin_Value+0x26>
     74a:	88 0f       	add	r24, r24
     74c:	99 1f       	adc	r25, r25
     74e:	6a 95       	dec	r22
     750:	e2 f7       	brpl	.-8      	; 0x74a <DIO_SetPin_Value+0x22>
     752:	80 95       	com	r24
     754:	82 23       	and	r24, r18
     756:	8b bb       	out	0x1b, r24	; 27
     758:	08 95       	ret
     75a:	28 b3       	in	r18, 0x18	; 24
     75c:	81 e0       	ldi	r24, 0x01	; 1
     75e:	90 e0       	ldi	r25, 0x00	; 0
     760:	02 c0       	rjmp	.+4      	; 0x766 <DIO_SetPin_Value+0x3e>
     762:	88 0f       	add	r24, r24
     764:	99 1f       	adc	r25, r25
     766:	6a 95       	dec	r22
     768:	e2 f7       	brpl	.-8      	; 0x762 <DIO_SetPin_Value+0x3a>
     76a:	80 95       	com	r24
     76c:	82 23       	and	r24, r18
     76e:	88 bb       	out	0x18, r24	; 24
     770:	08 95       	ret
     772:	25 b3       	in	r18, 0x15	; 21
     774:	81 e0       	ldi	r24, 0x01	; 1
     776:	90 e0       	ldi	r25, 0x00	; 0
     778:	02 c0       	rjmp	.+4      	; 0x77e <DIO_SetPin_Value+0x56>
     77a:	88 0f       	add	r24, r24
     77c:	99 1f       	adc	r25, r25
     77e:	6a 95       	dec	r22
     780:	e2 f7       	brpl	.-8      	; 0x77a <DIO_SetPin_Value+0x52>
     782:	80 95       	com	r24
     784:	82 23       	and	r24, r18
     786:	85 bb       	out	0x15, r24	; 21
     788:	08 95       	ret
     78a:	22 b3       	in	r18, 0x12	; 18
     78c:	81 e0       	ldi	r24, 0x01	; 1
     78e:	90 e0       	ldi	r25, 0x00	; 0
     790:	02 c0       	rjmp	.+4      	; 0x796 <DIO_SetPin_Value+0x6e>
     792:	88 0f       	add	r24, r24
     794:	99 1f       	adc	r25, r25
     796:	6a 95       	dec	r22
     798:	e2 f7       	brpl	.-8      	; 0x792 <DIO_SetPin_Value+0x6a>
     79a:	80 95       	com	r24
     79c:	82 23       	and	r24, r18
     79e:	82 bb       	out	0x12, r24	; 18
     7a0:	08 95       	ret
     7a2:	81 30       	cpi	r24, 0x01	; 1
     7a4:	89 f0       	breq	.+34     	; 0x7c8 <DIO_SetPin_Value+0xa0>
     7a6:	28 f0       	brcs	.+10     	; 0x7b2 <DIO_SetPin_Value+0x8a>
     7a8:	82 30       	cpi	r24, 0x02	; 2
     7aa:	c9 f0       	breq	.+50     	; 0x7de <DIO_SetPin_Value+0xb6>
     7ac:	83 30       	cpi	r24, 0x03	; 3
     7ae:	11 f1       	breq	.+68     	; 0x7f4 <DIO_SetPin_Value+0xcc>
     7b0:	08 95       	ret
     7b2:	2b b3       	in	r18, 0x1b	; 27
     7b4:	81 e0       	ldi	r24, 0x01	; 1
     7b6:	90 e0       	ldi	r25, 0x00	; 0
     7b8:	02 c0       	rjmp	.+4      	; 0x7be <DIO_SetPin_Value+0x96>
     7ba:	88 0f       	add	r24, r24
     7bc:	99 1f       	adc	r25, r25
     7be:	6a 95       	dec	r22
     7c0:	e2 f7       	brpl	.-8      	; 0x7ba <DIO_SetPin_Value+0x92>
     7c2:	82 2b       	or	r24, r18
     7c4:	8b bb       	out	0x1b, r24	; 27
     7c6:	08 95       	ret
     7c8:	28 b3       	in	r18, 0x18	; 24
     7ca:	81 e0       	ldi	r24, 0x01	; 1
     7cc:	90 e0       	ldi	r25, 0x00	; 0
     7ce:	02 c0       	rjmp	.+4      	; 0x7d4 <DIO_SetPin_Value+0xac>
     7d0:	88 0f       	add	r24, r24
     7d2:	99 1f       	adc	r25, r25
     7d4:	6a 95       	dec	r22
     7d6:	e2 f7       	brpl	.-8      	; 0x7d0 <DIO_SetPin_Value+0xa8>
     7d8:	82 2b       	or	r24, r18
     7da:	88 bb       	out	0x18, r24	; 24
     7dc:	08 95       	ret
     7de:	25 b3       	in	r18, 0x15	; 21
     7e0:	81 e0       	ldi	r24, 0x01	; 1
     7e2:	90 e0       	ldi	r25, 0x00	; 0
     7e4:	02 c0       	rjmp	.+4      	; 0x7ea <DIO_SetPin_Value+0xc2>
     7e6:	88 0f       	add	r24, r24
     7e8:	99 1f       	adc	r25, r25
     7ea:	6a 95       	dec	r22
     7ec:	e2 f7       	brpl	.-8      	; 0x7e6 <DIO_SetPin_Value+0xbe>
     7ee:	82 2b       	or	r24, r18
     7f0:	85 bb       	out	0x15, r24	; 21
     7f2:	08 95       	ret
     7f4:	22 b3       	in	r18, 0x12	; 18
     7f6:	81 e0       	ldi	r24, 0x01	; 1
     7f8:	90 e0       	ldi	r25, 0x00	; 0
     7fa:	02 c0       	rjmp	.+4      	; 0x800 <__DATA_REGION_LENGTH__>
     7fc:	88 0f       	add	r24, r24
     7fe:	99 1f       	adc	r25, r25
     800:	6a 95       	dec	r22
     802:	e2 f7       	brpl	.-8      	; 0x7fc <DIO_SetPin_Value+0xd4>
     804:	82 2b       	or	r24, r18
     806:	82 bb       	out	0x12, r24	; 18
     808:	08 95       	ret

0000080a <DIO_GetPin_Value>:
     80a:	81 30       	cpi	r24, 0x01	; 1
     80c:	79 f0       	breq	.+30     	; 0x82c <DIO_GetPin_Value+0x22>
     80e:	28 f0       	brcs	.+10     	; 0x81a <DIO_GetPin_Value+0x10>
     810:	82 30       	cpi	r24, 0x02	; 2
     812:	a9 f0       	breq	.+42     	; 0x83e <DIO_GetPin_Value+0x34>
     814:	83 30       	cpi	r24, 0x03	; 3
     816:	e1 f0       	breq	.+56     	; 0x850 <DIO_GetPin_Value+0x46>
     818:	24 c0       	rjmp	.+72     	; 0x862 <__stack+0x3>
     81a:	89 b3       	in	r24, 0x19	; 25
     81c:	90 e0       	ldi	r25, 0x00	; 0
     81e:	02 c0       	rjmp	.+4      	; 0x824 <DIO_GetPin_Value+0x1a>
     820:	95 95       	asr	r25
     822:	87 95       	ror	r24
     824:	6a 95       	dec	r22
     826:	e2 f7       	brpl	.-8      	; 0x820 <DIO_GetPin_Value+0x16>
     828:	81 70       	andi	r24, 0x01	; 1
     82a:	08 95       	ret
     82c:	86 b3       	in	r24, 0x16	; 22
     82e:	90 e0       	ldi	r25, 0x00	; 0
     830:	02 c0       	rjmp	.+4      	; 0x836 <DIO_GetPin_Value+0x2c>
     832:	95 95       	asr	r25
     834:	87 95       	ror	r24
     836:	6a 95       	dec	r22
     838:	e2 f7       	brpl	.-8      	; 0x832 <DIO_GetPin_Value+0x28>
     83a:	81 70       	andi	r24, 0x01	; 1
     83c:	08 95       	ret
     83e:	83 b3       	in	r24, 0x13	; 19
     840:	90 e0       	ldi	r25, 0x00	; 0
     842:	02 c0       	rjmp	.+4      	; 0x848 <DIO_GetPin_Value+0x3e>
     844:	95 95       	asr	r25
     846:	87 95       	ror	r24
     848:	6a 95       	dec	r22
     84a:	e2 f7       	brpl	.-8      	; 0x844 <DIO_GetPin_Value+0x3a>
     84c:	81 70       	andi	r24, 0x01	; 1
     84e:	08 95       	ret
     850:	80 b3       	in	r24, 0x10	; 16
     852:	90 e0       	ldi	r25, 0x00	; 0
     854:	02 c0       	rjmp	.+4      	; 0x85a <DIO_GetPin_Value+0x50>
     856:	95 95       	asr	r25
     858:	87 95       	ror	r24
     85a:	6a 95       	dec	r22
     85c:	e2 f7       	brpl	.-8      	; 0x856 <DIO_GetPin_Value+0x4c>
     85e:	81 70       	andi	r24, 0x01	; 1
     860:	08 95       	ret
     862:	80 e0       	ldi	r24, 0x00	; 0
     864:	08 95       	ret

00000866 <DIO_TogglePin_Value>:
     866:	81 30       	cpi	r24, 0x01	; 1
     868:	89 f0       	breq	.+34     	; 0x88c <DIO_TogglePin_Value+0x26>
     86a:	28 f0       	brcs	.+10     	; 0x876 <DIO_TogglePin_Value+0x10>
     86c:	82 30       	cpi	r24, 0x02	; 2
     86e:	c9 f0       	breq	.+50     	; 0x8a2 <DIO_TogglePin_Value+0x3c>
     870:	83 30       	cpi	r24, 0x03	; 3
     872:	11 f1       	breq	.+68     	; 0x8b8 <DIO_TogglePin_Value+0x52>
     874:	08 95       	ret
     876:	2b b3       	in	r18, 0x1b	; 27
     878:	81 e0       	ldi	r24, 0x01	; 1
     87a:	90 e0       	ldi	r25, 0x00	; 0
     87c:	02 c0       	rjmp	.+4      	; 0x882 <DIO_TogglePin_Value+0x1c>
     87e:	88 0f       	add	r24, r24
     880:	99 1f       	adc	r25, r25
     882:	6a 95       	dec	r22
     884:	e2 f7       	brpl	.-8      	; 0x87e <DIO_TogglePin_Value+0x18>
     886:	82 27       	eor	r24, r18
     888:	8b bb       	out	0x1b, r24	; 27
     88a:	08 95       	ret
     88c:	28 b3       	in	r18, 0x18	; 24
     88e:	81 e0       	ldi	r24, 0x01	; 1
     890:	90 e0       	ldi	r25, 0x00	; 0
     892:	02 c0       	rjmp	.+4      	; 0x898 <DIO_TogglePin_Value+0x32>
     894:	88 0f       	add	r24, r24
     896:	99 1f       	adc	r25, r25
     898:	6a 95       	dec	r22
     89a:	e2 f7       	brpl	.-8      	; 0x894 <DIO_TogglePin_Value+0x2e>
     89c:	82 27       	eor	r24, r18
     89e:	88 bb       	out	0x18, r24	; 24
     8a0:	08 95       	ret
     8a2:	25 b3       	in	r18, 0x15	; 21
     8a4:	81 e0       	ldi	r24, 0x01	; 1
     8a6:	90 e0       	ldi	r25, 0x00	; 0
     8a8:	02 c0       	rjmp	.+4      	; 0x8ae <DIO_TogglePin_Value+0x48>
     8aa:	88 0f       	add	r24, r24
     8ac:	99 1f       	adc	r25, r25
     8ae:	6a 95       	dec	r22
     8b0:	e2 f7       	brpl	.-8      	; 0x8aa <DIO_TogglePin_Value+0x44>
     8b2:	82 27       	eor	r24, r18
     8b4:	85 bb       	out	0x15, r24	; 21
     8b6:	08 95       	ret
     8b8:	22 b3       	in	r18, 0x12	; 18
     8ba:	81 e0       	ldi	r24, 0x01	; 1
     8bc:	90 e0       	ldi	r25, 0x00	; 0
     8be:	02 c0       	rjmp	.+4      	; 0x8c4 <DIO_TogglePin_Value+0x5e>
     8c0:	88 0f       	add	r24, r24
     8c2:	99 1f       	adc	r25, r25
     8c4:	6a 95       	dec	r22
     8c6:	e2 f7       	brpl	.-8      	; 0x8c0 <DIO_TogglePin_Value+0x5a>
     8c8:	82 27       	eor	r24, r18
     8ca:	82 bb       	out	0x12, r24	; 18
     8cc:	08 95       	ret

000008ce <DIO_SetPin_Pullup>:
     8ce:	81 30       	cpi	r24, 0x01	; 1
     8d0:	89 f0       	breq	.+34     	; 0x8f4 <DIO_SetPin_Pullup+0x26>
     8d2:	28 f0       	brcs	.+10     	; 0x8de <DIO_SetPin_Pullup+0x10>
     8d4:	82 30       	cpi	r24, 0x02	; 2
     8d6:	c9 f0       	breq	.+50     	; 0x90a <DIO_SetPin_Pullup+0x3c>
     8d8:	83 30       	cpi	r24, 0x03	; 3
     8da:	11 f1       	breq	.+68     	; 0x920 <DIO_SetPin_Pullup+0x52>
     8dc:	08 95       	ret
     8de:	2b b3       	in	r18, 0x1b	; 27
     8e0:	81 e0       	ldi	r24, 0x01	; 1
     8e2:	90 e0       	ldi	r25, 0x00	; 0
     8e4:	02 c0       	rjmp	.+4      	; 0x8ea <DIO_SetPin_Pullup+0x1c>
     8e6:	88 0f       	add	r24, r24
     8e8:	99 1f       	adc	r25, r25
     8ea:	6a 95       	dec	r22
     8ec:	e2 f7       	brpl	.-8      	; 0x8e6 <DIO_SetPin_Pullup+0x18>
     8ee:	82 2b       	or	r24, r18
     8f0:	8b bb       	out	0x1b, r24	; 27
     8f2:	08 95       	ret
     8f4:	28 b3       	in	r18, 0x18	; 24
     8f6:	81 e0       	ldi	r24, 0x01	; 1
     8f8:	90 e0       	ldi	r25, 0x00	; 0
     8fa:	02 c0       	rjmp	.+4      	; 0x900 <DIO_SetPin_Pullup+0x32>
     8fc:	88 0f       	add	r24, r24
     8fe:	99 1f       	adc	r25, r25
     900:	6a 95       	dec	r22
     902:	e2 f7       	brpl	.-8      	; 0x8fc <DIO_SetPin_Pullup+0x2e>
     904:	82 2b       	or	r24, r18
     906:	88 bb       	out	0x18, r24	; 24
     908:	08 95       	ret
     90a:	25 b3       	in	r18, 0x15	; 21
     90c:	81 e0       	ldi	r24, 0x01	; 1
     90e:	90 e0       	ldi	r25, 0x00	; 0
     910:	02 c0       	rjmp	.+4      	; 0x916 <DIO_SetPin_Pullup+0x48>
     912:	88 0f       	add	r24, r24
     914:	99 1f       	adc	r25, r25
     916:	6a 95       	dec	r22
     918:	e2 f7       	brpl	.-8      	; 0x912 <DIO_SetPin_Pullup+0x44>
     91a:	82 2b       	or	r24, r18
     91c:	85 bb       	out	0x15, r24	; 21
     91e:	08 95       	ret
     920:	22 b3       	in	r18, 0x12	; 18
     922:	81 e0       	ldi	r24, 0x01	; 1
     924:	90 e0       	ldi	r25, 0x00	; 0
     926:	02 c0       	rjmp	.+4      	; 0x92c <DIO_SetPin_Pullup+0x5e>
     928:	88 0f       	add	r24, r24
     92a:	99 1f       	adc	r25, r25
     92c:	6a 95       	dec	r22
     92e:	e2 f7       	brpl	.-8      	; 0x928 <DIO_SetPin_Pullup+0x5a>
     930:	82 2b       	or	r24, r18
     932:	82 bb       	out	0x12, r24	; 18
     934:	08 95       	ret

00000936 <EEPROM_INIT>:

        //Sending stop condition
        I2C_SendStopCond();

        _delay_ms(10);
}
     936:	0e 94 50 0a 	call	0x14a0	; 0x14a0 <I2C_INIT>
     93a:	08 95       	ret

0000093c <EEPROM_WriteByte>:
     93c:	1f 93       	push	r17
     93e:	cf 93       	push	r28
     940:	df 93       	push	r29
     942:	16 2f       	mov	r17, r22
     944:	d4 2f       	mov	r29, r20
     946:	88 30       	cpi	r24, 0x08	; 8
     948:	08 f0       	brcs	.+2      	; 0x94c <EEPROM_WriteByte+0x10>
     94a:	87 e0       	ldi	r24, 0x07	; 7
     94c:	c8 2f       	mov	r28, r24
     94e:	c0 65       	ori	r28, 0x50	; 80
     950:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <I2C_SendStartCond>
     954:	8c 2f       	mov	r24, r28
     956:	0e 94 64 0a 	call	0x14c8	; 0x14c8 <I2C_SendSlaveAdd_WriteOP>
     95a:	81 2f       	mov	r24, r17
     95c:	0e 94 80 0a 	call	0x1500	; 0x1500 <I2C_SendData>
     960:	8d 2f       	mov	r24, r29
     962:	0e 94 80 0a 	call	0x1500	; 0x1500 <I2C_SendData>
     966:	0e 94 8e 0a 	call	0x151c	; 0x151c <I2C_SendStopCond>
     96a:	8f e3       	ldi	r24, 0x3F	; 63
     96c:	9c e9       	ldi	r25, 0x9C	; 156
     96e:	01 97       	sbiw	r24, 0x01	; 1
     970:	f1 f7       	brne	.-4      	; 0x96e <EEPROM_WriteByte+0x32>
     972:	00 c0       	rjmp	.+0      	; 0x974 <EEPROM_WriteByte+0x38>
     974:	00 00       	nop
     976:	df 91       	pop	r29
     978:	cf 91       	pop	r28
     97a:	1f 91       	pop	r17
     97c:	08 95       	ret

0000097e <EEPROM_ReadByte>:

Uint8 EEPROM_ReadByte(Uint8 Device_Page, Uint8 Data_Add) {
     97e:	cf 93       	push	r28
     980:	df 93       	push	r29
     982:	d6 2f       	mov	r29, r22
        Uint8 Data = 0;
        if (Device_Page > 7)
     984:	88 30       	cpi	r24, 0x08	; 8
     986:	08 f0       	brcs	.+2      	; 0x98a <EEPROM_ReadByte+0xc>
                Device_Page = 7;
     988:	87 e0       	ldi	r24, 0x07	; 7

        //Device address calculation
        Uint8 Device_Add = 0X50 | Device_Page;
     98a:	c8 2f       	mov	r28, r24
     98c:	c0 65       	ori	r28, 0x50	; 80

        //Sending start condition
        I2C_SendStartCond();
     98e:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <I2C_SendStartCond>

        //sending slave address with write operation
        I2C_SendSlaveAdd_WriteOP(Device_Add);
     992:	8c 2f       	mov	r24, r28
     994:	0e 94 64 0a 	call	0x14c8	; 0x14c8 <I2C_SendSlaveAdd_WriteOP>

        //sending data byte address
        I2C_SendData(Data_Add);
     998:	8d 2f       	mov	r24, r29
     99a:	0e 94 80 0a 	call	0x1500	; 0x1500 <I2C_SendData>

        //Sending repeated start condition
        I2C_SendRepStartCond();
     99e:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <I2C_SendRepStartCond>

        //sending slave address with read operation
        I2C_SendSlaveAdd_ReadOP(Device_Add);
     9a2:	8c 2f       	mov	r24, r28
     9a4:	0e 94 75 0a 	call	0x14ea	; 0x14ea <I2C_SendSlaveAdd_ReadOP>

        //Receiving the data byte
        Data = I2C_ReadData();
     9a8:	0e 94 87 0a 	call	0x150e	; 0x150e <I2C_ReadData>
     9ac:	c8 2f       	mov	r28, r24

        //Sending stop condition
        I2C_SendStopCond();
     9ae:	0e 94 8e 0a 	call	0x151c	; 0x151c <I2C_SendStopCond>

        return Data;
}
     9b2:	8c 2f       	mov	r24, r28
     9b4:	df 91       	pop	r29
     9b6:	cf 91       	pop	r28
     9b8:	08 95       	ret

000009ba <INT0_Init>:

        /*INT0 Pin Direction*/
        DIO_SetPin_Dir(DIO_PORTB, PIN_2, PIN_IN);

        /*EXT INT0 Trigger*/
        MCUCR |= EXT_INT2_Trigger;
     9ba:	8f b7       	in	r24, 0x3f	; 63
     9bc:	80 68       	ori	r24, 0x80	; 128
     9be:	8f bf       	out	0x3f, r24	; 63
     9c0:	8b b7       	in	r24, 0x3b	; 59
     9c2:	80 64       	ori	r24, 0x40	; 64
     9c4:	8b bf       	out	0x3b, r24	; 59
     9c6:	40 e0       	ldi	r20, 0x00	; 0
     9c8:	62 e0       	ldi	r22, 0x02	; 2
     9ca:	83 e0       	ldi	r24, 0x03	; 3
     9cc:	0e 94 23 03 	call	0x646	; 0x646 <DIO_SetPin_Dir>
     9d0:	85 b7       	in	r24, 0x35	; 53
     9d2:	82 60       	ori	r24, 0x02	; 2
     9d4:	85 bf       	out	0x35, r24	; 53
     9d6:	08 95       	ret

000009d8 <__vector_1>:
}

ISR(INT0_vect) {
     9d8:	1f 92       	push	r1
     9da:	0f 92       	push	r0
     9dc:	0f b6       	in	r0, 0x3f	; 63
     9de:	0f 92       	push	r0
     9e0:	11 24       	eor	r1, r1
     9e2:	2f 92       	push	r2
     9e4:	3f 92       	push	r3
     9e6:	4f 92       	push	r4
     9e8:	5f 92       	push	r5
     9ea:	7f 92       	push	r7
     9ec:	8f 92       	push	r8
     9ee:	9f 92       	push	r9
     9f0:	af 92       	push	r10
     9f2:	bf 92       	push	r11
     9f4:	cf 92       	push	r12
     9f6:	df 92       	push	r13
     9f8:	ef 92       	push	r14
     9fa:	ff 92       	push	r15
     9fc:	0f 93       	push	r16
     9fe:	1f 93       	push	r17
     a00:	2f 93       	push	r18
     a02:	3f 93       	push	r19
     a04:	4f 93       	push	r20
     a06:	5f 93       	push	r21
     a08:	6f 93       	push	r22
     a0a:	7f 93       	push	r23
     a0c:	8f 93       	push	r24
     a0e:	9f 93       	push	r25
     a10:	af 93       	push	r26
     a12:	bf 93       	push	r27
     a14:	ef 93       	push	r30
     a16:	ff 93       	push	r31
     a18:	cf 93       	push	r28
     a1a:	df 93       	push	r29
     a1c:	cd b7       	in	r28, 0x3d	; 61
     a1e:	de b7       	in	r29, 0x3e	; 62
     a20:	28 97       	sbiw	r28, 0x08	; 8
     a22:	de bf       	out	0x3e, r29	; 62
     a24:	cd bf       	out	0x3d, r28	; 61
        // Write the first external interrupt handler here

        /*----------------->login to KEYPAD-LCD system <-----------------*/
        if (!eme_check) {
     a26:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
     a2a:	90 91 d2 07 	lds	r25, 0x07D2	; 0x8007d2 <eme_check+0x1>
     a2e:	89 2b       	or	r24, r25
     a30:	09 f0       	breq	.+2      	; 0xa34 <__vector_1+0x5c>
     a32:	d2 c1       	rjmp	.+932    	; 0xdd8 <__vector_1+0x400>
                Uint8 k = 0;
                Uint8 i = 0;
                Uint8 user[2][4];
                LCD_Clear();
     a34:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                UART_TX_Str("\r\n");
     a38:	8a ed       	ldi	r24, 0xDA	; 218
     a3a:	92 e0       	ldi	r25, 0x02	; 2
     a3c:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                UART_TX_Str("The system is busy!\r\n");
     a40:	8b e1       	ldi	r24, 0x1B	; 27
     a42:	91 e0       	ldi	r25, 0x01	; 1
     a44:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                Servoo_Motor(97); //Closing the door in case the system stuck here for a while 
     a48:	61 e6       	ldi	r22, 0x61	; 97
     a4a:	70 e0       	ldi	r23, 0x00	; 0
     a4c:	80 e0       	ldi	r24, 0x00	; 0
     a4e:	90 e0       	ldi	r25, 0x00	; 0
     a50:	0e 94 be 0d 	call	0x1b7c	; 0x1b7c <Servoo_Motor>

                /*----------------->Reciving username & password from KEYPAD <-----------------*/
                for (Uint8 j = 0; j < 3; j++) {
     a54:	71 2c       	mov	r7, r1
ISR(INT0_vect) {
        // Write the first external interrupt handler here

        /*----------------->login to KEYPAD-LCD system <-----------------*/
        if (!eme_check) {
                Uint8 k = 0;
     a56:	00 e0       	ldi	r16, 0x00	; 0
                UART_TX_Str("\r\n");
                UART_TX_Str("The system is busy!\r\n");
                Servoo_Motor(97); //Closing the door in case the system stuck here for a while 

                /*----------------->Reciving username & password from KEYPAD <-----------------*/
                for (Uint8 j = 0; j < 3; j++) {
     a58:	aa c1       	rjmp	.+852    	; 0xdae <__vector_1+0x3d6>
                        i = 0;
                        LCD_Write_String("user name:");
     a5a:	81 e3       	ldi	r24, 0x31	; 49
     a5c:	91 e0       	ldi	r25, 0x01	; 1
     a5e:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                UART_TX_Str("The system is busy!\r\n");
                Servoo_Motor(97); //Closing the door in case the system stuck here for a while 

                /*----------------->Reciving username & password from KEYPAD <-----------------*/
                for (Uint8 j = 0; j < 3; j++) {
                        i = 0;
     a62:	10 e0       	ldi	r17, 0x00	; 0
                        LCD_Write_String("user name:");
                        while (i < 4) {
     a64:	15 c0       	rjmp	.+42     	; 0xa90 <__vector_1+0xb8>
                                button = Keypad_GetValue();
     a66:	0e 94 d7 0a 	call	0x15ae	; 0x15ae <Keypad_GetValue>
     a6a:	80 93 d0 07 	sts	0x07D0, r24	; 0x8007d0 <button>

                                while (button != NULL_KEYPAD) {
     a6e:	0c c0       	rjmp	.+24     	; 0xa88 <__vector_1+0xb0>
                                        user[0][i] = button;
     a70:	e1 e0       	ldi	r30, 0x01	; 1
     a72:	f0 e0       	ldi	r31, 0x00	; 0
     a74:	ec 0f       	add	r30, r28
     a76:	fd 1f       	adc	r31, r29
     a78:	e1 0f       	add	r30, r17
     a7a:	f1 1d       	adc	r31, r1
     a7c:	80 83       	st	Z, r24
                                        LCD_Write_Char(button);
     a7e:	0e 94 b8 0b 	call	0x1770	; 0x1770 <LCD_Write_Char>
                                        button = NULL_KEYPAD;
     a82:	10 92 d0 07 	sts	0x07D0, r1	; 0x8007d0 <button>
                                        i++;
     a86:	1f 5f       	subi	r17, 0xFF	; 255
                        i = 0;
                        LCD_Write_String("user name:");
                        while (i < 4) {
                                button = Keypad_GetValue();

                                while (button != NULL_KEYPAD) {
     a88:	80 91 d0 07 	lds	r24, 0x07D0	; 0x8007d0 <button>
     a8c:	81 11       	cpse	r24, r1
     a8e:	f0 cf       	rjmp	.-32     	; 0xa70 <__vector_1+0x98>

                /*----------------->Reciving username & password from KEYPAD <-----------------*/
                for (Uint8 j = 0; j < 3; j++) {
                        i = 0;
                        LCD_Write_String("user name:");
                        while (i < 4) {
     a90:	14 30       	cpi	r17, 0x04	; 4
     a92:	48 f3       	brcs	.-46     	; 0xa66 <__vector_1+0x8e>
                                        button = NULL_KEYPAD;
                                        i++;
                                }
                        }
                        i = 0;
                        LCD_Goto(1, 0);
     a94:	60 e0       	ldi	r22, 0x00	; 0
     a96:	81 e0       	ldi	r24, 0x01	; 1
     a98:	0e 94 83 0c 	call	0x1906	; 0x1906 <LCD_Goto>
                        LCD_Write_String("password:");
     a9c:	8c e3       	ldi	r24, 0x3C	; 60
     a9e:	91 e0       	ldi	r25, 0x01	; 1
     aa0:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                                        LCD_Write_Char(button);
                                        button = NULL_KEYPAD;
                                        i++;
                                }
                        }
                        i = 0;
     aa4:	10 e0       	ldi	r17, 0x00	; 0
                        LCD_Goto(1, 0);
                        LCD_Write_String("password:");
                        while (i < 4) {
     aa6:	16 c0       	rjmp	.+44     	; 0xad4 <__vector_1+0xfc>
                                button = Keypad_GetValue();
     aa8:	0e 94 d7 0a 	call	0x15ae	; 0x15ae <Keypad_GetValue>
     aac:	80 93 d0 07 	sts	0x07D0, r24	; 0x8007d0 <button>
                                while (button != NULL_KEYPAD) {
     ab0:	0d c0       	rjmp	.+26     	; 0xacc <__vector_1+0xf4>
                                        user[1][i] = button;
     ab2:	e5 e0       	ldi	r30, 0x05	; 5
     ab4:	f0 e0       	ldi	r31, 0x00	; 0
     ab6:	ec 0f       	add	r30, r28
     ab8:	fd 1f       	adc	r31, r29
     aba:	e1 0f       	add	r30, r17
     abc:	f1 1d       	adc	r31, r1
     abe:	80 83       	st	Z, r24
                                        LCD_Write_Char('*');
     ac0:	8a e2       	ldi	r24, 0x2A	; 42
     ac2:	0e 94 b8 0b 	call	0x1770	; 0x1770 <LCD_Write_Char>
                                        button = NULL_KEYPAD;
     ac6:	10 92 d0 07 	sts	0x07D0, r1	; 0x8007d0 <button>
                                        i++;
     aca:	1f 5f       	subi	r17, 0xFF	; 255
                        i = 0;
                        LCD_Goto(1, 0);
                        LCD_Write_String("password:");
                        while (i < 4) {
                                button = Keypad_GetValue();
                                while (button != NULL_KEYPAD) {
     acc:	80 91 d0 07 	lds	r24, 0x07D0	; 0x8007d0 <button>
     ad0:	81 11       	cpse	r24, r1
     ad2:	ef cf       	rjmp	.-34     	; 0xab2 <__vector_1+0xda>
                                }
                        }
                        i = 0;
                        LCD_Goto(1, 0);
                        LCD_Write_String("password:");
                        while (i < 4) {
     ad4:	14 30       	cpi	r17, 0x04	; 4
     ad6:	40 f3       	brcs	.-48     	; 0xaa8 <__vector_1+0xd0>
                                        i++;
                                }
                        }

                        /*----------------->Option for showing the passward  <-----------------*/
                        LCD_Clear();
     ad8:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                        LCD_Write_String("Show password *");
     adc:	86 e4       	ldi	r24, 0x46	; 70
     ade:	91 e0       	ldi	r25, 0x01	; 1
     ae0:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                        LCD_Goto(1, 0);
     ae4:	60 e0       	ldi	r22, 0x00	; 0
     ae6:	81 e0       	ldi	r24, 0x01	; 1
     ae8:	0e 94 83 0c 	call	0x1906	; 0x1906 <LCD_Goto>
                        LCD_Write_String("other press #");
     aec:	86 e5       	ldi	r24, 0x56	; 86
     aee:	91 e0       	ldi	r25, 0x01	; 1
     af0:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>

                        while (!(button == '*' || button == '#'))
     af4:	04 c0       	rjmp	.+8      	; 0xafe <__vector_1+0x126>
                                button = Keypad_GetValue();
     af6:	0e 94 d7 0a 	call	0x15ae	; 0x15ae <Keypad_GetValue>
     afa:	80 93 d0 07 	sts	0x07D0, r24	; 0x8007d0 <button>
                        LCD_Clear();
                        LCD_Write_String("Show password *");
                        LCD_Goto(1, 0);
                        LCD_Write_String("other press #");

                        while (!(button == '*' || button == '#'))
     afe:	80 91 d0 07 	lds	r24, 0x07D0	; 0x8007d0 <button>
     b02:	8a 32       	cpi	r24, 0x2A	; 42
     b04:	11 f0       	breq	.+4      	; 0xb0a <__vector_1+0x132>
     b06:	83 32       	cpi	r24, 0x23	; 35
     b08:	b1 f7       	brne	.-20     	; 0xaf6 <__vector_1+0x11e>
                                button = Keypad_GetValue();

                        if (button == '*') {
     b0a:	8a 32       	cpi	r24, 0x2A	; 42
     b0c:	e9 f4       	brne	.+58     	; 0xb48 <__vector_1+0x170>
                                LCD_Clear();
     b0e:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                LCD_Write_String("password:");
     b12:	8c e3       	ldi	r24, 0x3C	; 60
     b14:	91 e0       	ldi	r25, 0x01	; 1
     b16:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                                i = 0;
     b1a:	10 e0       	ldi	r17, 0x00	; 0
                                while (i < 4) {
     b1c:	0a c0       	rjmp	.+20     	; 0xb32 <__vector_1+0x15a>
                                        LCD_Write_Char(user[1][i]);
     b1e:	e5 e0       	ldi	r30, 0x05	; 5
     b20:	f0 e0       	ldi	r31, 0x00	; 0
     b22:	ec 0f       	add	r30, r28
     b24:	fd 1f       	adc	r31, r29
     b26:	e1 0f       	add	r30, r17
     b28:	f1 1d       	adc	r31, r1
     b2a:	80 81       	ld	r24, Z
     b2c:	0e 94 b8 0b 	call	0x1770	; 0x1770 <LCD_Write_Char>
                                        i++;
     b30:	1f 5f       	subi	r17, 0xFF	; 255

                        if (button == '*') {
                                LCD_Clear();
                                LCD_Write_String("password:");
                                i = 0;
                                while (i < 4) {
     b32:	14 30       	cpi	r17, 0x04	; 4
     b34:	a0 f3       	brcs	.-24     	; 0xb1e <__vector_1+0x146>
     b36:	2f ef       	ldi	r18, 0xFF	; 255
     b38:	89 e6       	ldi	r24, 0x69	; 105
     b3a:	98 e1       	ldi	r25, 0x18	; 24
     b3c:	21 50       	subi	r18, 0x01	; 1
     b3e:	80 40       	sbci	r24, 0x00	; 0
     b40:	90 40       	sbci	r25, 0x00	; 0
     b42:	e1 f7       	brne	.-8      	; 0xb3c <__vector_1+0x164>
     b44:	00 c0       	rjmp	.+0      	; 0xb46 <__vector_1+0x16e>
     b46:	00 00       	nop
                                        i++;
                                }
                                _delay_ms(500);

                        }
                        LCD_Clear();
     b48:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>

                        for (Uint8 Check_Counter = 0; Check_Counter <= KP_Counter; Check_Counter += 4) {
     b4c:	10 e0       	ldi	r17, 0x00	; 0
     b4e:	04 c1       	rjmp	.+520    	; 0xd58 <__vector_1+0x380>
                                /*----------------->Username Check<------------------*/

                                if (user[0][0] == EEPROM_ReadByte(0, Check_Counter + 1) && user[0][1] == EEPROM_ReadByte(0, Check_Counter + 2) && user[0][2] == EEPROM_ReadByte(0, Check_Counter + 3) && user[0][3] == EEPROM_ReadByte(0, Check_Counter + 4))
     b50:	a9 80       	ldd	r10, Y+1	; 0x01
     b52:	b1 2c       	mov	r11, r1
     b54:	e1 2e       	mov	r14, r17
     b56:	f1 2c       	mov	r15, r1
     b58:	67 01       	movw	r12, r14
     b5a:	2f ef       	ldi	r18, 0xFF	; 255
     b5c:	c2 1a       	sub	r12, r18
     b5e:	d2 0a       	sbc	r13, r18
     b60:	b6 01       	movw	r22, r12
     b62:	80 e0       	ldi	r24, 0x00	; 0
     b64:	90 e0       	ldi	r25, 0x00	; 0
     b66:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
     b6a:	a8 16       	cp	r10, r24
     b6c:	b9 06       	cpc	r11, r25
     b6e:	09 f0       	breq	.+2      	; 0xb72 <__vector_1+0x19a>
     b70:	f2 c0       	rjmp	.+484    	; 0xd56 <__vector_1+0x37e>
     b72:	aa 80       	ldd	r10, Y+2	; 0x02
     b74:	b1 2c       	mov	r11, r1
     b76:	47 01       	movw	r8, r14
     b78:	82 e0       	ldi	r24, 0x02	; 2
     b7a:	88 0e       	add	r8, r24
     b7c:	91 1c       	adc	r9, r1
     b7e:	b4 01       	movw	r22, r8
     b80:	80 e0       	ldi	r24, 0x00	; 0
     b82:	90 e0       	ldi	r25, 0x00	; 0
     b84:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
     b88:	a8 16       	cp	r10, r24
     b8a:	b9 06       	cpc	r11, r25
     b8c:	09 f0       	breq	.+2      	; 0xb90 <__vector_1+0x1b8>
     b8e:	e3 c0       	rjmp	.+454    	; 0xd56 <__vector_1+0x37e>
     b90:	ab 80       	ldd	r10, Y+3	; 0x03
     b92:	b1 2c       	mov	r11, r1
     b94:	17 01       	movw	r2, r14
     b96:	93 e0       	ldi	r25, 0x03	; 3
     b98:	29 0e       	add	r2, r25
     b9a:	31 1c       	adc	r3, r1
     b9c:	b1 01       	movw	r22, r2
     b9e:	80 e0       	ldi	r24, 0x00	; 0
     ba0:	90 e0       	ldi	r25, 0x00	; 0
     ba2:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
     ba6:	a8 16       	cp	r10, r24
     ba8:	b9 06       	cpc	r11, r25
     baa:	09 f0       	breq	.+2      	; 0xbae <__vector_1+0x1d6>
     bac:	d4 c0       	rjmp	.+424    	; 0xd56 <__vector_1+0x37e>
     bae:	4c 80       	ldd	r4, Y+4	; 0x04
     bb0:	51 2c       	mov	r5, r1
     bb2:	57 01       	movw	r10, r14
     bb4:	24 e0       	ldi	r18, 0x04	; 4
     bb6:	a2 0e       	add	r10, r18
     bb8:	b1 1c       	adc	r11, r1
     bba:	b5 01       	movw	r22, r10
     bbc:	80 e0       	ldi	r24, 0x00	; 0
     bbe:	90 e0       	ldi	r25, 0x00	; 0
     bc0:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
     bc4:	48 16       	cp	r4, r24
     bc6:	59 06       	cpc	r5, r25
     bc8:	09 f0       	breq	.+2      	; 0xbcc <__vector_1+0x1f4>
     bca:	c5 c0       	rjmp	.+394    	; 0xd56 <__vector_1+0x37e>

                                {
                                        /*----------------->Password Check<------------------*/

                                        if (user[1][0] == EEPROM_ReadByte(1, Check_Counter + 1) && user[1][1] == EEPROM_ReadByte(1, Check_Counter + 2) && user[1][2] == EEPROM_ReadByte(1, Check_Counter + 3) && user[1][3] == EEPROM_ReadByte(1, Check_Counter + 4))
     bcc:	ed 80       	ldd	r14, Y+5	; 0x05
     bce:	f1 2c       	mov	r15, r1
     bd0:	b6 01       	movw	r22, r12
     bd2:	81 e0       	ldi	r24, 0x01	; 1
     bd4:	90 e0       	ldi	r25, 0x00	; 0
     bd6:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
     bda:	e8 16       	cp	r14, r24
     bdc:	f9 06       	cpc	r15, r25
     bde:	09 f0       	breq	.+2      	; 0xbe2 <__vector_1+0x20a>
     be0:	ba c0       	rjmp	.+372    	; 0xd56 <__vector_1+0x37e>
     be2:	ee 80       	ldd	r14, Y+6	; 0x06
     be4:	f1 2c       	mov	r15, r1
     be6:	b4 01       	movw	r22, r8
     be8:	81 e0       	ldi	r24, 0x01	; 1
     bea:	90 e0       	ldi	r25, 0x00	; 0
     bec:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
     bf0:	e8 16       	cp	r14, r24
     bf2:	f9 06       	cpc	r15, r25
     bf4:	09 f0       	breq	.+2      	; 0xbf8 <__vector_1+0x220>
     bf6:	af c0       	rjmp	.+350    	; 0xd56 <__vector_1+0x37e>
     bf8:	ef 80       	ldd	r14, Y+7	; 0x07
     bfa:	f1 2c       	mov	r15, r1
     bfc:	b1 01       	movw	r22, r2
     bfe:	81 e0       	ldi	r24, 0x01	; 1
     c00:	90 e0       	ldi	r25, 0x00	; 0
     c02:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
     c06:	e8 16       	cp	r14, r24
     c08:	f9 06       	cpc	r15, r25
     c0a:	09 f0       	breq	.+2      	; 0xc0e <__vector_1+0x236>
     c0c:	a4 c0       	rjmp	.+328    	; 0xd56 <__vector_1+0x37e>
     c0e:	e8 84       	ldd	r14, Y+8	; 0x08
     c10:	f1 2c       	mov	r15, r1
     c12:	b5 01       	movw	r22, r10
     c14:	81 e0       	ldi	r24, 0x01	; 1
     c16:	90 e0       	ldi	r25, 0x00	; 0
     c18:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
     c1c:	e8 16       	cp	r14, r24
     c1e:	f9 06       	cpc	r15, r25
     c20:	09 f0       	breq	.+2      	; 0xc24 <__vector_1+0x24c>
     c22:	99 c0       	rjmp	.+306    	; 0xd56 <__vector_1+0x37e>
                                                /*----------------->right Username & Password<-----------------*/
                                                j = 4;
                                                k = 4;

                                                /*----------------->Check if there is admin uses the system to ask for accessing the KEYPAD-LCD system <-----------------*/
                                                if (SYS_Check == 0 || SYS_Check == 2) //Case of there is no one controlling yet via PC/Mobile or there is a user
     c24:	80 91 f4 07 	lds	r24, 0x07F4	; 0x8007f4 <SYS_Check>
     c28:	88 23       	and	r24, r24
     c2a:	11 f0       	breq	.+4      	; 0xc30 <__vector_1+0x258>
     c2c:	82 30       	cpi	r24, 0x02	; 2
     c2e:	29 f5       	brne	.+74     	; 0xc7a <__vector_1+0x2a2>
                                                {
                                                        eme_check = 1; //Changing it to 1 to use the emergency case function (controlling system with KEYPAD-LCD)
     c30:	81 e0       	ldi	r24, 0x01	; 1
     c32:	90 e0       	ldi	r25, 0x00	; 0
     c34:	90 93 d2 07 	sts	0x07D2, r25	; 0x8007d2 <eme_check+0x1>
     c38:	80 93 d1 07 	sts	0x07D1, r24	; 0x8007d1 <eme_check>
                                                        LCD_Write_String("User verified");
     c3c:	84 e6       	ldi	r24, 0x64	; 100
     c3e:	91 e0       	ldi	r25, 0x01	; 1
     c40:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                                                        LCD_Goto(1, 0);
     c44:	60 e0       	ldi	r22, 0x00	; 0
     c46:	81 e0       	ldi	r24, 0x01	; 1
     c48:	0e 94 83 0c 	call	0x1906	; 0x1906 <LCD_Goto>
                                                        LCD_Write_String("Welcome!");
     c4c:	82 e7       	ldi	r24, 0x72	; 114
     c4e:	91 e0       	ldi	r25, 0x01	; 1
     c50:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                                                        Check_Counter = KP_Counter + 1; //To exit the for loop of user-pass check
     c54:	10 91 f1 07 	lds	r17, 0x07F1	; 0x8007f1 <KP_Counter>
     c58:	1f 5f       	subi	r17, 0xFF	; 255
     c5a:	8f ef       	ldi	r24, 0xFF	; 255
     c5c:	99 e6       	ldi	r25, 0x69	; 105
     c5e:	28 e1       	ldi	r18, 0x18	; 24
     c60:	81 50       	subi	r24, 0x01	; 1
     c62:	90 40       	sbci	r25, 0x00	; 0
     c64:	20 40       	sbci	r18, 0x00	; 0
     c66:	e1 f7       	brne	.-8      	; 0xc60 <__vector_1+0x288>
     c68:	00 c0       	rjmp	.+0      	; 0xc6a <__vector_1+0x292>
     c6a:	00 00       	nop
                                                        _delay_ms(500);
                                                        LCD_Clear();
     c6c:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>

                                        if (user[1][0] == EEPROM_ReadByte(1, Check_Counter + 1) && user[1][1] == EEPROM_ReadByte(1, Check_Counter + 2) && user[1][2] == EEPROM_ReadByte(1, Check_Counter + 3) && user[1][3] == EEPROM_ReadByte(1, Check_Counter + 4))

                                        {
                                                /*----------------->right Username & Password<-----------------*/
                                                j = 4;
     c70:	68 94       	set
     c72:	77 24       	eor	r7, r7
     c74:	72 f8       	bld	r7, 2
                                                k = 4;
     c76:	04 e0       	ldi	r16, 0x04	; 4
                                                        LCD_Write_String("User verified");
                                                        LCD_Goto(1, 0);
                                                        LCD_Write_String("Welcome!");
                                                        Check_Counter = KP_Counter + 1; //To exit the for loop of user-pass check
                                                        _delay_ms(500);
                                                        LCD_Clear();
     c78:	6e c0       	rjmp	.+220    	; 0xd56 <__vector_1+0x37e>
                                                } else if (SYS_Check == 1) //Case of Admin is controlling 
     c7a:	81 30       	cpi	r24, 0x01	; 1
     c7c:	09 f0       	breq	.+2      	; 0xc80 <__vector_1+0x2a8>
     c7e:	67 c0       	rjmp	.+206    	; 0xd4e <__vector_1+0x376>
                                                {
                                                        LCD_Clear();
     c80:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                                        LCD_Write_String("Asking Admin");
     c84:	8b e7       	ldi	r24, 0x7B	; 123
     c86:	91 e0       	ldi	r25, 0x01	; 1
     c88:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
     c8c:	8f ef       	ldi	r24, 0xFF	; 255
     c8e:	99 e6       	ldi	r25, 0x69	; 105
     c90:	28 e1       	ldi	r18, 0x18	; 24
     c92:	81 50       	subi	r24, 0x01	; 1
     c94:	90 40       	sbci	r25, 0x00	; 0
     c96:	20 40       	sbci	r18, 0x00	; 0
     c98:	e1 f7       	brne	.-8      	; 0xc92 <__vector_1+0x2ba>
     c9a:	00 c0       	rjmp	.+0      	; 0xc9c <__vector_1+0x2c4>
     c9c:	00 00       	nop
                                                        _delay_ms(500);
                                                        LCD_Clear();
     c9e:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                                        /*----------------->Asking for acceptance the request or Not <-----------------*/
                                                        UART_TX_Str("\r\n");
     ca2:	8a ed       	ldi	r24, 0xDA	; 218
     ca4:	92 e0       	ldi	r25, 0x02	; 2
     ca6:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                                        UART_TX_Str("1.Accept user request to control the system\r\n");
     caa:	88 e8       	ldi	r24, 0x88	; 136
     cac:	91 e0       	ldi	r25, 0x01	; 1
     cae:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                                        UART_TX_Str("2.Reject user request to control the system\r\n");
     cb2:	86 eb       	ldi	r24, 0xB6	; 182
     cb4:	91 e0       	ldi	r25, 0x01	; 1
     cb6:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                                        UART_TX_Str("\r\n");
     cba:	8a ed       	ldi	r24, 0xDA	; 218
     cbc:	92 e0       	ldi	r25, 0x02	; 2
     cbe:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                                        UART_TX_Str("\r\n");
     cc2:	8a ed       	ldi	r24, 0xDA	; 218
     cc4:	92 e0       	ldi	r25, 0x02	; 2
     cc6:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                                        while (!Get_Bit(UCSRA, 7));
     cca:	5f 9b       	sbis	0x0b, 7	; 11
     ccc:	fe cf       	rjmp	.-4      	; 0xcca <__vector_1+0x2f2>
                                                        UART_GetValue = UDR; //Getting response from al Admin 
     cce:	8c b1       	in	r24, 0x0c	; 12
     cd0:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <UART_GetValue>
                                                        UART_TX_Str("\r\n");
     cd4:	8a ed       	ldi	r24, 0xDA	; 218
     cd6:	92 e0       	ldi	r25, 0x02	; 2
     cd8:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                                        if (UART_GetValue == '1') {
     cdc:	80 91 f5 07 	lds	r24, 0x07F5	; 0x8007f5 <UART_GetValue>
     ce0:	81 33       	cpi	r24, 0x31	; 49
     ce2:	99 f4       	brne	.+38     	; 0xd0a <__vector_1+0x332>
                                                                eme_check = 1;
     ce4:	81 e0       	ldi	r24, 0x01	; 1
     ce6:	90 e0       	ldi	r25, 0x00	; 0
     ce8:	90 93 d2 07 	sts	0x07D2, r25	; 0x8007d2 <eme_check+0x1>
     cec:	80 93 d1 07 	sts	0x07D1, r24	; 0x8007d1 <eme_check>
                                                                LCD_Write_String("User verified");
     cf0:	84 e6       	ldi	r24, 0x64	; 100
     cf2:	91 e0       	ldi	r25, 0x01	; 1
     cf4:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                                                                LCD_Goto(1, 0);
     cf8:	60 e0       	ldi	r22, 0x00	; 0
     cfa:	81 e0       	ldi	r24, 0x01	; 1
     cfc:	0e 94 83 0c 	call	0x1906	; 0x1906 <LCD_Goto>
                                                                LCD_Write_String("Welcome!");
     d00:	82 e7       	ldi	r24, 0x72	; 114
     d02:	91 e0       	ldi	r25, 0x01	; 1
     d04:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
     d08:	0c c0       	rjmp	.+24     	; 0xd22 <__vector_1+0x34a>
                                                        } else if (UART_GetValue == '2') {
     d0a:	82 33       	cpi	r24, 0x32	; 50
     d0c:	51 f4       	brne	.+20     	; 0xd22 <__vector_1+0x34a>
                                                                eme_check = 0;
     d0e:	10 92 d2 07 	sts	0x07D2, r1	; 0x8007d2 <eme_check+0x1>
     d12:	10 92 d1 07 	sts	0x07D1, r1	; 0x8007d1 <eme_check>
                                                                LCD_Clear();
     d16:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                                                LCD_Write_String("Admin Denied");
     d1a:	84 ee       	ldi	r24, 0xE4	; 228
     d1c:	91 e0       	ldi	r25, 0x01	; 1
     d1e:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                                                        }
                                                        Check_Counter = KP_Counter + 1;
     d22:	10 91 f1 07 	lds	r17, 0x07F1	; 0x8007f1 <KP_Counter>
     d26:	1f 5f       	subi	r17, 0xFF	; 255
     d28:	8f ef       	ldi	r24, 0xFF	; 255
     d2a:	99 e6       	ldi	r25, 0x69	; 105
     d2c:	28 e1       	ldi	r18, 0x18	; 24
     d2e:	81 50       	subi	r24, 0x01	; 1
     d30:	90 40       	sbci	r25, 0x00	; 0
     d32:	20 40       	sbci	r18, 0x00	; 0
     d34:	e1 f7       	brne	.-8      	; 0xd2e <__vector_1+0x356>
     d36:	00 c0       	rjmp	.+0      	; 0xd38 <__vector_1+0x360>
     d38:	00 00       	nop
                                                        _delay_ms(500);
                                                        LCD_Clear();
     d3a:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                                        UART_GetValue = 8;
     d3e:	88 e0       	ldi	r24, 0x08	; 8
     d40:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <UART_GetValue>

                                        if (user[1][0] == EEPROM_ReadByte(1, Check_Counter + 1) && user[1][1] == EEPROM_ReadByte(1, Check_Counter + 2) && user[1][2] == EEPROM_ReadByte(1, Check_Counter + 3) && user[1][3] == EEPROM_ReadByte(1, Check_Counter + 4))

                                        {
                                                /*----------------->right Username & Password<-----------------*/
                                                j = 4;
     d44:	68 94       	set
     d46:	77 24       	eor	r7, r7
     d48:	72 f8       	bld	r7, 2
                                                k = 4;
     d4a:	04 e0       	ldi	r16, 0x04	; 4
     d4c:	04 c0       	rjmp	.+8      	; 0xd56 <__vector_1+0x37e>

                                        if (user[1][0] == EEPROM_ReadByte(1, Check_Counter + 1) && user[1][1] == EEPROM_ReadByte(1, Check_Counter + 2) && user[1][2] == EEPROM_ReadByte(1, Check_Counter + 3) && user[1][3] == EEPROM_ReadByte(1, Check_Counter + 4))

                                        {
                                                /*----------------->right Username & Password<-----------------*/
                                                j = 4;
     d4e:	68 94       	set
     d50:	77 24       	eor	r7, r7
     d52:	72 f8       	bld	r7, 2
                                                k = 4;
     d54:	04 e0       	ldi	r16, 0x04	; 4
                                _delay_ms(500);

                        }
                        LCD_Clear();

                        for (Uint8 Check_Counter = 0; Check_Counter <= KP_Counter; Check_Counter += 4) {
     d56:	1c 5f       	subi	r17, 0xFC	; 252
     d58:	80 91 f1 07 	lds	r24, 0x07F1	; 0x8007f1 <KP_Counter>
     d5c:	81 17       	cp	r24, r17
     d5e:	08 f0       	brcs	.+2      	; 0xd62 <__vector_1+0x38a>
     d60:	f7 ce       	rjmp	.-530    	; 0xb50 <__vector_1+0x178>
                                        }
                                }
                        }

                        /*----------------->Wrong Username or Password<-----------------*/
                        if (k != 4) {
     d62:	04 30       	cpi	r16, 0x04	; 4
     d64:	b9 f0       	breq	.+46     	; 0xd94 <__vector_1+0x3bc>
                                LCD_Write_String("User/Pass Wrong");
     d66:	81 ef       	ldi	r24, 0xF1	; 241
     d68:	91 e0       	ldi	r25, 0x01	; 1
     d6a:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                                LCD_Goto(1, 0);
     d6e:	60 e0       	ldi	r22, 0x00	; 0
     d70:	81 e0       	ldi	r24, 0x01	; 1
     d72:	0e 94 83 0c 	call	0x1906	; 0x1906 <LCD_Goto>
                                LCD_Write_String("Try again");
     d76:	81 e0       	ldi	r24, 0x01	; 1
     d78:	92 e0       	ldi	r25, 0x02	; 2
     d7a:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
     d7e:	8f ef       	ldi	r24, 0xFF	; 255
     d80:	99 e6       	ldi	r25, 0x69	; 105
     d82:	28 e1       	ldi	r18, 0x18	; 24
     d84:	81 50       	subi	r24, 0x01	; 1
     d86:	90 40       	sbci	r25, 0x00	; 0
     d88:	20 40       	sbci	r18, 0x00	; 0
     d8a:	e1 f7       	brne	.-8      	; 0xd84 <__vector_1+0x3ac>
     d8c:	00 c0       	rjmp	.+0      	; 0xd8e <__vector_1+0x3b6>
     d8e:	00 00       	nop
                                _delay_ms(500);
                                LCD_Clear();
     d90:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                        }
                        k++;
     d94:	0f 5f       	subi	r16, 0xFF	; 255
                        /*----------------->Firing alarm in the third wrong trial of entering user and password <-----------------*/
                        if (k == 3) {
     d96:	03 30       	cpi	r16, 0x03	; 3
     d98:	49 f4       	brne	.+18     	; 0xdac <__vector_1+0x3d4>
                                LCD_Clear();
     d9a:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                LCD_Write_String("Firing Alarm!");
     d9e:	8b e0       	ldi	r24, 0x0B	; 11
     da0:	92 e0       	ldi	r25, 0x02	; 2
     da2:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>

                                while (1) {
                                        Alarm_Fn();
     da6:	0e 94 1a 07 	call	0xe34	; 0xe34 <Alarm_Fn>
     daa:	fd cf       	rjmp	.-6      	; 0xda6 <__vector_1+0x3ce>
                UART_TX_Str("\r\n");
                UART_TX_Str("The system is busy!\r\n");
                Servoo_Motor(97); //Closing the door in case the system stuck here for a while 

                /*----------------->Reciving username & password from KEYPAD <-----------------*/
                for (Uint8 j = 0; j < 3; j++) {
     dac:	73 94       	inc	r7
     dae:	82 e0       	ldi	r24, 0x02	; 2
     db0:	87 15       	cp	r24, r7
     db2:	08 f0       	brcs	.+2      	; 0xdb6 <__vector_1+0x3de>
     db4:	52 ce       	rjmp	.-860    	; 0xa5a <__vector_1+0x82>
                                        Alarm_Fn();
                                }
                        }
                }

                UART_TX_Str("System online!\r\n");
     db6:	89 e1       	ldi	r24, 0x19	; 25
     db8:	92 e0       	ldi	r25, 0x02	; 2
     dba:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                UART_TX_Str("Press any key to control the system\r\n");
     dbe:	8a e2       	ldi	r24, 0x2A	; 42
     dc0:	92 e0       	ldi	r25, 0x02	; 2
     dc2:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                UART_TX_Str("\r\n");
     dc6:	8a ed       	ldi	r24, 0xDA	; 218
     dc8:	92 e0       	ldi	r25, 0x02	; 2
     dca:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                UART_TX_Str("\r\n");
     dce:	8a ed       	ldi	r24, 0xDA	; 218
     dd0:	92 e0       	ldi	r25, 0x02	; 2
     dd2:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
     dd6:	06 c0       	rjmp	.+12     	; 0xde4 <__vector_1+0x40c>
        }

        /*----------------->logout from KEYPAD-LCD system <-----------------*/
        else {
                eme_check = 0;
     dd8:	10 92 d2 07 	sts	0x07D2, r1	; 0x8007d2 <eme_check+0x1>
     ddc:	10 92 d1 07 	sts	0x07D1, r1	; 0x8007d1 <eme_check>
                LCD_Clear();
     de0:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
        }
     de4:	28 96       	adiw	r28, 0x08	; 8
     de6:	0f b6       	in	r0, 0x3f	; 63
     de8:	f8 94       	cli
     dea:	de bf       	out	0x3e, r29	; 62
     dec:	0f be       	out	0x3f, r0	; 63
     dee:	cd bf       	out	0x3d, r28	; 61
     df0:	df 91       	pop	r29
     df2:	cf 91       	pop	r28
     df4:	ff 91       	pop	r31
     df6:	ef 91       	pop	r30
     df8:	bf 91       	pop	r27
     dfa:	af 91       	pop	r26
     dfc:	9f 91       	pop	r25
     dfe:	8f 91       	pop	r24
     e00:	7f 91       	pop	r23
     e02:	6f 91       	pop	r22
     e04:	5f 91       	pop	r21
     e06:	4f 91       	pop	r20
     e08:	3f 91       	pop	r19
     e0a:	2f 91       	pop	r18
     e0c:	1f 91       	pop	r17
     e0e:	0f 91       	pop	r16
     e10:	ff 90       	pop	r15
     e12:	ef 90       	pop	r14
     e14:	df 90       	pop	r13
     e16:	cf 90       	pop	r12
     e18:	bf 90       	pop	r11
     e1a:	af 90       	pop	r10
     e1c:	9f 90       	pop	r9
     e1e:	8f 90       	pop	r8
     e20:	7f 90       	pop	r7
     e22:	5f 90       	pop	r5
     e24:	4f 90       	pop	r4
     e26:	3f 90       	pop	r3
     e28:	2f 90       	pop	r2
     e2a:	0f 90       	pop	r0
     e2c:	0f be       	out	0x3f, r0	; 63
     e2e:	0f 90       	pop	r0
     e30:	1f 90       	pop	r1
     e32:	18 95       	reti

00000e34 <Alarm_Fn>:
#include "Functions.h"
#define Delay  60
#include <util/delay.h>
void Alarm_Fn(void){
	
	Buzzer_ON();
     e34:	0e 94 bf 00 	call	0x17e	; 0x17e <Buzzer_ON>
	LED3_ON();
     e38:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <LED3_ON>
	LED4_ON();
     e3c:	0e 94 1c 0d 	call	0x1a38	; 0x1a38 <LED4_ON>
	
	LED0_ON();
     e40:	0e 94 ac 0c 	call	0x1958	; 0x1958 <LED0_ON>
     e44:	2f ef       	ldi	r18, 0xFF	; 255
     e46:	8d ee       	ldi	r24, 0xED	; 237
     e48:	92 e0       	ldi	r25, 0x02	; 2
     e4a:	21 50       	subi	r18, 0x01	; 1
     e4c:	80 40       	sbci	r24, 0x00	; 0
     e4e:	90 40       	sbci	r25, 0x00	; 0
     e50:	e1 f7       	brne	.-8      	; 0xe4a <Alarm_Fn+0x16>
     e52:	00 c0       	rjmp	.+0      	; 0xe54 <Alarm_Fn+0x20>
     e54:	00 00       	nop
	_delay_ms(Delay);
	LED0_OFF();
     e56:	0e 94 b2 0c 	call	0x1964	; 0x1964 <LED0_OFF>
     e5a:	2f ef       	ldi	r18, 0xFF	; 255
     e5c:	8d ee       	ldi	r24, 0xED	; 237
     e5e:	92 e0       	ldi	r25, 0x02	; 2
     e60:	21 50       	subi	r18, 0x01	; 1
     e62:	80 40       	sbci	r24, 0x00	; 0
     e64:	90 40       	sbci	r25, 0x00	; 0
     e66:	e1 f7       	brne	.-8      	; 0xe60 <Alarm_Fn+0x2c>
     e68:	00 c0       	rjmp	.+0      	; 0xe6a <Alarm_Fn+0x36>
     e6a:	00 00       	nop
	_delay_ms(Delay);
	LED3_ON();
     e6c:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <LED3_ON>
	
	LED0_ON();
     e70:	0e 94 ac 0c 	call	0x1958	; 0x1958 <LED0_ON>
     e74:	2f ef       	ldi	r18, 0xFF	; 255
     e76:	8d ee       	ldi	r24, 0xED	; 237
     e78:	92 e0       	ldi	r25, 0x02	; 2
     e7a:	21 50       	subi	r18, 0x01	; 1
     e7c:	80 40       	sbci	r24, 0x00	; 0
     e7e:	90 40       	sbci	r25, 0x00	; 0
     e80:	e1 f7       	brne	.-8      	; 0xe7a <Alarm_Fn+0x46>
     e82:	00 c0       	rjmp	.+0      	; 0xe84 <Alarm_Fn+0x50>
     e84:	00 00       	nop
	_delay_ms(Delay);
	LED0_OFF();
     e86:	0e 94 b2 0c 	call	0x1964	; 0x1964 <LED0_OFF>
     e8a:	2f ef       	ldi	r18, 0xFF	; 255
     e8c:	8d ee       	ldi	r24, 0xED	; 237
     e8e:	92 e0       	ldi	r25, 0x02	; 2
     e90:	21 50       	subi	r18, 0x01	; 1
     e92:	80 40       	sbci	r24, 0x00	; 0
     e94:	90 40       	sbci	r25, 0x00	; 0
     e96:	e1 f7       	brne	.-8      	; 0xe90 <Alarm_Fn+0x5c>
     e98:	00 c0       	rjmp	.+0      	; 0xe9a <Alarm_Fn+0x66>
     e9a:	00 00       	nop
	_delay_ms(Delay);
	
	
	LED2_ON();
     e9c:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LED2_ON>
     ea0:	2f ef       	ldi	r18, 0xFF	; 255
     ea2:	8d ee       	ldi	r24, 0xED	; 237
     ea4:	92 e0       	ldi	r25, 0x02	; 2
     ea6:	21 50       	subi	r18, 0x01	; 1
     ea8:	80 40       	sbci	r24, 0x00	; 0
     eaa:	90 40       	sbci	r25, 0x00	; 0
     eac:	e1 f7       	brne	.-8      	; 0xea6 <Alarm_Fn+0x72>
     eae:	00 c0       	rjmp	.+0      	; 0xeb0 <Alarm_Fn+0x7c>
     eb0:	00 00       	nop
	_delay_ms(Delay);
	LED2_OFF();
     eb2:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <LED2_OFF>
     eb6:	2f ef       	ldi	r18, 0xFF	; 255
     eb8:	8d ee       	ldi	r24, 0xED	; 237
     eba:	92 e0       	ldi	r25, 0x02	; 2
     ebc:	21 50       	subi	r18, 0x01	; 1
     ebe:	80 40       	sbci	r24, 0x00	; 0
     ec0:	90 40       	sbci	r25, 0x00	; 0
     ec2:	e1 f7       	brne	.-8      	; 0xebc <Alarm_Fn+0x88>
     ec4:	00 c0       	rjmp	.+0      	; 0xec6 <Alarm_Fn+0x92>
     ec6:	00 00       	nop
	_delay_ms(Delay);
	
	
	LED2_ON();
     ec8:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LED2_ON>
     ecc:	2f ef       	ldi	r18, 0xFF	; 255
     ece:	8d ee       	ldi	r24, 0xED	; 237
     ed0:	92 e0       	ldi	r25, 0x02	; 2
     ed2:	21 50       	subi	r18, 0x01	; 1
     ed4:	80 40       	sbci	r24, 0x00	; 0
     ed6:	90 40       	sbci	r25, 0x00	; 0
     ed8:	e1 f7       	brne	.-8      	; 0xed2 <Alarm_Fn+0x9e>
     eda:	00 c0       	rjmp	.+0      	; 0xedc <Alarm_Fn+0xa8>
     edc:	00 00       	nop
	_delay_ms(Delay);
	LED2_OFF();
     ede:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <LED2_OFF>
     ee2:	2f ef       	ldi	r18, 0xFF	; 255
     ee4:	8d ee       	ldi	r24, 0xED	; 237
     ee6:	92 e0       	ldi	r25, 0x02	; 2
     ee8:	21 50       	subi	r18, 0x01	; 1
     eea:	80 40       	sbci	r24, 0x00	; 0
     eec:	90 40       	sbci	r25, 0x00	; 0
     eee:	e1 f7       	brne	.-8      	; 0xee8 <Alarm_Fn+0xb4>
     ef0:	00 c0       	rjmp	.+0      	; 0xef2 <Alarm_Fn+0xbe>
     ef2:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_ON();
     ef4:	0e 94 ac 0c 	call	0x1958	; 0x1958 <LED0_ON>
	LED2_ON();
     ef8:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LED2_ON>
     efc:	2f ef       	ldi	r18, 0xFF	; 255
     efe:	8d ee       	ldi	r24, 0xED	; 237
     f00:	92 e0       	ldi	r25, 0x02	; 2
     f02:	21 50       	subi	r18, 0x01	; 1
     f04:	80 40       	sbci	r24, 0x00	; 0
     f06:	90 40       	sbci	r25, 0x00	; 0
     f08:	e1 f7       	brne	.-8      	; 0xf02 <Alarm_Fn+0xce>
     f0a:	00 c0       	rjmp	.+0      	; 0xf0c <Alarm_Fn+0xd8>
     f0c:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_OFF();
     f0e:	0e 94 b2 0c 	call	0x1964	; 0x1964 <LED0_OFF>
	LED2_OFF();
     f12:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <LED2_OFF>
     f16:	2f ef       	ldi	r18, 0xFF	; 255
     f18:	8d ee       	ldi	r24, 0xED	; 237
     f1a:	92 e0       	ldi	r25, 0x02	; 2
     f1c:	21 50       	subi	r18, 0x01	; 1
     f1e:	80 40       	sbci	r24, 0x00	; 0
     f20:	90 40       	sbci	r25, 0x00	; 0
     f22:	e1 f7       	brne	.-8      	; 0xf1c <Alarm_Fn+0xe8>
     f24:	00 c0       	rjmp	.+0      	; 0xf26 <Alarm_Fn+0xf2>
     f26:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_OFF();
     f28:	0e 94 b2 0c 	call	0x1964	; 0x1964 <LED0_OFF>
	LED2_OFF();
     f2c:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <LED2_OFF>
     f30:	2f ef       	ldi	r18, 0xFF	; 255
     f32:	8d ee       	ldi	r24, 0xED	; 237
     f34:	92 e0       	ldi	r25, 0x02	; 2
     f36:	21 50       	subi	r18, 0x01	; 1
     f38:	80 40       	sbci	r24, 0x00	; 0
     f3a:	90 40       	sbci	r25, 0x00	; 0
     f3c:	e1 f7       	brne	.-8      	; 0xf36 <Alarm_Fn+0x102>
     f3e:	00 c0       	rjmp	.+0      	; 0xf40 <Alarm_Fn+0x10c>
     f40:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_ON();
     f42:	0e 94 ac 0c 	call	0x1958	; 0x1958 <LED0_ON>
	LED2_ON();
     f46:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LED2_ON>
     f4a:	2f ef       	ldi	r18, 0xFF	; 255
     f4c:	8d ee       	ldi	r24, 0xED	; 237
     f4e:	92 e0       	ldi	r25, 0x02	; 2
     f50:	21 50       	subi	r18, 0x01	; 1
     f52:	80 40       	sbci	r24, 0x00	; 0
     f54:	90 40       	sbci	r25, 0x00	; 0
     f56:	e1 f7       	brne	.-8      	; 0xf50 <Alarm_Fn+0x11c>
     f58:	00 c0       	rjmp	.+0      	; 0xf5a <Alarm_Fn+0x126>
     f5a:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_OFF();
     f5c:	0e 94 b2 0c 	call	0x1964	; 0x1964 <LED0_OFF>
	LED2_OFF();
     f60:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <LED2_OFF>
     f64:	2f ef       	ldi	r18, 0xFF	; 255
     f66:	8d ee       	ldi	r24, 0xED	; 237
     f68:	92 e0       	ldi	r25, 0x02	; 2
     f6a:	21 50       	subi	r18, 0x01	; 1
     f6c:	80 40       	sbci	r24, 0x00	; 0
     f6e:	90 40       	sbci	r25, 0x00	; 0
     f70:	e1 f7       	brne	.-8      	; 0xf6a <Alarm_Fn+0x136>
     f72:	00 c0       	rjmp	.+0      	; 0xf74 <Alarm_Fn+0x140>
     f74:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_ON();
     f76:	0e 94 ac 0c 	call	0x1958	; 0x1958 <LED0_ON>
     f7a:	2f ef       	ldi	r18, 0xFF	; 255
     f7c:	8d ee       	ldi	r24, 0xED	; 237
     f7e:	92 e0       	ldi	r25, 0x02	; 2
     f80:	21 50       	subi	r18, 0x01	; 1
     f82:	80 40       	sbci	r24, 0x00	; 0
     f84:	90 40       	sbci	r25, 0x00	; 0
     f86:	e1 f7       	brne	.-8      	; 0xf80 <Alarm_Fn+0x14c>
     f88:	00 c0       	rjmp	.+0      	; 0xf8a <Alarm_Fn+0x156>
     f8a:	00 00       	nop
	_delay_ms(Delay);
	LED0_OFF();
     f8c:	0e 94 b2 0c 	call	0x1964	; 0x1964 <LED0_OFF>
	LED2_ON();
     f90:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LED2_ON>
     f94:	2f ef       	ldi	r18, 0xFF	; 255
     f96:	8d ee       	ldi	r24, 0xED	; 237
     f98:	92 e0       	ldi	r25, 0x02	; 2
     f9a:	21 50       	subi	r18, 0x01	; 1
     f9c:	80 40       	sbci	r24, 0x00	; 0
     f9e:	90 40       	sbci	r25, 0x00	; 0
     fa0:	e1 f7       	brne	.-8      	; 0xf9a <Alarm_Fn+0x166>
     fa2:	00 c0       	rjmp	.+0      	; 0xfa4 <Alarm_Fn+0x170>
     fa4:	00 00       	nop
	_delay_ms(Delay);
	LED2_OFF();
     fa6:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <LED2_OFF>
     faa:	2f ef       	ldi	r18, 0xFF	; 255
     fac:	8d ee       	ldi	r24, 0xED	; 237
     fae:	92 e0       	ldi	r25, 0x02	; 2
     fb0:	21 50       	subi	r18, 0x01	; 1
     fb2:	80 40       	sbci	r24, 0x00	; 0
     fb4:	90 40       	sbci	r25, 0x00	; 0
     fb6:	e1 f7       	brne	.-8      	; 0xfb0 <Alarm_Fn+0x17c>
     fb8:	00 c0       	rjmp	.+0      	; 0xfba <Alarm_Fn+0x186>
     fba:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_ON();
     fbc:	0e 94 ac 0c 	call	0x1958	; 0x1958 <LED0_ON>
     fc0:	2f ef       	ldi	r18, 0xFF	; 255
     fc2:	8d ee       	ldi	r24, 0xED	; 237
     fc4:	92 e0       	ldi	r25, 0x02	; 2
     fc6:	21 50       	subi	r18, 0x01	; 1
     fc8:	80 40       	sbci	r24, 0x00	; 0
     fca:	90 40       	sbci	r25, 0x00	; 0
     fcc:	e1 f7       	brne	.-8      	; 0xfc6 <Alarm_Fn+0x192>
     fce:	00 c0       	rjmp	.+0      	; 0xfd0 <Alarm_Fn+0x19c>
     fd0:	00 00       	nop
	_delay_ms(Delay);
	LED0_OFF();
     fd2:	0e 94 b2 0c 	call	0x1964	; 0x1964 <LED0_OFF>
	LED2_ON();
     fd6:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LED2_ON>
     fda:	2f ef       	ldi	r18, 0xFF	; 255
     fdc:	8d ee       	ldi	r24, 0xED	; 237
     fde:	92 e0       	ldi	r25, 0x02	; 2
     fe0:	21 50       	subi	r18, 0x01	; 1
     fe2:	80 40       	sbci	r24, 0x00	; 0
     fe4:	90 40       	sbci	r25, 0x00	; 0
     fe6:	e1 f7       	brne	.-8      	; 0xfe0 <Alarm_Fn+0x1ac>
     fe8:	00 c0       	rjmp	.+0      	; 0xfea <Alarm_Fn+0x1b6>
     fea:	00 00       	nop
	_delay_ms(Delay);
	LED2_OFF();
     fec:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <LED2_OFF>
     ff0:	2f ef       	ldi	r18, 0xFF	; 255
     ff2:	8d ee       	ldi	r24, 0xED	; 237
     ff4:	92 e0       	ldi	r25, 0x02	; 2
     ff6:	21 50       	subi	r18, 0x01	; 1
     ff8:	80 40       	sbci	r24, 0x00	; 0
     ffa:	90 40       	sbci	r25, 0x00	; 0
     ffc:	e1 f7       	brne	.-8      	; 0xff6 <Alarm_Fn+0x1c2>
     ffe:	00 c0       	rjmp	.+0      	; 0x1000 <Alarm_Fn+0x1cc>
    1000:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_ON();
    1002:	0e 94 ac 0c 	call	0x1958	; 0x1958 <LED0_ON>
    1006:	2f ef       	ldi	r18, 0xFF	; 255
    1008:	8d ee       	ldi	r24, 0xED	; 237
    100a:	92 e0       	ldi	r25, 0x02	; 2
    100c:	21 50       	subi	r18, 0x01	; 1
    100e:	80 40       	sbci	r24, 0x00	; 0
    1010:	90 40       	sbci	r25, 0x00	; 0
    1012:	e1 f7       	brne	.-8      	; 0x100c <Alarm_Fn+0x1d8>
    1014:	00 c0       	rjmp	.+0      	; 0x1016 <Alarm_Fn+0x1e2>
    1016:	00 00       	nop
	_delay_ms(Delay);
	LED0_OFF();
    1018:	0e 94 b2 0c 	call	0x1964	; 0x1964 <LED0_OFF>
	LED2_ON();
    101c:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LED2_ON>
    1020:	2f ef       	ldi	r18, 0xFF	; 255
    1022:	8d ee       	ldi	r24, 0xED	; 237
    1024:	92 e0       	ldi	r25, 0x02	; 2
    1026:	21 50       	subi	r18, 0x01	; 1
    1028:	80 40       	sbci	r24, 0x00	; 0
    102a:	90 40       	sbci	r25, 0x00	; 0
    102c:	e1 f7       	brne	.-8      	; 0x1026 <Alarm_Fn+0x1f2>
    102e:	00 c0       	rjmp	.+0      	; 0x1030 <Alarm_Fn+0x1fc>
    1030:	00 00       	nop
	_delay_ms(Delay);
	LED2_OFF();
    1032:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <LED2_OFF>
    1036:	2f ef       	ldi	r18, 0xFF	; 255
    1038:	8d ee       	ldi	r24, 0xED	; 237
    103a:	92 e0       	ldi	r25, 0x02	; 2
    103c:	21 50       	subi	r18, 0x01	; 1
    103e:	80 40       	sbci	r24, 0x00	; 0
    1040:	90 40       	sbci	r25, 0x00	; 0
    1042:	e1 f7       	brne	.-8      	; 0x103c <Alarm_Fn+0x208>
    1044:	00 c0       	rjmp	.+0      	; 0x1046 <Alarm_Fn+0x212>
    1046:	00 00       	nop
	_delay_ms(Delay);
	Buzzer_OFF();
    1048:	0e 94 c5 00 	call	0x18a	; 0x18a <Buzzer_OFF>
	
	LED0_ON();
    104c:	0e 94 ac 0c 	call	0x1958	; 0x1958 <LED0_ON>
    1050:	2f ef       	ldi	r18, 0xFF	; 255
    1052:	8d ee       	ldi	r24, 0xED	; 237
    1054:	92 e0       	ldi	r25, 0x02	; 2
    1056:	21 50       	subi	r18, 0x01	; 1
    1058:	80 40       	sbci	r24, 0x00	; 0
    105a:	90 40       	sbci	r25, 0x00	; 0
    105c:	e1 f7       	brne	.-8      	; 0x1056 <Alarm_Fn+0x222>
    105e:	00 c0       	rjmp	.+0      	; 0x1060 <Alarm_Fn+0x22c>
    1060:	00 00       	nop
	_delay_ms(Delay);
	LED0_OFF();
    1062:	0e 94 b2 0c 	call	0x1964	; 0x1964 <LED0_OFF>
	LED2_ON();
    1066:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LED2_ON>
    106a:	2f ef       	ldi	r18, 0xFF	; 255
    106c:	8d ee       	ldi	r24, 0xED	; 237
    106e:	92 e0       	ldi	r25, 0x02	; 2
    1070:	21 50       	subi	r18, 0x01	; 1
    1072:	80 40       	sbci	r24, 0x00	; 0
    1074:	90 40       	sbci	r25, 0x00	; 0
    1076:	e1 f7       	brne	.-8      	; 0x1070 <Alarm_Fn+0x23c>
    1078:	00 c0       	rjmp	.+0      	; 0x107a <Alarm_Fn+0x246>
    107a:	00 00       	nop
	_delay_ms(Delay);
	LED2_OFF();
    107c:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <LED2_OFF>
    1080:	2f ef       	ldi	r18, 0xFF	; 255
    1082:	8d ee       	ldi	r24, 0xED	; 237
    1084:	92 e0       	ldi	r25, 0x02	; 2
    1086:	21 50       	subi	r18, 0x01	; 1
    1088:	80 40       	sbci	r24, 0x00	; 0
    108a:	90 40       	sbci	r25, 0x00	; 0
    108c:	e1 f7       	brne	.-8      	; 0x1086 <Alarm_Fn+0x252>
    108e:	00 c0       	rjmp	.+0      	; 0x1090 <Alarm_Fn+0x25c>
    1090:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_ON();
    1092:	0e 94 ac 0c 	call	0x1958	; 0x1958 <LED0_ON>
    1096:	2f ef       	ldi	r18, 0xFF	; 255
    1098:	8d ee       	ldi	r24, 0xED	; 237
    109a:	92 e0       	ldi	r25, 0x02	; 2
    109c:	21 50       	subi	r18, 0x01	; 1
    109e:	80 40       	sbci	r24, 0x00	; 0
    10a0:	90 40       	sbci	r25, 0x00	; 0
    10a2:	e1 f7       	brne	.-8      	; 0x109c <Alarm_Fn+0x268>
    10a4:	00 c0       	rjmp	.+0      	; 0x10a6 <Alarm_Fn+0x272>
    10a6:	00 00       	nop
	_delay_ms(Delay);
	LED0_OFF();
    10a8:	0e 94 b2 0c 	call	0x1964	; 0x1964 <LED0_OFF>
    10ac:	2f ef       	ldi	r18, 0xFF	; 255
    10ae:	8d ee       	ldi	r24, 0xED	; 237
    10b0:	92 e0       	ldi	r25, 0x02	; 2
    10b2:	21 50       	subi	r18, 0x01	; 1
    10b4:	80 40       	sbci	r24, 0x00	; 0
    10b6:	90 40       	sbci	r25, 0x00	; 0
    10b8:	e1 f7       	brne	.-8      	; 0x10b2 <Alarm_Fn+0x27e>
    10ba:	00 c0       	rjmp	.+0      	; 0x10bc <Alarm_Fn+0x288>
    10bc:	00 00       	nop
	_delay_ms(Delay);
	
	
	LED2_ON();
    10be:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LED2_ON>
    10c2:	2f ef       	ldi	r18, 0xFF	; 255
    10c4:	8d ee       	ldi	r24, 0xED	; 237
    10c6:	92 e0       	ldi	r25, 0x02	; 2
    10c8:	21 50       	subi	r18, 0x01	; 1
    10ca:	80 40       	sbci	r24, 0x00	; 0
    10cc:	90 40       	sbci	r25, 0x00	; 0
    10ce:	e1 f7       	brne	.-8      	; 0x10c8 <Alarm_Fn+0x294>
    10d0:	00 c0       	rjmp	.+0      	; 0x10d2 <Alarm_Fn+0x29e>
    10d2:	00 00       	nop
	_delay_ms(Delay);
	LED2_OFF();
    10d4:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <LED2_OFF>
    10d8:	2f ef       	ldi	r18, 0xFF	; 255
    10da:	8d ee       	ldi	r24, 0xED	; 237
    10dc:	92 e0       	ldi	r25, 0x02	; 2
    10de:	21 50       	subi	r18, 0x01	; 1
    10e0:	80 40       	sbci	r24, 0x00	; 0
    10e2:	90 40       	sbci	r25, 0x00	; 0
    10e4:	e1 f7       	brne	.-8      	; 0x10de <Alarm_Fn+0x2aa>
    10e6:	00 c0       	rjmp	.+0      	; 0x10e8 <Alarm_Fn+0x2b4>
    10e8:	00 00       	nop
	_delay_ms(Delay);
	
	LED2_ON();
    10ea:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LED2_ON>
    10ee:	2f ef       	ldi	r18, 0xFF	; 255
    10f0:	8d ee       	ldi	r24, 0xED	; 237
    10f2:	92 e0       	ldi	r25, 0x02	; 2
    10f4:	21 50       	subi	r18, 0x01	; 1
    10f6:	80 40       	sbci	r24, 0x00	; 0
    10f8:	90 40       	sbci	r25, 0x00	; 0
    10fa:	e1 f7       	brne	.-8      	; 0x10f4 <Alarm_Fn+0x2c0>
    10fc:	00 c0       	rjmp	.+0      	; 0x10fe <Alarm_Fn+0x2ca>
    10fe:	00 00       	nop
	_delay_ms(Delay);
	LED2_OFF();
    1100:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <LED2_OFF>
    1104:	2f ef       	ldi	r18, 0xFF	; 255
    1106:	8d ee       	ldi	r24, 0xED	; 237
    1108:	92 e0       	ldi	r25, 0x02	; 2
    110a:	21 50       	subi	r18, 0x01	; 1
    110c:	80 40       	sbci	r24, 0x00	; 0
    110e:	90 40       	sbci	r25, 0x00	; 0
    1110:	e1 f7       	brne	.-8      	; 0x110a <Alarm_Fn+0x2d6>
    1112:	00 c0       	rjmp	.+0      	; 0x1114 <Alarm_Fn+0x2e0>
    1114:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_ON();
    1116:	0e 94 ac 0c 	call	0x1958	; 0x1958 <LED0_ON>
	LED2_ON();
    111a:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LED2_ON>
    111e:	2f ef       	ldi	r18, 0xFF	; 255
    1120:	8d ee       	ldi	r24, 0xED	; 237
    1122:	92 e0       	ldi	r25, 0x02	; 2
    1124:	21 50       	subi	r18, 0x01	; 1
    1126:	80 40       	sbci	r24, 0x00	; 0
    1128:	90 40       	sbci	r25, 0x00	; 0
    112a:	e1 f7       	brne	.-8      	; 0x1124 <Alarm_Fn+0x2f0>
    112c:	00 c0       	rjmp	.+0      	; 0x112e <Alarm_Fn+0x2fa>
    112e:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_OFF();
    1130:	0e 94 b2 0c 	call	0x1964	; 0x1964 <LED0_OFF>
	LED2_OFF();
    1134:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <LED2_OFF>
    1138:	2f ef       	ldi	r18, 0xFF	; 255
    113a:	8d ee       	ldi	r24, 0xED	; 237
    113c:	92 e0       	ldi	r25, 0x02	; 2
    113e:	21 50       	subi	r18, 0x01	; 1
    1140:	80 40       	sbci	r24, 0x00	; 0
    1142:	90 40       	sbci	r25, 0x00	; 0
    1144:	e1 f7       	brne	.-8      	; 0x113e <Alarm_Fn+0x30a>
    1146:	00 c0       	rjmp	.+0      	; 0x1148 <Alarm_Fn+0x314>
    1148:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_ON();
    114a:	0e 94 ac 0c 	call	0x1958	; 0x1958 <LED0_ON>
	LED2_ON();
    114e:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LED2_ON>
    1152:	2f ef       	ldi	r18, 0xFF	; 255
    1154:	8d ee       	ldi	r24, 0xED	; 237
    1156:	92 e0       	ldi	r25, 0x02	; 2
    1158:	21 50       	subi	r18, 0x01	; 1
    115a:	80 40       	sbci	r24, 0x00	; 0
    115c:	90 40       	sbci	r25, 0x00	; 0
    115e:	e1 f7       	brne	.-8      	; 0x1158 <Alarm_Fn+0x324>
    1160:	00 c0       	rjmp	.+0      	; 0x1162 <Alarm_Fn+0x32e>
    1162:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_OFF();
    1164:	0e 94 b2 0c 	call	0x1964	; 0x1964 <LED0_OFF>
	LED2_OFF();
    1168:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <LED2_OFF>
    116c:	2f ef       	ldi	r18, 0xFF	; 255
    116e:	8d ee       	ldi	r24, 0xED	; 237
    1170:	92 e0       	ldi	r25, 0x02	; 2
    1172:	21 50       	subi	r18, 0x01	; 1
    1174:	80 40       	sbci	r24, 0x00	; 0
    1176:	90 40       	sbci	r25, 0x00	; 0
    1178:	e1 f7       	brne	.-8      	; 0x1172 <Alarm_Fn+0x33e>
    117a:	00 c0       	rjmp	.+0      	; 0x117c <Alarm_Fn+0x348>
    117c:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_ON();
    117e:	0e 94 ac 0c 	call	0x1958	; 0x1958 <LED0_ON>
    1182:	2f ef       	ldi	r18, 0xFF	; 255
    1184:	8d ee       	ldi	r24, 0xED	; 237
    1186:	92 e0       	ldi	r25, 0x02	; 2
    1188:	21 50       	subi	r18, 0x01	; 1
    118a:	80 40       	sbci	r24, 0x00	; 0
    118c:	90 40       	sbci	r25, 0x00	; 0
    118e:	e1 f7       	brne	.-8      	; 0x1188 <Alarm_Fn+0x354>
    1190:	00 c0       	rjmp	.+0      	; 0x1192 <Alarm_Fn+0x35e>
    1192:	00 00       	nop
	_delay_ms(Delay);
	LED0_OFF();
    1194:	0e 94 b2 0c 	call	0x1964	; 0x1964 <LED0_OFF>
	LED2_ON();
    1198:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LED2_ON>
    119c:	2f ef       	ldi	r18, 0xFF	; 255
    119e:	8d ee       	ldi	r24, 0xED	; 237
    11a0:	92 e0       	ldi	r25, 0x02	; 2
    11a2:	21 50       	subi	r18, 0x01	; 1
    11a4:	80 40       	sbci	r24, 0x00	; 0
    11a6:	90 40       	sbci	r25, 0x00	; 0
    11a8:	e1 f7       	brne	.-8      	; 0x11a2 <Alarm_Fn+0x36e>
    11aa:	00 c0       	rjmp	.+0      	; 0x11ac <Alarm_Fn+0x378>
    11ac:	00 00       	nop
	_delay_ms(Delay);
	LED2_OFF();
    11ae:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <LED2_OFF>
    11b2:	2f ef       	ldi	r18, 0xFF	; 255
    11b4:	8d ee       	ldi	r24, 0xED	; 237
    11b6:	92 e0       	ldi	r25, 0x02	; 2
    11b8:	21 50       	subi	r18, 0x01	; 1
    11ba:	80 40       	sbci	r24, 0x00	; 0
    11bc:	90 40       	sbci	r25, 0x00	; 0
    11be:	e1 f7       	brne	.-8      	; 0x11b8 <Alarm_Fn+0x384>
    11c0:	00 c0       	rjmp	.+0      	; 0x11c2 <Alarm_Fn+0x38e>
    11c2:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_ON();
    11c4:	0e 94 ac 0c 	call	0x1958	; 0x1958 <LED0_ON>
    11c8:	2f ef       	ldi	r18, 0xFF	; 255
    11ca:	8d ee       	ldi	r24, 0xED	; 237
    11cc:	92 e0       	ldi	r25, 0x02	; 2
    11ce:	21 50       	subi	r18, 0x01	; 1
    11d0:	80 40       	sbci	r24, 0x00	; 0
    11d2:	90 40       	sbci	r25, 0x00	; 0
    11d4:	e1 f7       	brne	.-8      	; 0x11ce <Alarm_Fn+0x39a>
    11d6:	00 c0       	rjmp	.+0      	; 0x11d8 <Alarm_Fn+0x3a4>
    11d8:	00 00       	nop
	_delay_ms(Delay);
	LED0_OFF();
    11da:	0e 94 b2 0c 	call	0x1964	; 0x1964 <LED0_OFF>
	LED2_ON();
    11de:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LED2_ON>
    11e2:	2f ef       	ldi	r18, 0xFF	; 255
    11e4:	8d ee       	ldi	r24, 0xED	; 237
    11e6:	92 e0       	ldi	r25, 0x02	; 2
    11e8:	21 50       	subi	r18, 0x01	; 1
    11ea:	80 40       	sbci	r24, 0x00	; 0
    11ec:	90 40       	sbci	r25, 0x00	; 0
    11ee:	e1 f7       	brne	.-8      	; 0x11e8 <Alarm_Fn+0x3b4>
    11f0:	00 c0       	rjmp	.+0      	; 0x11f2 <Alarm_Fn+0x3be>
    11f2:	00 00       	nop
	_delay_ms(Delay);
	LED2_OFF();
    11f4:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <LED2_OFF>
    11f8:	2f ef       	ldi	r18, 0xFF	; 255
    11fa:	8d ee       	ldi	r24, 0xED	; 237
    11fc:	92 e0       	ldi	r25, 0x02	; 2
    11fe:	21 50       	subi	r18, 0x01	; 1
    1200:	80 40       	sbci	r24, 0x00	; 0
    1202:	90 40       	sbci	r25, 0x00	; 0
    1204:	e1 f7       	brne	.-8      	; 0x11fe <Alarm_Fn+0x3ca>
    1206:	00 c0       	rjmp	.+0      	; 0x1208 <Alarm_Fn+0x3d4>
    1208:	00 00       	nop
	_delay_ms(Delay);
	
	
	
	
	LED0_Toggle();
    120a:	0e 94 b8 0c 	call	0x1970	; 0x1970 <LED0_Toggle>
	Buzzer_Toggle();
    120e:	0e 94 cb 00 	call	0x196	; 0x196 <Buzzer_Toggle>
    1212:	2f ef       	ldi	r18, 0xFF	; 255
    1214:	8d ee       	ldi	r24, 0xED	; 237
    1216:	92 e0       	ldi	r25, 0x02	; 2
    1218:	21 50       	subi	r18, 0x01	; 1
    121a:	80 40       	sbci	r24, 0x00	; 0
    121c:	90 40       	sbci	r25, 0x00	; 0
    121e:	e1 f7       	brne	.-8      	; 0x1218 <Alarm_Fn+0x3e4>
    1220:	00 c0       	rjmp	.+0      	; 0x1222 <Alarm_Fn+0x3ee>
    1222:	00 00       	nop
	_delay_ms(Delay);
	LED0_Toggle();
    1224:	0e 94 b8 0c 	call	0x1970	; 0x1970 <LED0_Toggle>
	Buzzer_Toggle();
    1228:	0e 94 cb 00 	call	0x196	; 0x196 <Buzzer_Toggle>
    122c:	2f ef       	ldi	r18, 0xFF	; 255
    122e:	83 ec       	ldi	r24, 0xC3	; 195
    1230:	99 e0       	ldi	r25, 0x09	; 9
    1232:	21 50       	subi	r18, 0x01	; 1
    1234:	80 40       	sbci	r24, 0x00	; 0
    1236:	90 40       	sbci	r25, 0x00	; 0
    1238:	e1 f7       	brne	.-8      	; 0x1232 <Alarm_Fn+0x3fe>
    123a:	00 c0       	rjmp	.+0      	; 0x123c <Alarm_Fn+0x408>
    123c:	00 00       	nop
	_delay_ms(200);
	LED0_Toggle();
    123e:	0e 94 b8 0c 	call	0x1970	; 0x1970 <LED0_Toggle>
	Buzzer_Toggle();
    1242:	0e 94 cb 00 	call	0x196	; 0x196 <Buzzer_Toggle>
    1246:	2f ef       	ldi	r18, 0xFF	; 255
    1248:	89 e6       	ldi	r24, 0x69	; 105
    124a:	98 e1       	ldi	r25, 0x18	; 24
    124c:	21 50       	subi	r18, 0x01	; 1
    124e:	80 40       	sbci	r24, 0x00	; 0
    1250:	90 40       	sbci	r25, 0x00	; 0
    1252:	e1 f7       	brne	.-8      	; 0x124c <Alarm_Fn+0x418>
    1254:	00 c0       	rjmp	.+0      	; 0x1256 <Alarm_Fn+0x422>
    1256:	00 00       	nop
	_delay_ms(500);
	LED0_Toggle();
    1258:	0e 94 b8 0c 	call	0x1970	; 0x1970 <LED0_Toggle>
	Buzzer_Toggle();
    125c:	0e 94 cb 00 	call	0x196	; 0x196 <Buzzer_Toggle>
    1260:	2f ef       	ldi	r18, 0xFF	; 255
    1262:	81 ee       	ldi	r24, 0xE1	; 225
    1264:	94 e0       	ldi	r25, 0x04	; 4
    1266:	21 50       	subi	r18, 0x01	; 1
    1268:	80 40       	sbci	r24, 0x00	; 0
    126a:	90 40       	sbci	r25, 0x00	; 0
    126c:	e1 f7       	brne	.-8      	; 0x1266 <Alarm_Fn+0x432>
    126e:	00 c0       	rjmp	.+0      	; 0x1270 <Alarm_Fn+0x43c>
    1270:	00 00       	nop
	_delay_ms(100);
	LED0_Toggle();
    1272:	0e 94 b8 0c 	call	0x1970	; 0x1970 <LED0_Toggle>
	Buzzer_Toggle();
    1276:	0e 94 cb 00 	call	0x196	; 0x196 <Buzzer_Toggle>
    127a:	2f ef       	ldi	r18, 0xFF	; 255
    127c:	8d ee       	ldi	r24, 0xED	; 237
    127e:	92 e0       	ldi	r25, 0x02	; 2
    1280:	21 50       	subi	r18, 0x01	; 1
    1282:	80 40       	sbci	r24, 0x00	; 0
    1284:	90 40       	sbci	r25, 0x00	; 0
    1286:	e1 f7       	brne	.-8      	; 0x1280 <Alarm_Fn+0x44c>
    1288:	00 c0       	rjmp	.+0      	; 0x128a <Alarm_Fn+0x456>
    128a:	00 00       	nop
	_delay_ms(Delay);
	LED0_Toggle();
    128c:	0e 94 b8 0c 	call	0x1970	; 0x1970 <LED0_Toggle>
	Buzzer_Toggle();
    1290:	0e 94 cb 00 	call	0x196	; 0x196 <Buzzer_Toggle>
    1294:	2f ef       	ldi	r18, 0xFF	; 255
    1296:	8d ee       	ldi	r24, 0xED	; 237
    1298:	92 e0       	ldi	r25, 0x02	; 2
    129a:	21 50       	subi	r18, 0x01	; 1
    129c:	80 40       	sbci	r24, 0x00	; 0
    129e:	90 40       	sbci	r25, 0x00	; 0
    12a0:	e1 f7       	brne	.-8      	; 0x129a <Alarm_Fn+0x466>
    12a2:	00 c0       	rjmp	.+0      	; 0x12a4 <Alarm_Fn+0x470>
    12a4:	00 00       	nop
	_delay_ms(Delay);
	LED0_Toggle();
    12a6:	0e 94 b8 0c 	call	0x1970	; 0x1970 <LED0_Toggle>
	Buzzer_Toggle();
    12aa:	0e 94 cb 00 	call	0x196	; 0x196 <Buzzer_Toggle>
    12ae:	8f e3       	ldi	r24, 0x3F	; 63
    12b0:	9c e9       	ldi	r25, 0x9C	; 156
    12b2:	01 97       	sbiw	r24, 0x01	; 1
    12b4:	f1 f7       	brne	.-4      	; 0x12b2 <Alarm_Fn+0x47e>
    12b6:	00 c0       	rjmp	.+0      	; 0x12b8 <Alarm_Fn+0x484>
    12b8:	00 00       	nop
	_delay_ms(10);
	LED0_Toggle();
    12ba:	0e 94 b8 0c 	call	0x1970	; 0x1970 <LED0_Toggle>
	Buzzer_Toggle();
    12be:	0e 94 cb 00 	call	0x196	; 0x196 <Buzzer_Toggle>
    12c2:	9f ef       	ldi	r25, 0xFF	; 255
    12c4:	2d ee       	ldi	r18, 0xED	; 237
    12c6:	82 e0       	ldi	r24, 0x02	; 2
    12c8:	91 50       	subi	r25, 0x01	; 1
    12ca:	20 40       	sbci	r18, 0x00	; 0
    12cc:	80 40       	sbci	r24, 0x00	; 0
    12ce:	e1 f7       	brne	.-8      	; 0x12c8 <Alarm_Fn+0x494>
    12d0:	00 c0       	rjmp	.+0      	; 0x12d2 <Alarm_Fn+0x49e>
    12d2:	00 00       	nop
	_delay_ms(Delay);
	LED0_Toggle();
    12d4:	0e 94 b8 0c 	call	0x1970	; 0x1970 <LED0_Toggle>
	Buzzer_Toggle();
    12d8:	0e 94 cb 00 	call	0x196	; 0x196 <Buzzer_Toggle>
    12dc:	9f ef       	ldi	r25, 0xFF	; 255
    12de:	2d ee       	ldi	r18, 0xED	; 237
    12e0:	82 e0       	ldi	r24, 0x02	; 2
    12e2:	91 50       	subi	r25, 0x01	; 1
    12e4:	20 40       	sbci	r18, 0x00	; 0
    12e6:	80 40       	sbci	r24, 0x00	; 0
    12e8:	e1 f7       	brne	.-8      	; 0x12e2 <Alarm_Fn+0x4ae>
    12ea:	00 c0       	rjmp	.+0      	; 0x12ec <Alarm_Fn+0x4b8>
    12ec:	00 00       	nop
	_delay_ms(Delay);
	
	LED0_Toggle();
    12ee:	0e 94 b8 0c 	call	0x1970	; 0x1970 <LED0_Toggle>
	Buzzer_Toggle();
    12f2:	0e 94 cb 00 	call	0x196	; 0x196 <Buzzer_Toggle>
    12f6:	9f ef       	ldi	r25, 0xFF	; 255
    12f8:	2d ee       	ldi	r18, 0xED	; 237
    12fa:	82 e0       	ldi	r24, 0x02	; 2
    12fc:	91 50       	subi	r25, 0x01	; 1
    12fe:	20 40       	sbci	r18, 0x00	; 0
    1300:	80 40       	sbci	r24, 0x00	; 0
    1302:	e1 f7       	brne	.-8      	; 0x12fc <Alarm_Fn+0x4c8>
    1304:	00 c0       	rjmp	.+0      	; 0x1306 <Alarm_Fn+0x4d2>
    1306:	00 00       	nop
	_delay_ms(Delay);
	LED2_Toggle();
    1308:	0e 94 f0 0c 	call	0x19e0	; 0x19e0 <LED2_Toggle>
	LED3_Toggle();
    130c:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <LED3_Toggle>
	LED0_Toggle();
    1310:	0e 94 b8 0c 	call	0x1970	; 0x1970 <LED0_Toggle>
	LED1_Toggle();
    1314:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <LED1_Toggle>
	LED4_Toggle();
    1318:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <LED4_Toggle>
	Buzzer_Toggle();
    131c:	0e 94 cb 00 	call	0x196	; 0x196 <Buzzer_Toggle>
    1320:	9f ef       	ldi	r25, 0xFF	; 255
    1322:	23 ec       	ldi	r18, 0xC3	; 195
    1324:	89 e0       	ldi	r24, 0x09	; 9
    1326:	91 50       	subi	r25, 0x01	; 1
    1328:	20 40       	sbci	r18, 0x00	; 0
    132a:	80 40       	sbci	r24, 0x00	; 0
    132c:	e1 f7       	brne	.-8      	; 0x1326 <Alarm_Fn+0x4f2>
    132e:	00 c0       	rjmp	.+0      	; 0x1330 <Alarm_Fn+0x4fc>
    1330:	00 00       	nop
	_delay_ms(200);
	LED0_Toggle();
    1332:	0e 94 b8 0c 	call	0x1970	; 0x1970 <LED0_Toggle>
	LED2_Toggle();
    1336:	0e 94 f0 0c 	call	0x19e0	; 0x19e0 <LED2_Toggle>
	LED3_Toggle();
    133a:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <LED3_Toggle>
	LED1_Toggle();
    133e:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <LED1_Toggle>
	LED4_Toggle();
    1342:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <LED4_Toggle>
	Buzzer_Toggle();
    1346:	0e 94 cb 00 	call	0x196	; 0x196 <Buzzer_Toggle>
    134a:	9f ef       	ldi	r25, 0xFF	; 255
    134c:	2d ee       	ldi	r18, 0xED	; 237
    134e:	82 e0       	ldi	r24, 0x02	; 2
    1350:	91 50       	subi	r25, 0x01	; 1
    1352:	20 40       	sbci	r18, 0x00	; 0
    1354:	80 40       	sbci	r24, 0x00	; 0
    1356:	e1 f7       	brne	.-8      	; 0x1350 <Alarm_Fn+0x51c>
    1358:	00 c0       	rjmp	.+0      	; 0x135a <Alarm_Fn+0x526>
    135a:	00 00       	nop
	_delay_ms(Delay);
	LED2_Toggle();
    135c:	0e 94 f0 0c 	call	0x19e0	; 0x19e0 <LED2_Toggle>
	LED3_Toggle();
    1360:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <LED3_Toggle>
	LED0_Toggle();
    1364:	0e 94 b8 0c 	call	0x1970	; 0x1970 <LED0_Toggle>
	LED1_Toggle();
    1368:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <LED1_Toggle>
	LED4_Toggle();
    136c:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <LED4_Toggle>
	Buzzer_Toggle();
    1370:	0e 94 cb 00 	call	0x196	; 0x196 <Buzzer_Toggle>
    1374:	9f ef       	ldi	r25, 0xFF	; 255
    1376:	21 ee       	ldi	r18, 0xE1	; 225
    1378:	84 e0       	ldi	r24, 0x04	; 4
    137a:	91 50       	subi	r25, 0x01	; 1
    137c:	20 40       	sbci	r18, 0x00	; 0
    137e:	80 40       	sbci	r24, 0x00	; 0
    1380:	e1 f7       	brne	.-8      	; 0x137a <Alarm_Fn+0x546>
    1382:	00 c0       	rjmp	.+0      	; 0x1384 <Alarm_Fn+0x550>
    1384:	00 00       	nop
	_delay_ms(100);
	LED2_Toggle();
    1386:	0e 94 f0 0c 	call	0x19e0	; 0x19e0 <LED2_Toggle>
	LED3_Toggle();
    138a:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <LED3_Toggle>
	LED0_Toggle();
    138e:	0e 94 b8 0c 	call	0x1970	; 0x1970 <LED0_Toggle>
	LED1_Toggle();
    1392:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <LED1_Toggle>
	LED4_Toggle();
    1396:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <LED4_Toggle>
	Buzzer_Toggle();
    139a:	0e 94 cb 00 	call	0x196	; 0x196 <Buzzer_Toggle>
    139e:	9f ef       	ldi	r25, 0xFF	; 255
    13a0:	2d ee       	ldi	r18, 0xED	; 237
    13a2:	82 e0       	ldi	r24, 0x02	; 2
    13a4:	91 50       	subi	r25, 0x01	; 1
    13a6:	20 40       	sbci	r18, 0x00	; 0
    13a8:	80 40       	sbci	r24, 0x00	; 0
    13aa:	e1 f7       	brne	.-8      	; 0x13a4 <Alarm_Fn+0x570>
    13ac:	00 c0       	rjmp	.+0      	; 0x13ae <Alarm_Fn+0x57a>
    13ae:	00 00       	nop
	_delay_ms(Delay);
	LED2_Toggle();
    13b0:	0e 94 f0 0c 	call	0x19e0	; 0x19e0 <LED2_Toggle>
	LED3_Toggle();
    13b4:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <LED3_Toggle>
	LED0_Toggle();
    13b8:	0e 94 b8 0c 	call	0x1970	; 0x1970 <LED0_Toggle>
	LED1_Toggle();
    13bc:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <LED1_Toggle>
	LED4_Toggle();
    13c0:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <LED4_Toggle>
	Buzzer_Toggle();
    13c4:	0e 94 cb 00 	call	0x196	; 0x196 <Buzzer_Toggle>
    13c8:	9f ef       	ldi	r25, 0xFF	; 255
    13ca:	23 ed       	ldi	r18, 0xD3	; 211
    13cc:	80 e3       	ldi	r24, 0x30	; 48
    13ce:	91 50       	subi	r25, 0x01	; 1
    13d0:	20 40       	sbci	r18, 0x00	; 0
    13d2:	80 40       	sbci	r24, 0x00	; 0
    13d4:	e1 f7       	brne	.-8      	; 0x13ce <Alarm_Fn+0x59a>
    13d6:	00 c0       	rjmp	.+0      	; 0x13d8 <Alarm_Fn+0x5a4>
    13d8:	00 00       	nop
	_delay_ms(1000);
	LED2_Toggle();
    13da:	0e 94 f0 0c 	call	0x19e0	; 0x19e0 <LED2_Toggle>
	LED3_Toggle();
    13de:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <LED3_Toggle>
	LED0_Toggle();
    13e2:	0e 94 b8 0c 	call	0x1970	; 0x1970 <LED0_Toggle>
	LED1_Toggle();
    13e6:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <LED1_Toggle>
	LED4_Toggle();
    13ea:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <LED4_Toggle>
	Buzzer_Toggle();
    13ee:	0e 94 cb 00 	call	0x196	; 0x196 <Buzzer_Toggle>
    13f2:	8f e3       	ldi	r24, 0x3F	; 63
    13f4:	9c e9       	ldi	r25, 0x9C	; 156
    13f6:	01 97       	sbiw	r24, 0x01	; 1
    13f8:	f1 f7       	brne	.-4      	; 0x13f6 <Alarm_Fn+0x5c2>
    13fa:	00 c0       	rjmp	.+0      	; 0x13fc <Alarm_Fn+0x5c8>
    13fc:	00 00       	nop
	_delay_ms(10);
	LED2_Toggle();
    13fe:	0e 94 f0 0c 	call	0x19e0	; 0x19e0 <LED2_Toggle>
	LED3_Toggle();
    1402:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <LED3_Toggle>
	LED0_Toggle();
    1406:	0e 94 b8 0c 	call	0x1970	; 0x1970 <LED0_Toggle>
	LED1_Toggle();
    140a:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <LED1_Toggle>
	LED4_Toggle();
    140e:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <LED4_Toggle>
	Buzzer_Toggle();
    1412:	0e 94 cb 00 	call	0x196	; 0x196 <Buzzer_Toggle>
    1416:	8f e3       	ldi	r24, 0x3F	; 63
    1418:	9c e9       	ldi	r25, 0x9C	; 156
    141a:	01 97       	sbiw	r24, 0x01	; 1
    141c:	f1 f7       	brne	.-4      	; 0x141a <Alarm_Fn+0x5e6>
    141e:	00 c0       	rjmp	.+0      	; 0x1420 <Alarm_Fn+0x5ec>
    1420:	00 00       	nop
	_delay_ms(10);
	LED2_Toggle();
    1422:	0e 94 f0 0c 	call	0x19e0	; 0x19e0 <LED2_Toggle>
	LED3_Toggle();
    1426:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <LED3_Toggle>
	LED0_Toggle();
    142a:	0e 94 b8 0c 	call	0x1970	; 0x1970 <LED0_Toggle>
	LED1_Toggle();
    142e:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <LED1_Toggle>
	LED4_Toggle();
    1432:	0e 94 28 0d 	call	0x1a50	; 0x1a50 <LED4_Toggle>
	Buzzer_Toggle();
    1436:	0e 94 cb 00 	call	0x196	; 0x196 <Buzzer_Toggle>
    143a:	9f ef       	ldi	r25, 0xFF	; 255
    143c:	21 ee       	ldi	r18, 0xE1	; 225
    143e:	84 e0       	ldi	r24, 0x04	; 4
    1440:	91 50       	subi	r25, 0x01	; 1
    1442:	20 40       	sbci	r18, 0x00	; 0
    1444:	80 40       	sbci	r24, 0x00	; 0
    1446:	e1 f7       	brne	.-8      	; 0x1440 <Alarm_Fn+0x60c>
    1448:	00 c0       	rjmp	.+0      	; 0x144a <Alarm_Fn+0x616>
    144a:	00 00       	nop
	_delay_ms(100);
	
	LED0_Toggle();
    144c:	0e 94 b8 0c 	call	0x1970	; 0x1970 <LED0_Toggle>
	Buzzer_ON();
    1450:	0e 94 bf 00 	call	0x17e	; 0x17e <Buzzer_ON>
    1454:	9f ef       	ldi	r25, 0xFF	; 255
    1456:	24 e3       	ldi	r18, 0x34	; 52
    1458:	8c e0       	ldi	r24, 0x0C	; 12
    145a:	91 50       	subi	r25, 0x01	; 1
    145c:	20 40       	sbci	r18, 0x00	; 0
    145e:	80 40       	sbci	r24, 0x00	; 0
    1460:	e1 f7       	brne	.-8      	; 0x145a <Alarm_Fn+0x626>
    1462:	00 c0       	rjmp	.+0      	; 0x1464 <Alarm_Fn+0x630>
    1464:	00 00       	nop
	_delay_ms(250);
	LED0_Toggle();
    1466:	0e 94 b8 0c 	call	0x1970	; 0x1970 <LED0_Toggle>
	Buzzer_Toggle();
    146a:	0e 94 cb 00 	call	0x196	; 0x196 <Buzzer_Toggle>
    146e:	9f ef       	ldi	r25, 0xFF	; 255
    1470:	24 e3       	ldi	r18, 0x34	; 52
    1472:	8c e0       	ldi	r24, 0x0C	; 12
    1474:	91 50       	subi	r25, 0x01	; 1
    1476:	20 40       	sbci	r18, 0x00	; 0
    1478:	80 40       	sbci	r24, 0x00	; 0
    147a:	e1 f7       	brne	.-8      	; 0x1474 <Alarm_Fn+0x640>
    147c:	00 c0       	rjmp	.+0      	; 0x147e <Alarm_Fn+0x64a>
    147e:	00 00       	nop
	_delay_ms(250);
	LED0_Toggle();
    1480:	0e 94 b8 0c 	call	0x1970	; 0x1970 <LED0_Toggle>
	Buzzer_ON();
    1484:	0e 94 bf 00 	call	0x17e	; 0x17e <Buzzer_ON>
    1488:	9f ef       	ldi	r25, 0xFF	; 255
    148a:	2d ee       	ldi	r18, 0xED	; 237
    148c:	82 e0       	ldi	r24, 0x02	; 2
    148e:	91 50       	subi	r25, 0x01	; 1
    1490:	20 40       	sbci	r18, 0x00	; 0
    1492:	80 40       	sbci	r24, 0x00	; 0
    1494:	e1 f7       	brne	.-8      	; 0x148e <Alarm_Fn+0x65a>
    1496:	00 c0       	rjmp	.+0      	; 0x1498 <Alarm_Fn+0x664>
    1498:	00 00       	nop
	_delay_ms(Delay);
	Buzzer_OFF();
    149a:	0e 94 c5 00 	call	0x18a	; 0x18a <Buzzer_OFF>
    149e:	08 95       	ret

000014a0 <I2C_INIT>:
        // 	{
        // 		(*pptr0)();
        // 		(*pptr1)(string16);
        // 	}
        return TWDR;
}
    14a0:	80 e8       	ldi	r24, 0x80	; 128
    14a2:	8f bf       	out	0x3f, r24	; 63
    14a4:	85 e0       	ldi	r24, 0x05	; 5
    14a6:	86 bf       	out	0x36, r24	; 54
    14a8:	8c e0       	ldi	r24, 0x0C	; 12
    14aa:	80 b9       	out	0x00, r24	; 0
    14ac:	11 b8       	out	0x01, r1	; 1
    14ae:	08 95       	ret

000014b0 <I2C_SendStartCond>:
    14b0:	84 ea       	ldi	r24, 0xA4	; 164
    14b2:	86 bf       	out	0x36, r24	; 54
    14b4:	06 b6       	in	r0, 0x36	; 54
    14b6:	07 fe       	sbrs	r0, 7
    14b8:	fd cf       	rjmp	.-6      	; 0x14b4 <I2C_SendStartCond+0x4>
    14ba:	08 95       	ret

000014bc <I2C_SendRepStartCond>:
    14bc:	84 ea       	ldi	r24, 0xA4	; 164
    14be:	86 bf       	out	0x36, r24	; 54
    14c0:	06 b6       	in	r0, 0x36	; 54
    14c2:	07 fe       	sbrs	r0, 7
    14c4:	fd cf       	rjmp	.-6      	; 0x14c0 <I2C_SendRepStartCond+0x4>
    14c6:	08 95       	ret

000014c8 <I2C_SendSlaveAdd_WriteOP>:
    14c8:	88 0f       	add	r24, r24
    14ca:	83 b9       	out	0x03, r24	; 3
    14cc:	84 e8       	ldi	r24, 0x84	; 132
    14ce:	86 bf       	out	0x36, r24	; 54
    14d0:	06 b6       	in	r0, 0x36	; 54
    14d2:	07 fe       	sbrs	r0, 7
    14d4:	fd cf       	rjmp	.-6      	; 0x14d0 <I2C_SendSlaveAdd_WriteOP+0x8>
    14d6:	2f ef       	ldi	r18, 0xFF	; 255
    14d8:	81 ee       	ldi	r24, 0xE1	; 225
    14da:	94 e0       	ldi	r25, 0x04	; 4
    14dc:	21 50       	subi	r18, 0x01	; 1
    14de:	80 40       	sbci	r24, 0x00	; 0
    14e0:	90 40       	sbci	r25, 0x00	; 0
    14e2:	e1 f7       	brne	.-8      	; 0x14dc <I2C_SendSlaveAdd_WriteOP+0x14>
    14e4:	00 c0       	rjmp	.+0      	; 0x14e6 <I2C_SendSlaveAdd_WriteOP+0x1e>
    14e6:	00 00       	nop
    14e8:	08 95       	ret

000014ea <I2C_SendSlaveAdd_ReadOP>:
    14ea:	90 e0       	ldi	r25, 0x00	; 0
    14ec:	88 0f       	add	r24, r24
    14ee:	99 1f       	adc	r25, r25
    14f0:	81 60       	ori	r24, 0x01	; 1
    14f2:	83 b9       	out	0x03, r24	; 3
    14f4:	84 e8       	ldi	r24, 0x84	; 132
    14f6:	86 bf       	out	0x36, r24	; 54
    14f8:	06 b6       	in	r0, 0x36	; 54
    14fa:	07 fe       	sbrs	r0, 7
    14fc:	fd cf       	rjmp	.-6      	; 0x14f8 <I2C_SendSlaveAdd_ReadOP+0xe>
    14fe:	08 95       	ret

00001500 <I2C_SendData>:
    1500:	83 b9       	out	0x03, r24	; 3
    1502:	84 e8       	ldi	r24, 0x84	; 132
    1504:	86 bf       	out	0x36, r24	; 54
    1506:	06 b6       	in	r0, 0x36	; 54
    1508:	07 fe       	sbrs	r0, 7
    150a:	fd cf       	rjmp	.-6      	; 0x1506 <I2C_SendData+0x6>
    150c:	08 95       	ret

0000150e <I2C_ReadData>:
    150e:	84 e8       	ldi	r24, 0x84	; 132
    1510:	86 bf       	out	0x36, r24	; 54
    1512:	06 b6       	in	r0, 0x36	; 54
    1514:	07 fe       	sbrs	r0, 7
    1516:	fd cf       	rjmp	.-6      	; 0x1512 <I2C_ReadData+0x4>
    1518:	83 b1       	in	r24, 0x03	; 3
    151a:	08 95       	ret

0000151c <I2C_SendStopCond>:

void I2C_SendStopCond(void) {
        TWCR = (1 << TWSTO) | (1 << TWEN) | (1 << TWINT);
    151c:	84 e9       	ldi	r24, 0x94	; 148
    151e:	86 bf       	out	0x36, r24	; 54
        Set_Bit(TWCR, 7);
    1520:	86 b7       	in	r24, 0x36	; 54
    1522:	80 68       	ori	r24, 0x80	; 128
    1524:	86 bf       	out	0x36, r24	; 54
    1526:	08 95       	ret

00001528 <Keypad_Init>:
    1528:	40 e0       	ldi	r20, 0x00	; 0
    152a:	63 e0       	ldi	r22, 0x03	; 3
    152c:	80 e0       	ldi	r24, 0x00	; 0
    152e:	0e 94 23 03 	call	0x646	; 0x646 <DIO_SetPin_Dir>
    1532:	40 e0       	ldi	r20, 0x00	; 0
    1534:	64 e0       	ldi	r22, 0x04	; 4
    1536:	80 e0       	ldi	r24, 0x00	; 0
    1538:	0e 94 23 03 	call	0x646	; 0x646 <DIO_SetPin_Dir>
    153c:	40 e0       	ldi	r20, 0x00	; 0
    153e:	65 e0       	ldi	r22, 0x05	; 5
    1540:	80 e0       	ldi	r24, 0x00	; 0
    1542:	0e 94 23 03 	call	0x646	; 0x646 <DIO_SetPin_Dir>
    1546:	40 e0       	ldi	r20, 0x00	; 0
    1548:	66 e0       	ldi	r22, 0x06	; 6
    154a:	80 e0       	ldi	r24, 0x00	; 0
    154c:	0e 94 23 03 	call	0x646	; 0x646 <DIO_SetPin_Dir>
    1550:	63 e0       	ldi	r22, 0x03	; 3
    1552:	80 e0       	ldi	r24, 0x00	; 0
    1554:	0e 94 67 04 	call	0x8ce	; 0x8ce <DIO_SetPin_Pullup>
    1558:	64 e0       	ldi	r22, 0x04	; 4
    155a:	80 e0       	ldi	r24, 0x00	; 0
    155c:	0e 94 67 04 	call	0x8ce	; 0x8ce <DIO_SetPin_Pullup>
    1560:	65 e0       	ldi	r22, 0x05	; 5
    1562:	80 e0       	ldi	r24, 0x00	; 0
    1564:	0e 94 67 04 	call	0x8ce	; 0x8ce <DIO_SetPin_Pullup>
    1568:	66 e0       	ldi	r22, 0x06	; 6
    156a:	80 e0       	ldi	r24, 0x00	; 0
    156c:	0e 94 67 04 	call	0x8ce	; 0x8ce <DIO_SetPin_Pullup>
    1570:	41 e0       	ldi	r20, 0x01	; 1
    1572:	60 e0       	ldi	r22, 0x00	; 0
    1574:	80 e0       	ldi	r24, 0x00	; 0
    1576:	0e 94 23 03 	call	0x646	; 0x646 <DIO_SetPin_Dir>
    157a:	41 e0       	ldi	r20, 0x01	; 1
    157c:	61 e0       	ldi	r22, 0x01	; 1
    157e:	80 e0       	ldi	r24, 0x00	; 0
    1580:	0e 94 23 03 	call	0x646	; 0x646 <DIO_SetPin_Dir>
    1584:	41 e0       	ldi	r20, 0x01	; 1
    1586:	62 e0       	ldi	r22, 0x02	; 2
    1588:	80 e0       	ldi	r24, 0x00	; 0
    158a:	0e 94 23 03 	call	0x646	; 0x646 <DIO_SetPin_Dir>
    158e:	40 e0       	ldi	r20, 0x00	; 0
    1590:	60 e0       	ldi	r22, 0x00	; 0
    1592:	80 e0       	ldi	r24, 0x00	; 0
    1594:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    1598:	40 e0       	ldi	r20, 0x00	; 0
    159a:	61 e0       	ldi	r22, 0x01	; 1
    159c:	80 e0       	ldi	r24, 0x00	; 0
    159e:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    15a2:	40 e0       	ldi	r20, 0x00	; 0
    15a4:	62 e0       	ldi	r22, 0x02	; 2
    15a6:	80 e0       	ldi	r24, 0x00	; 0
    15a8:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    15ac:	08 95       	ret

000015ae <Keypad_GetValue>:
    15ae:	1f 93       	push	r17
    15b0:	cf 93       	push	r28
    15b2:	df 93       	push	r29
    15b4:	d0 e0       	ldi	r29, 0x00	; 0
    15b6:	10 e0       	ldi	r17, 0x00	; 0
    15b8:	28 c0       	rjmp	.+80     	; 0x160a <Keypad_GetValue+0x5c>
    15ba:	41 e0       	ldi	r20, 0x01	; 1
    15bc:	6d 2f       	mov	r22, r29
    15be:	80 e0       	ldi	r24, 0x00	; 0
    15c0:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    15c4:	c3 e0       	ldi	r28, 0x03	; 3
    15c6:	19 c0       	rjmp	.+50     	; 0x15fa <Keypad_GetValue+0x4c>
    15c8:	6c 2f       	mov	r22, r28
    15ca:	80 e0       	ldi	r24, 0x00	; 0
    15cc:	0e 94 05 04 	call	0x80a	; 0x80a <DIO_GetPin_Value>
    15d0:	81 11       	cpse	r24, r1
    15d2:	12 c0       	rjmp	.+36     	; 0x15f8 <Keypad_GetValue+0x4a>
    15d4:	ec 2f       	mov	r30, r28
    15d6:	f0 e0       	ldi	r31, 0x00	; 0
    15d8:	33 97       	sbiw	r30, 0x03	; 3
    15da:	ee 0f       	add	r30, r30
    15dc:	ff 1f       	adc	r31, r31
    15de:	ee 0f       	add	r30, r30
    15e0:	ff 1f       	adc	r31, r31
    15e2:	e0 5a       	subi	r30, 0xA0	; 160
    15e4:	ff 4f       	sbci	r31, 0xFF	; 255
    15e6:	ed 0f       	add	r30, r29
    15e8:	f1 1d       	adc	r31, r1
    15ea:	10 81       	ld	r17, Z
    15ec:	6c 2f       	mov	r22, r28
    15ee:	80 e0       	ldi	r24, 0x00	; 0
    15f0:	0e 94 05 04 	call	0x80a	; 0x80a <DIO_GetPin_Value>
    15f4:	88 23       	and	r24, r24
    15f6:	d1 f3       	breq	.-12     	; 0x15ec <Keypad_GetValue+0x3e>
    15f8:	cf 5f       	subi	r28, 0xFF	; 255
    15fa:	c7 30       	cpi	r28, 0x07	; 7
    15fc:	28 f3       	brcs	.-54     	; 0x15c8 <Keypad_GetValue+0x1a>
    15fe:	40 e0       	ldi	r20, 0x00	; 0
    1600:	6d 2f       	mov	r22, r29
    1602:	80 e0       	ldi	r24, 0x00	; 0
    1604:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    1608:	df 5f       	subi	r29, 0xFF	; 255
    160a:	d3 30       	cpi	r29, 0x03	; 3
    160c:	b0 f2       	brcs	.-84     	; 0x15ba <Keypad_GetValue+0xc>
    160e:	81 2f       	mov	r24, r17
    1610:	df 91       	pop	r29
    1612:	cf 91       	pop	r28
    1614:	1f 91       	pop	r17
    1616:	08 95       	ret

00001618 <LCD_Write_CMD>:
    1618:	cf 93       	push	r28
    161a:	c8 2f       	mov	r28, r24
    161c:	41 e0       	ldi	r20, 0x01	; 1
    161e:	60 e0       	ldi	r22, 0x00	; 0
    1620:	81 e0       	ldi	r24, 0x01	; 1
    1622:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    1626:	41 e0       	ldi	r20, 0x01	; 1
    1628:	61 e0       	ldi	r22, 0x01	; 1
    162a:	81 e0       	ldi	r24, 0x01	; 1
    162c:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    1630:	41 e0       	ldi	r20, 0x01	; 1
    1632:	62 e0       	ldi	r22, 0x02	; 2
    1634:	81 e0       	ldi	r24, 0x01	; 1
    1636:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    163a:	88 b3       	in	r24, 0x18	; 24
    163c:	9c 2f       	mov	r25, r28
    163e:	90 7f       	andi	r25, 0xF0	; 240
    1640:	8f 70       	andi	r24, 0x0F	; 15
    1642:	89 2b       	or	r24, r25
    1644:	88 bb       	out	0x18, r24	; 24
    1646:	40 e0       	ldi	r20, 0x00	; 0
    1648:	62 e0       	ldi	r22, 0x02	; 2
    164a:	81 e0       	ldi	r24, 0x01	; 1
    164c:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    1650:	8f e9       	ldi	r24, 0x9F	; 159
    1652:	9f e0       	ldi	r25, 0x0F	; 15
    1654:	01 97       	sbiw	r24, 0x01	; 1
    1656:	f1 f7       	brne	.-4      	; 0x1654 <LCD_Write_CMD+0x3c>
    1658:	00 c0       	rjmp	.+0      	; 0x165a <LCD_Write_CMD+0x42>
    165a:	00 00       	nop
    165c:	41 e0       	ldi	r20, 0x01	; 1
    165e:	62 e0       	ldi	r22, 0x02	; 2
    1660:	81 e0       	ldi	r24, 0x01	; 1
    1662:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    1666:	20 e1       	ldi	r18, 0x10	; 16
    1668:	c2 9f       	mul	r28, r18
    166a:	c0 01       	movw	r24, r0
    166c:	11 24       	eor	r1, r1
    166e:	98 b3       	in	r25, 0x18	; 24
    1670:	9f 70       	andi	r25, 0x0F	; 15
    1672:	89 2b       	or	r24, r25
    1674:	88 bb       	out	0x18, r24	; 24
    1676:	40 e0       	ldi	r20, 0x00	; 0
    1678:	62 e0       	ldi	r22, 0x02	; 2
    167a:	81 e0       	ldi	r24, 0x01	; 1
    167c:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    1680:	8f e9       	ldi	r24, 0x9F	; 159
    1682:	9f e0       	ldi	r25, 0x0F	; 15
    1684:	01 97       	sbiw	r24, 0x01	; 1
    1686:	f1 f7       	brne	.-4      	; 0x1684 <LCD_Write_CMD+0x6c>
    1688:	00 c0       	rjmp	.+0      	; 0x168a <LCD_Write_CMD+0x72>
    168a:	00 00       	nop
    168c:	41 e0       	ldi	r20, 0x01	; 1
    168e:	62 e0       	ldi	r22, 0x02	; 2
    1690:	81 e0       	ldi	r24, 0x01	; 1
    1692:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    1696:	8f e1       	ldi	r24, 0x1F	; 31
    1698:	9e e4       	ldi	r25, 0x4E	; 78
    169a:	01 97       	sbiw	r24, 0x01	; 1
    169c:	f1 f7       	brne	.-4      	; 0x169a <LCD_Write_CMD+0x82>
    169e:	00 c0       	rjmp	.+0      	; 0x16a0 <LCD_Write_CMD+0x88>
    16a0:	00 00       	nop
    16a2:	cf 91       	pop	r28
    16a4:	08 95       	ret

000016a6 <LCD_Init>:
    16a6:	41 e0       	ldi	r20, 0x01	; 1
    16a8:	60 e0       	ldi	r22, 0x00	; 0
    16aa:	81 e0       	ldi	r24, 0x01	; 1
    16ac:	0e 94 23 03 	call	0x646	; 0x646 <DIO_SetPin_Dir>
    16b0:	41 e0       	ldi	r20, 0x01	; 1
    16b2:	61 e0       	ldi	r22, 0x01	; 1
    16b4:	81 e0       	ldi	r24, 0x01	; 1
    16b6:	0e 94 23 03 	call	0x646	; 0x646 <DIO_SetPin_Dir>
    16ba:	41 e0       	ldi	r20, 0x01	; 1
    16bc:	62 e0       	ldi	r22, 0x02	; 2
    16be:	81 e0       	ldi	r24, 0x01	; 1
    16c0:	0e 94 23 03 	call	0x646	; 0x646 <DIO_SetPin_Dir>
    16c4:	41 e0       	ldi	r20, 0x01	; 1
    16c6:	64 e0       	ldi	r22, 0x04	; 4
    16c8:	81 e0       	ldi	r24, 0x01	; 1
    16ca:	0e 94 23 03 	call	0x646	; 0x646 <DIO_SetPin_Dir>
    16ce:	41 e0       	ldi	r20, 0x01	; 1
    16d0:	65 e0       	ldi	r22, 0x05	; 5
    16d2:	81 e0       	ldi	r24, 0x01	; 1
    16d4:	0e 94 23 03 	call	0x646	; 0x646 <DIO_SetPin_Dir>
    16d8:	41 e0       	ldi	r20, 0x01	; 1
    16da:	66 e0       	ldi	r22, 0x06	; 6
    16dc:	81 e0       	ldi	r24, 0x01	; 1
    16de:	0e 94 23 03 	call	0x646	; 0x646 <DIO_SetPin_Dir>
    16e2:	41 e0       	ldi	r20, 0x01	; 1
    16e4:	67 e0       	ldi	r22, 0x07	; 7
    16e6:	81 e0       	ldi	r24, 0x01	; 1
    16e8:	0e 94 23 03 	call	0x646	; 0x646 <DIO_SetPin_Dir>
    16ec:	41 e0       	ldi	r20, 0x01	; 1
    16ee:	60 e0       	ldi	r22, 0x00	; 0
    16f0:	81 e0       	ldi	r24, 0x01	; 1
    16f2:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    16f6:	41 e0       	ldi	r20, 0x01	; 1
    16f8:	61 e0       	ldi	r22, 0x01	; 1
    16fa:	81 e0       	ldi	r24, 0x01	; 1
    16fc:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    1700:	41 e0       	ldi	r20, 0x01	; 1
    1702:	62 e0       	ldi	r22, 0x02	; 2
    1704:	81 e0       	ldi	r24, 0x01	; 1
    1706:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    170a:	41 e0       	ldi	r20, 0x01	; 1
    170c:	64 e0       	ldi	r22, 0x04	; 4
    170e:	81 e0       	ldi	r24, 0x01	; 1
    1710:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    1714:	41 e0       	ldi	r20, 0x01	; 1
    1716:	65 e0       	ldi	r22, 0x05	; 5
    1718:	81 e0       	ldi	r24, 0x01	; 1
    171a:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    171e:	41 e0       	ldi	r20, 0x01	; 1
    1720:	66 e0       	ldi	r22, 0x06	; 6
    1722:	81 e0       	ldi	r24, 0x01	; 1
    1724:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    1728:	41 e0       	ldi	r20, 0x01	; 1
    172a:	67 e0       	ldi	r22, 0x07	; 7
    172c:	81 e0       	ldi	r24, 0x01	; 1
    172e:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    1732:	2f ef       	ldi	r18, 0xFF	; 255
    1734:	81 ee       	ldi	r24, 0xE1	; 225
    1736:	94 e0       	ldi	r25, 0x04	; 4
    1738:	21 50       	subi	r18, 0x01	; 1
    173a:	80 40       	sbci	r24, 0x00	; 0
    173c:	90 40       	sbci	r25, 0x00	; 0
    173e:	e1 f7       	brne	.-8      	; 0x1738 <LCD_Init+0x92>
    1740:	00 c0       	rjmp	.+0      	; 0x1742 <LCD_Init+0x9c>
    1742:	00 00       	nop
    1744:	83 e3       	ldi	r24, 0x33	; 51
    1746:	0e 94 0c 0b 	call	0x1618	; 0x1618 <LCD_Write_CMD>
    174a:	82 e3       	ldi	r24, 0x32	; 50
    174c:	0e 94 0c 0b 	call	0x1618	; 0x1618 <LCD_Write_CMD>
    1750:	88 e2       	ldi	r24, 0x28	; 40
    1752:	0e 94 0c 0b 	call	0x1618	; 0x1618 <LCD_Write_CMD>
    1756:	81 e0       	ldi	r24, 0x01	; 1
    1758:	0e 94 0c 0b 	call	0x1618	; 0x1618 <LCD_Write_CMD>
    175c:	82 e0       	ldi	r24, 0x02	; 2
    175e:	0e 94 0c 0b 	call	0x1618	; 0x1618 <LCD_Write_CMD>
    1762:	86 e0       	ldi	r24, 0x06	; 6
    1764:	0e 94 0c 0b 	call	0x1618	; 0x1618 <LCD_Write_CMD>
    1768:	8e e0       	ldi	r24, 0x0E	; 14
    176a:	0e 94 0c 0b 	call	0x1618	; 0x1618 <LCD_Write_CMD>
    176e:	08 95       	ret

00001770 <LCD_Write_Char>:
    1770:	cf 93       	push	r28
    1772:	c8 2f       	mov	r28, r24
    1774:	40 e0       	ldi	r20, 0x00	; 0
    1776:	60 e0       	ldi	r22, 0x00	; 0
    1778:	81 e0       	ldi	r24, 0x01	; 1
    177a:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    177e:	41 e0       	ldi	r20, 0x01	; 1
    1780:	61 e0       	ldi	r22, 0x01	; 1
    1782:	81 e0       	ldi	r24, 0x01	; 1
    1784:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    1788:	41 e0       	ldi	r20, 0x01	; 1
    178a:	62 e0       	ldi	r22, 0x02	; 2
    178c:	81 e0       	ldi	r24, 0x01	; 1
    178e:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    1792:	88 b3       	in	r24, 0x18	; 24
    1794:	9c 2f       	mov	r25, r28
    1796:	90 7f       	andi	r25, 0xF0	; 240
    1798:	8f 70       	andi	r24, 0x0F	; 15
    179a:	89 2b       	or	r24, r25
    179c:	88 bb       	out	0x18, r24	; 24
    179e:	40 e0       	ldi	r20, 0x00	; 0
    17a0:	62 e0       	ldi	r22, 0x02	; 2
    17a2:	81 e0       	ldi	r24, 0x01	; 1
    17a4:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    17a8:	8f e9       	ldi	r24, 0x9F	; 159
    17aa:	9f e0       	ldi	r25, 0x0F	; 15
    17ac:	01 97       	sbiw	r24, 0x01	; 1
    17ae:	f1 f7       	brne	.-4      	; 0x17ac <LCD_Write_Char+0x3c>
    17b0:	00 c0       	rjmp	.+0      	; 0x17b2 <LCD_Write_Char+0x42>
    17b2:	00 00       	nop
    17b4:	41 e0       	ldi	r20, 0x01	; 1
    17b6:	62 e0       	ldi	r22, 0x02	; 2
    17b8:	81 e0       	ldi	r24, 0x01	; 1
    17ba:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    17be:	20 e1       	ldi	r18, 0x10	; 16
    17c0:	c2 9f       	mul	r28, r18
    17c2:	c0 01       	movw	r24, r0
    17c4:	11 24       	eor	r1, r1
    17c6:	98 b3       	in	r25, 0x18	; 24
    17c8:	9f 70       	andi	r25, 0x0F	; 15
    17ca:	89 2b       	or	r24, r25
    17cc:	88 bb       	out	0x18, r24	; 24
    17ce:	40 e0       	ldi	r20, 0x00	; 0
    17d0:	62 e0       	ldi	r22, 0x02	; 2
    17d2:	81 e0       	ldi	r24, 0x01	; 1
    17d4:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    17d8:	8f e9       	ldi	r24, 0x9F	; 159
    17da:	9f e0       	ldi	r25, 0x0F	; 15
    17dc:	01 97       	sbiw	r24, 0x01	; 1
    17de:	f1 f7       	brne	.-4      	; 0x17dc <LCD_Write_Char+0x6c>
    17e0:	00 c0       	rjmp	.+0      	; 0x17e2 <LCD_Write_Char+0x72>
    17e2:	00 00       	nop
    17e4:	41 e0       	ldi	r20, 0x01	; 1
    17e6:	62 e0       	ldi	r22, 0x02	; 2
    17e8:	81 e0       	ldi	r24, 0x01	; 1
    17ea:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    17ee:	cf 91       	pop	r28
    17f0:	08 95       	ret

000017f2 <LCD_Write_String>:
    17f2:	0f 93       	push	r16
    17f4:	1f 93       	push	r17
    17f6:	cf 93       	push	r28
    17f8:	8c 01       	movw	r16, r24
    17fa:	c0 e0       	ldi	r28, 0x00	; 0
    17fc:	03 c0       	rjmp	.+6      	; 0x1804 <LCD_Write_String+0x12>
    17fe:	0e 94 b8 0b 	call	0x1770	; 0x1770 <LCD_Write_Char>
    1802:	cf 5f       	subi	r28, 0xFF	; 255
    1804:	f8 01       	movw	r30, r16
    1806:	ec 0f       	add	r30, r28
    1808:	f1 1d       	adc	r31, r1
    180a:	80 81       	ld	r24, Z
    180c:	81 11       	cpse	r24, r1
    180e:	f7 cf       	rjmp	.-18     	; 0x17fe <LCD_Write_String+0xc>
    1810:	cf 91       	pop	r28
    1812:	1f 91       	pop	r17
    1814:	0f 91       	pop	r16
    1816:	08 95       	ret

00001818 <LCD_Write_Integer>:
    1818:	8f 92       	push	r8
    181a:	9f 92       	push	r9
    181c:	af 92       	push	r10
    181e:	bf 92       	push	r11
    1820:	ef 92       	push	r14
    1822:	ff 92       	push	r15
    1824:	0f 93       	push	r16
    1826:	1f 93       	push	r17
    1828:	cf 93       	push	r28
    182a:	df 93       	push	r29
    182c:	4b 01       	movw	r8, r22
    182e:	5c 01       	movw	r10, r24
    1830:	67 2b       	or	r22, r23
    1832:	68 2b       	or	r22, r24
    1834:	69 2b       	or	r22, r25
    1836:	19 f4       	brne	.+6      	; 0x183e <LCD_Write_Integer+0x26>
    1838:	80 e3       	ldi	r24, 0x30	; 48
    183a:	0e 94 b8 0b 	call	0x1770	; 0x1770 <LCD_Write_Char>
    183e:	01 e0       	ldi	r16, 0x01	; 1
    1840:	10 e0       	ldi	r17, 0x00	; 0
    1842:	e1 2c       	mov	r14, r1
    1844:	f1 2c       	mov	r15, r1
    1846:	2f c0       	rjmp	.+94     	; 0x18a6 <LCD_Write_Integer+0x8e>
    1848:	c7 01       	movw	r24, r14
    184a:	88 0f       	add	r24, r24
    184c:	99 1f       	adc	r25, r25
    184e:	b7 01       	movw	r22, r14
    1850:	66 0f       	add	r22, r22
    1852:	77 1f       	adc	r23, r23
    1854:	66 0f       	add	r22, r22
    1856:	77 1f       	adc	r23, r23
    1858:	66 0f       	add	r22, r22
    185a:	77 1f       	adc	r23, r23
    185c:	7c 01       	movw	r14, r24
    185e:	e6 0e       	add	r14, r22
    1860:	f7 1e       	adc	r15, r23
    1862:	c5 01       	movw	r24, r10
    1864:	b4 01       	movw	r22, r8
    1866:	2a e0       	ldi	r18, 0x0A	; 10
    1868:	30 e0       	ldi	r19, 0x00	; 0
    186a:	40 e0       	ldi	r20, 0x00	; 0
    186c:	50 e0       	ldi	r21, 0x00	; 0
    186e:	0e 94 ec 1d 	call	0x3bd8	; 0x3bd8 <__udivmodsi4>
    1872:	e6 0e       	add	r14, r22
    1874:	f7 1e       	adc	r15, r23
    1876:	e1 14       	cp	r14, r1
    1878:	f1 04       	cpc	r15, r1
    187a:	59 f4       	brne	.+22     	; 0x1892 <LCD_Write_Integer+0x7a>
    187c:	c8 01       	movw	r24, r16
    187e:	88 0f       	add	r24, r24
    1880:	99 1f       	adc	r25, r25
    1882:	00 0f       	add	r16, r16
    1884:	11 1f       	adc	r17, r17
    1886:	00 0f       	add	r16, r16
    1888:	11 1f       	adc	r17, r17
    188a:	00 0f       	add	r16, r16
    188c:	11 1f       	adc	r17, r17
    188e:	08 0f       	add	r16, r24
    1890:	19 1f       	adc	r17, r25
    1892:	c5 01       	movw	r24, r10
    1894:	b4 01       	movw	r22, r8
    1896:	2a e0       	ldi	r18, 0x0A	; 10
    1898:	30 e0       	ldi	r19, 0x00	; 0
    189a:	40 e0       	ldi	r20, 0x00	; 0
    189c:	50 e0       	ldi	r21, 0x00	; 0
    189e:	0e 94 ec 1d 	call	0x3bd8	; 0x3bd8 <__udivmodsi4>
    18a2:	49 01       	movw	r8, r18
    18a4:	5a 01       	movw	r10, r20
    18a6:	81 14       	cp	r8, r1
    18a8:	91 04       	cpc	r9, r1
    18aa:	a1 04       	cpc	r10, r1
    18ac:	b1 04       	cpc	r11, r1
    18ae:	61 f6       	brne	.-104    	; 0x1848 <LCD_Write_Integer+0x30>
    18b0:	a1 2c       	mov	r10, r1
    18b2:	b1 2c       	mov	r11, r1
    18b4:	16 c0       	rjmp	.+44     	; 0x18e2 <LCD_Write_Integer+0xca>
    18b6:	c7 01       	movw	r24, r14
    18b8:	6a e0       	ldi	r22, 0x0A	; 10
    18ba:	70 e0       	ldi	r23, 0x00	; 0
    18bc:	0e 94 d8 1d 	call	0x3bb0	; 0x3bb0 <__divmodhi4>
    18c0:	d6 2f       	mov	r29, r22
    18c2:	c7 2f       	mov	r28, r23
    18c4:	80 5d       	subi	r24, 0xD0	; 208
    18c6:	0e 94 b8 0b 	call	0x1770	; 0x1770 <LCD_Write_Char>
    18ca:	ed 2e       	mov	r14, r29
    18cc:	fc 2e       	mov	r15, r28
    18ce:	e1 14       	cp	r14, r1
    18d0:	f1 04       	cpc	r15, r1
    18d2:	39 f4       	brne	.+14     	; 0x18e2 <LCD_Write_Integer+0xca>
    18d4:	0a 30       	cpi	r16, 0x0A	; 10
    18d6:	11 05       	cpc	r17, r1
    18d8:	24 f0       	brlt	.+8      	; 0x18e2 <LCD_Write_Integer+0xca>
    18da:	78 01       	movw	r14, r16
    18dc:	aa 24       	eor	r10, r10
    18de:	a3 94       	inc	r10
    18e0:	b1 2c       	mov	r11, r1
    18e2:	ea 14       	cp	r14, r10
    18e4:	fb 04       	cpc	r15, r11
    18e6:	39 f7       	brne	.-50     	; 0x18b6 <LCD_Write_Integer+0x9e>
    18e8:	df 91       	pop	r29
    18ea:	cf 91       	pop	r28
    18ec:	1f 91       	pop	r17
    18ee:	0f 91       	pop	r16
    18f0:	ff 90       	pop	r15
    18f2:	ef 90       	pop	r14
    18f4:	bf 90       	pop	r11
    18f6:	af 90       	pop	r10
    18f8:	9f 90       	pop	r9
    18fa:	8f 90       	pop	r8
    18fc:	08 95       	ret

000018fe <LCD_Clear>:
    18fe:	81 e0       	ldi	r24, 0x01	; 1
    1900:	0e 94 0c 0b 	call	0x1618	; 0x1618 <LCD_Write_CMD>
    1904:	08 95       	ret

00001906 <LCD_Goto>:
    1906:	cf 93       	push	r28
    1908:	df 93       	push	r29
    190a:	00 d0       	rcall	.+0      	; 0x190c <LCD_Goto+0x6>
    190c:	cd b7       	in	r28, 0x3d	; 61
    190e:	de b7       	in	r29, 0x3e	; 62
    1910:	90 e8       	ldi	r25, 0x80	; 128
    1912:	99 83       	std	Y+1, r25	; 0x01
    1914:	90 ec       	ldi	r25, 0xC0	; 192
    1916:	9a 83       	std	Y+2, r25	; 0x02
    1918:	82 30       	cpi	r24, 0x02	; 2
    191a:	08 f0       	brcs	.+2      	; 0x191e <LCD_Goto+0x18>
    191c:	80 e0       	ldi	r24, 0x00	; 0
    191e:	68 32       	cpi	r22, 0x28	; 40
    1920:	08 f0       	brcs	.+2      	; 0x1924 <LCD_Goto+0x1e>
    1922:	60 e0       	ldi	r22, 0x00	; 0
    1924:	e1 e0       	ldi	r30, 0x01	; 1
    1926:	f0 e0       	ldi	r31, 0x00	; 0
    1928:	ec 0f       	add	r30, r28
    192a:	fd 1f       	adc	r31, r29
    192c:	e8 0f       	add	r30, r24
    192e:	f1 1d       	adc	r31, r1
    1930:	80 81       	ld	r24, Z
    1932:	86 0f       	add	r24, r22
    1934:	0e 94 0c 0b 	call	0x1618	; 0x1618 <LCD_Write_CMD>
    1938:	0f 90       	pop	r0
    193a:	0f 90       	pop	r0
    193c:	df 91       	pop	r29
    193e:	cf 91       	pop	r28
    1940:	08 95       	ret

00001942 <LED0_Init>:
    1942:	41 e0       	ldi	r20, 0x01	; 1
    1944:	62 e0       	ldi	r22, 0x02	; 2
    1946:	82 e0       	ldi	r24, 0x02	; 2
    1948:	0e 94 23 03 	call	0x646	; 0x646 <DIO_SetPin_Dir>
    194c:	41 e0       	ldi	r20, 0x01	; 1
    194e:	62 e0       	ldi	r22, 0x02	; 2
    1950:	82 e0       	ldi	r24, 0x02	; 2
    1952:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    1956:	08 95       	ret

00001958 <LED0_ON>:
    1958:	40 e0       	ldi	r20, 0x00	; 0
    195a:	62 e0       	ldi	r22, 0x02	; 2
    195c:	82 e0       	ldi	r24, 0x02	; 2
    195e:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    1962:	08 95       	ret

00001964 <LED0_OFF>:
    1964:	41 e0       	ldi	r20, 0x01	; 1
    1966:	62 e0       	ldi	r22, 0x02	; 2
    1968:	82 e0       	ldi	r24, 0x02	; 2
    196a:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    196e:	08 95       	ret

00001970 <LED0_Toggle>:
    1970:	62 e0       	ldi	r22, 0x02	; 2
    1972:	82 e0       	ldi	r24, 0x02	; 2
    1974:	0e 94 33 04 	call	0x866	; 0x866 <DIO_TogglePin_Value>
    1978:	08 95       	ret

0000197a <LED1_Init>:
    197a:	41 e0       	ldi	r20, 0x01	; 1
    197c:	63 e0       	ldi	r22, 0x03	; 3
    197e:	82 e0       	ldi	r24, 0x02	; 2
    1980:	0e 94 23 03 	call	0x646	; 0x646 <DIO_SetPin_Dir>
    1984:	41 e0       	ldi	r20, 0x01	; 1
    1986:	63 e0       	ldi	r22, 0x03	; 3
    1988:	82 e0       	ldi	r24, 0x02	; 2
    198a:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    198e:	08 95       	ret

00001990 <LED1_ON>:
    1990:	40 e0       	ldi	r20, 0x00	; 0
    1992:	63 e0       	ldi	r22, 0x03	; 3
    1994:	82 e0       	ldi	r24, 0x02	; 2
    1996:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    199a:	08 95       	ret

0000199c <LED1_OFF>:
    199c:	41 e0       	ldi	r20, 0x01	; 1
    199e:	63 e0       	ldi	r22, 0x03	; 3
    19a0:	82 e0       	ldi	r24, 0x02	; 2
    19a2:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    19a6:	08 95       	ret

000019a8 <LED1_Toggle>:
    19a8:	63 e0       	ldi	r22, 0x03	; 3
    19aa:	82 e0       	ldi	r24, 0x02	; 2
    19ac:	0e 94 33 04 	call	0x866	; 0x866 <DIO_TogglePin_Value>
    19b0:	08 95       	ret

000019b2 <LED2_Init>:
    19b2:	41 e0       	ldi	r20, 0x01	; 1
    19b4:	64 e0       	ldi	r22, 0x04	; 4
    19b6:	82 e0       	ldi	r24, 0x02	; 2
    19b8:	0e 94 23 03 	call	0x646	; 0x646 <DIO_SetPin_Dir>
    19bc:	41 e0       	ldi	r20, 0x01	; 1
    19be:	64 e0       	ldi	r22, 0x04	; 4
    19c0:	82 e0       	ldi	r24, 0x02	; 2
    19c2:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    19c6:	08 95       	ret

000019c8 <LED2_ON>:
    19c8:	40 e0       	ldi	r20, 0x00	; 0
    19ca:	64 e0       	ldi	r22, 0x04	; 4
    19cc:	82 e0       	ldi	r24, 0x02	; 2
    19ce:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    19d2:	08 95       	ret

000019d4 <LED2_OFF>:
    19d4:	41 e0       	ldi	r20, 0x01	; 1
    19d6:	64 e0       	ldi	r22, 0x04	; 4
    19d8:	82 e0       	ldi	r24, 0x02	; 2
    19da:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    19de:	08 95       	ret

000019e0 <LED2_Toggle>:
    19e0:	64 e0       	ldi	r22, 0x04	; 4
    19e2:	82 e0       	ldi	r24, 0x02	; 2
    19e4:	0e 94 33 04 	call	0x866	; 0x866 <DIO_TogglePin_Value>
    19e8:	08 95       	ret

000019ea <LED3_Init>:
    19ea:	41 e0       	ldi	r20, 0x01	; 1
    19ec:	65 e0       	ldi	r22, 0x05	; 5
    19ee:	82 e0       	ldi	r24, 0x02	; 2
    19f0:	0e 94 23 03 	call	0x646	; 0x646 <DIO_SetPin_Dir>
    19f4:	41 e0       	ldi	r20, 0x01	; 1
    19f6:	65 e0       	ldi	r22, 0x05	; 5
    19f8:	82 e0       	ldi	r24, 0x02	; 2
    19fa:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    19fe:	08 95       	ret

00001a00 <LED3_ON>:
    1a00:	40 e0       	ldi	r20, 0x00	; 0
    1a02:	65 e0       	ldi	r22, 0x05	; 5
    1a04:	82 e0       	ldi	r24, 0x02	; 2
    1a06:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    1a0a:	08 95       	ret

00001a0c <LED3_OFF>:
    1a0c:	41 e0       	ldi	r20, 0x01	; 1
    1a0e:	65 e0       	ldi	r22, 0x05	; 5
    1a10:	82 e0       	ldi	r24, 0x02	; 2
    1a12:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    1a16:	08 95       	ret

00001a18 <LED3_Toggle>:
    1a18:	65 e0       	ldi	r22, 0x05	; 5
    1a1a:	82 e0       	ldi	r24, 0x02	; 2
    1a1c:	0e 94 33 04 	call	0x866	; 0x866 <DIO_TogglePin_Value>
    1a20:	08 95       	ret

00001a22 <LED4_Init>:
    1a22:	41 e0       	ldi	r20, 0x01	; 1
    1a24:	66 e0       	ldi	r22, 0x06	; 6
    1a26:	82 e0       	ldi	r24, 0x02	; 2
    1a28:	0e 94 23 03 	call	0x646	; 0x646 <DIO_SetPin_Dir>
    1a2c:	41 e0       	ldi	r20, 0x01	; 1
    1a2e:	66 e0       	ldi	r22, 0x06	; 6
    1a30:	82 e0       	ldi	r24, 0x02	; 2
    1a32:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    1a36:	08 95       	ret

00001a38 <LED4_ON>:
    1a38:	40 e0       	ldi	r20, 0x00	; 0
    1a3a:	66 e0       	ldi	r22, 0x06	; 6
    1a3c:	82 e0       	ldi	r24, 0x02	; 2
    1a3e:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    1a42:	08 95       	ret

00001a44 <LED4_OFF>:
    1a44:	41 e0       	ldi	r20, 0x01	; 1
    1a46:	66 e0       	ldi	r22, 0x06	; 6
    1a48:	82 e0       	ldi	r24, 0x02	; 2
    1a4a:	0e 94 94 03 	call	0x728	; 0x728 <DIO_SetPin_Value>
    1a4e:	08 95       	ret

00001a50 <LED4_Toggle>:
    1a50:	66 e0       	ldi	r22, 0x06	; 6
    1a52:	82 e0       	ldi	r24, 0x02	; 2
    1a54:	0e 94 33 04 	call	0x866	; 0x866 <DIO_TogglePin_Value>
    1a58:	08 95       	ret

00001a5a <main>:
    1a5a:	0e 94 49 00 	call	0x92	; 0x92 <ADC_Init>
    1a5e:	0e 94 b4 00 	call	0x168	; 0x168 <Buzzer_Init>
    1a62:	0e 94 9b 04 	call	0x936	; 0x936 <EEPROM_INIT>
    1a66:	0e 94 dd 04 	call	0x9ba	; 0x9ba <INT0_Init>
    1a6a:	0e 94 94 0a 	call	0x1528	; 0x1528 <Keypad_Init>
    1a6e:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <LCD_Init>
    1a72:	0e 94 a1 0c 	call	0x1942	; 0x1942 <LED0_Init>
    1a76:	0e 94 bd 0c 	call	0x197a	; 0x197a <LED1_Init>
    1a7a:	0e 94 d9 0c 	call	0x19b2	; 0x19b2 <LED2_Init>
    1a7e:	0e 94 f5 0c 	call	0x19ea	; 0x19ea <LED3_Init>
    1a82:	0e 94 11 0d 	call	0x1a22	; 0x1a22 <LED4_Init>
    1a86:	0e 94 cd 0d 	call	0x1b9a	; 0x1b9a <Servo_Init>
    1a8a:	0e 94 d7 0d 	call	0x1bae	; 0x1bae <Timer0_Init>
    1a8e:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <Timer0_Start>
    1a92:	60 e0       	ldi	r22, 0x00	; 0
    1a94:	70 e0       	ldi	r23, 0x00	; 0
    1a96:	cb 01       	movw	r24, r22
    1a98:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <PWM0_Gen>
    1a9c:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <Timer2_Init>
    1aa0:	0e 94 02 10 	call	0x2004	; 0x2004 <UART_Init>
    1aa4:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <DC_Motor1_INIT>
    1aa8:	60 e0       	ldi	r22, 0x00	; 0
    1aaa:	84 e0       	ldi	r24, 0x04	; 4
    1aac:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    1ab0:	8f 3f       	cpi	r24, 0xFF	; 255
    1ab2:	39 f0       	breq	.+14     	; 0x1ac2 <main+0x68>
    1ab4:	60 e0       	ldi	r22, 0x00	; 0
    1ab6:	84 e0       	ldi	r24, 0x04	; 4
    1ab8:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    1abc:	80 93 f1 07 	sts	0x07F1, r24	; 0x8007f1 <KP_Counter>
    1ac0:	02 c0       	rjmp	.+4      	; 0x1ac6 <main+0x6c>
    1ac2:	10 92 f1 07 	sts	0x07F1, r1	; 0x8007f1 <KP_Counter>
    1ac6:	61 e0       	ldi	r22, 0x01	; 1
    1ac8:	84 e0       	ldi	r24, 0x04	; 4
    1aca:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    1ace:	8f 3f       	cpi	r24, 0xFF	; 255
    1ad0:	39 f0       	breq	.+14     	; 0x1ae0 <main+0x86>
    1ad2:	61 e0       	ldi	r22, 0x01	; 1
    1ad4:	84 e0       	ldi	r24, 0x04	; 4
    1ad6:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    1ada:	80 93 f0 07 	sts	0x07F0, r24	; 0x8007f0 <PC_Counter>
    1ade:	02 c0       	rjmp	.+4      	; 0x1ae4 <main+0x8a>
    1ae0:	10 92 f0 07 	sts	0x07F0, r1	; 0x8007f0 <PC_Counter>
    1ae4:	62 e0       	ldi	r22, 0x02	; 2
    1ae6:	84 e0       	ldi	r24, 0x04	; 4
    1ae8:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    1aec:	8f 3f       	cpi	r24, 0xFF	; 255
    1aee:	41 f0       	breq	.+16     	; 0x1b00 <main+0xa6>
    1af0:	62 e0       	ldi	r22, 0x02	; 2
    1af2:	84 e0       	ldi	r24, 0x04	; 4
    1af4:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    1af8:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <AD_Counter>
    1afc:	c1 e0       	ldi	r28, 0x01	; 1
    1afe:	0f c0       	rjmp	.+30     	; 0x1b1e <main+0xc4>
    1b00:	84 e0       	ldi	r24, 0x04	; 4
    1b02:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <AD_Counter>
    1b06:	fa cf       	rjmp	.-12     	; 0x1afc <main+0xa2>
    1b08:	41 e3       	ldi	r20, 0x31	; 49
    1b0a:	6c 2f       	mov	r22, r28
    1b0c:	85 e0       	ldi	r24, 0x05	; 5
    1b0e:	0e 94 9e 04 	call	0x93c	; 0x93c <EEPROM_WriteByte>
    1b12:	41 e3       	ldi	r20, 0x31	; 49
    1b14:	6c 2f       	mov	r22, r28
    1b16:	86 e0       	ldi	r24, 0x06	; 6
    1b18:	0e 94 9e 04 	call	0x93c	; 0x93c <EEPROM_WriteByte>
    1b1c:	cf 5f       	subi	r28, 0xFF	; 255
    1b1e:	c5 30       	cpi	r28, 0x05	; 5
    1b20:	98 f3       	brcs	.-26     	; 0x1b08 <main+0xae>
    1b22:	8a ed       	ldi	r24, 0xDA	; 218
    1b24:	92 e0       	ldi	r25, 0x02	; 2
    1b26:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
    1b2a:	80 e5       	ldi	r24, 0x50	; 80
    1b2c:	92 e0       	ldi	r25, 0x02	; 2
    1b2e:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
    1b32:	8a ed       	ldi	r24, 0xDA	; 218
    1b34:	92 e0       	ldi	r25, 0x02	; 2
    1b36:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
    1b3a:	8c e6       	ldi	r24, 0x6C	; 108
    1b3c:	92 e0       	ldi	r25, 0x02	; 2
    1b3e:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
    1b42:	8c e7       	ldi	r24, 0x7C	; 124
    1b44:	92 e0       	ldi	r25, 0x02	; 2
    1b46:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
    1b4a:	8a ed       	ldi	r24, 0xDA	; 218
    1b4c:	92 e0       	ldi	r25, 0x02	; 2
    1b4e:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
    1b52:	0e 94 3f 0f 	call	0x1e7e	; 0x1e7e <Timer2_Start>
    1b56:	65 e0       	ldi	r22, 0x05	; 5
    1b58:	70 e0       	ldi	r23, 0x00	; 0
    1b5a:	80 e0       	ldi	r24, 0x00	; 0
    1b5c:	90 e0       	ldi	r25, 0x00	; 0
    1b5e:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <Timer2_SetDelay>
    1b62:	87 e0       	ldi	r24, 0x07	; 7
    1b64:	0e 94 63 00 	call	0xc6	; 0xc6 <ADC_Read>
    1b68:	02 c0       	rjmp	.+4      	; 0x1b6e <main+0x114>
    1b6a:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <emergency_case>
    1b6e:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    1b72:	90 91 d2 07 	lds	r25, 0x07D2	; 0x8007d2 <eme_check+0x1>
    1b76:	89 2b       	or	r24, r25
    1b78:	c1 f7       	brne	.-16     	; 0x1b6a <main+0x110>
    1b7a:	f9 cf       	rjmp	.-14     	; 0x1b6e <main+0x114>

00001b7c <Servoo_Motor>:
    1b7c:	1d bc       	out	0x2d, r1	; 45
    1b7e:	1c bc       	out	0x2c, r1	; 44
    1b80:	27 e8       	ldi	r18, 0x87	; 135
    1b82:	33 e1       	ldi	r19, 0x13	; 19
    1b84:	37 bd       	out	0x27, r19	; 39
    1b86:	26 bd       	out	0x26, r18	; 38
    1b88:	7b bd       	out	0x2b, r23	; 43
    1b8a:	6a bd       	out	0x2a, r22	; 42
    1b8c:	8f b5       	in	r24, 0x2f	; 47
    1b8e:	82 6a       	ori	r24, 0xA2	; 162
    1b90:	8f bd       	out	0x2f, r24	; 47
    1b92:	8e b5       	in	r24, 0x2e	; 46
    1b94:	8b 61       	ori	r24, 0x1B	; 27
    1b96:	8e bd       	out	0x2e, r24	; 46
    1b98:	08 95       	ret

00001b9a <Servo_Init>:
    1b9a:	81 b3       	in	r24, 0x11	; 17
    1b9c:	80 62       	ori	r24, 0x20	; 32
    1b9e:	81 bb       	out	0x11, r24	; 17
    1ba0:	61 e6       	ldi	r22, 0x61	; 97
    1ba2:	70 e0       	ldi	r23, 0x00	; 0
    1ba4:	80 e0       	ldi	r24, 0x00	; 0
    1ba6:	90 e0       	ldi	r25, 0x00	; 0
    1ba8:	0e 94 be 0d 	call	0x1b7c	; 0x1b7c <Servoo_Motor>
    1bac:	08 95       	ret

00001bae <Timer0_Init>:
    1bae:	8f b7       	in	r24, 0x3f	; 63
    1bb0:	80 68       	ori	r24, 0x80	; 128
    1bb2:	8f bf       	out	0x3f, r24	; 63
    1bb4:	83 b7       	in	r24, 0x33	; 51
    1bb6:	88 60       	ori	r24, 0x08	; 8
    1bb8:	83 bf       	out	0x33, r24	; 51
    1bba:	83 b7       	in	r24, 0x33	; 51
    1bbc:	80 64       	ori	r24, 0x40	; 64
    1bbe:	83 bf       	out	0x33, r24	; 51
    1bc0:	83 b7       	in	r24, 0x33	; 51
    1bc2:	8f 7c       	andi	r24, 0xCF	; 207
    1bc4:	80 62       	ori	r24, 0x20	; 32
    1bc6:	83 bf       	out	0x33, r24	; 51
    1bc8:	89 b7       	in	r24, 0x39	; 57
    1bca:	81 60       	ori	r24, 0x01	; 1
    1bcc:	89 bf       	out	0x39, r24	; 57
    1bce:	41 e0       	ldi	r20, 0x01	; 1
    1bd0:	63 e0       	ldi	r22, 0x03	; 3
    1bd2:	81 e0       	ldi	r24, 0x01	; 1
    1bd4:	0e 94 23 03 	call	0x646	; 0x646 <DIO_SetPin_Dir>
    1bd8:	08 95       	ret

00001bda <PWM0_Gen>:
    1bda:	cf 92       	push	r12
    1bdc:	df 92       	push	r13
    1bde:	ef 92       	push	r14
    1be0:	ff 92       	push	r15
    1be2:	6b 01       	movw	r12, r22
    1be4:	7c 01       	movw	r14, r24
    1be6:	20 e0       	ldi	r18, 0x00	; 0
    1be8:	30 e0       	ldi	r19, 0x00	; 0
    1bea:	a9 01       	movw	r20, r18
    1bec:	0e 94 0e 1c 	call	0x381c	; 0x381c <__cmpsf2>
    1bf0:	88 23       	and	r24, r24
    1bf2:	5c f0       	brlt	.+22     	; 0x1c0a <PWM0_Gen+0x30>
    1bf4:	20 e0       	ldi	r18, 0x00	; 0
    1bf6:	30 e0       	ldi	r19, 0x00	; 0
    1bf8:	48 ec       	ldi	r20, 0xC8	; 200
    1bfa:	52 e4       	ldi	r21, 0x42	; 66
    1bfc:	c7 01       	movw	r24, r14
    1bfe:	b6 01       	movw	r22, r12
    1c00:	0e 94 66 1d 	call	0x3acc	; 0x3acc <__gesf2>
    1c04:	18 16       	cp	r1, r24
    1c06:	2c f0       	brlt	.+10     	; 0x1c12 <PWM0_Gen+0x38>
    1c08:	0c c0       	rjmp	.+24     	; 0x1c22 <PWM0_Gen+0x48>
    1c0a:	c1 2c       	mov	r12, r1
    1c0c:	d1 2c       	mov	r13, r1
    1c0e:	76 01       	movw	r14, r12
    1c10:	08 c0       	rjmp	.+16     	; 0x1c22 <PWM0_Gen+0x48>
    1c12:	0f 2e       	mov	r0, r31
    1c14:	c1 2c       	mov	r12, r1
    1c16:	d1 2c       	mov	r13, r1
    1c18:	f8 ec       	ldi	r31, 0xC8	; 200
    1c1a:	ef 2e       	mov	r14, r31
    1c1c:	f2 e4       	ldi	r31, 0x42	; 66
    1c1e:	ff 2e       	mov	r15, r31
    1c20:	f0 2d       	mov	r31, r0
    1c22:	20 e0       	ldi	r18, 0x00	; 0
    1c24:	30 e0       	ldi	r19, 0x00	; 0
    1c26:	a9 01       	movw	r20, r18
    1c28:	c7 01       	movw	r24, r14
    1c2a:	b6 01       	movw	r22, r12
    1c2c:	0e 94 0e 1c 	call	0x381c	; 0x381c <__cmpsf2>
    1c30:	88 23       	and	r24, r24
    1c32:	b9 f0       	breq	.+46     	; 0x1c62 <PWM0_Gen+0x88>
    1c34:	20 e0       	ldi	r18, 0x00	; 0
    1c36:	30 e0       	ldi	r19, 0x00	; 0
    1c38:	48 ec       	ldi	r20, 0xC8	; 200
    1c3a:	52 e4       	ldi	r21, 0x42	; 66
    1c3c:	c7 01       	movw	r24, r14
    1c3e:	b6 01       	movw	r22, r12
    1c40:	0e 94 13 1c 	call	0x3826	; 0x3826 <__divsf3>
    1c44:	20 e0       	ldi	r18, 0x00	; 0
    1c46:	30 e0       	ldi	r19, 0x00	; 0
    1c48:	40 e8       	ldi	r20, 0x80	; 128
    1c4a:	53 e4       	ldi	r21, 0x43	; 67
    1c4c:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <__mulsf3>
    1c50:	20 e0       	ldi	r18, 0x00	; 0
    1c52:	30 e0       	ldi	r19, 0x00	; 0
    1c54:	40 e8       	ldi	r20, 0x80	; 128
    1c56:	5f e3       	ldi	r21, 0x3F	; 63
    1c58:	0e 94 a1 1b 	call	0x3742	; 0x3742 <__subsf3>
    1c5c:	0e 94 85 1c 	call	0x390a	; 0x390a <__fixunssfsi>
    1c60:	01 c0       	rjmp	.+2      	; 0x1c64 <PWM0_Gen+0x8a>
    1c62:	60 e0       	ldi	r22, 0x00	; 0
    1c64:	6c bf       	out	0x3c, r22	; 60
    1c66:	ff 90       	pop	r15
    1c68:	ef 90       	pop	r14
    1c6a:	df 90       	pop	r13
    1c6c:	cf 90       	pop	r12
    1c6e:	08 95       	ret

00001c70 <Timer0_Start>:
    1c70:	83 b7       	in	r24, 0x33	; 51
    1c72:	88 7f       	andi	r24, 0xF8	; 248
    1c74:	85 60       	ori	r24, 0x05	; 5
    1c76:	83 bf       	out	0x33, r24	; 51
    1c78:	08 95       	ret

00001c7a <__vector_11>:
    1c7a:	1f 92       	push	r1
    1c7c:	0f 92       	push	r0
    1c7e:	0f b6       	in	r0, 0x3f	; 63
    1c80:	0f 92       	push	r0
    1c82:	11 24       	eor	r1, r1
    1c84:	4f 93       	push	r20
    1c86:	5f 93       	push	r21
    1c88:	6f 93       	push	r22
    1c8a:	7f 93       	push	r23
    1c8c:	8f 93       	push	r24
    1c8e:	9f 93       	push	r25
    1c90:	af 93       	push	r26
    1c92:	bf 93       	push	r27
    1c94:	80 91 df 07 	lds	r24, 0x07DF	; 0x8007df <Count.1709>
    1c98:	90 91 e0 07 	lds	r25, 0x07E0	; 0x8007e0 <Count.1709+0x1>
    1c9c:	a0 91 e1 07 	lds	r26, 0x07E1	; 0x8007e1 <Count.1709+0x2>
    1ca0:	b0 91 e2 07 	lds	r27, 0x07E2	; 0x8007e2 <Count.1709+0x3>
    1ca4:	01 96       	adiw	r24, 0x01	; 1
    1ca6:	a1 1d       	adc	r26, r1
    1ca8:	b1 1d       	adc	r27, r1
    1caa:	80 93 df 07 	sts	0x07DF, r24	; 0x8007df <Count.1709>
    1cae:	90 93 e0 07 	sts	0x07E0, r25	; 0x8007e0 <Count.1709+0x1>
    1cb2:	a0 93 e1 07 	sts	0x07E1, r26	; 0x8007e1 <Count.1709+0x2>
    1cb6:	b0 93 e2 07 	sts	0x07E2, r27	; 0x8007e2 <Count.1709+0x3>
    1cba:	40 91 e7 07 	lds	r20, 0x07E7	; 0x8007e7 <Timer0_Num_OVF>
    1cbe:	50 91 e8 07 	lds	r21, 0x07E8	; 0x8007e8 <Timer0_Num_OVF+0x1>
    1cc2:	60 e0       	ldi	r22, 0x00	; 0
    1cc4:	70 e0       	ldi	r23, 0x00	; 0
    1cc6:	84 17       	cp	r24, r20
    1cc8:	95 07       	cpc	r25, r21
    1cca:	a6 07       	cpc	r26, r22
    1ccc:	b7 07       	cpc	r27, r23
    1cce:	59 f4       	brne	.+22     	; 0x1ce6 <__vector_11+0x6c>
    1cd0:	10 92 df 07 	sts	0x07DF, r1	; 0x8007df <Count.1709>
    1cd4:	10 92 e0 07 	sts	0x07E0, r1	; 0x8007e0 <Count.1709+0x1>
    1cd8:	10 92 e1 07 	sts	0x07E1, r1	; 0x8007e1 <Count.1709+0x2>
    1cdc:	10 92 e2 07 	sts	0x07E2, r1	; 0x8007e2 <Count.1709+0x3>
    1ce0:	80 91 e6 07 	lds	r24, 0x07E6	; 0x8007e6 <Timer0_Init_Value>
    1ce4:	82 bf       	out	0x32, r24	; 50
    1ce6:	bf 91       	pop	r27
    1ce8:	af 91       	pop	r26
    1cea:	9f 91       	pop	r25
    1cec:	8f 91       	pop	r24
    1cee:	7f 91       	pop	r23
    1cf0:	6f 91       	pop	r22
    1cf2:	5f 91       	pop	r21
    1cf4:	4f 91       	pop	r20
    1cf6:	0f 90       	pop	r0
    1cf8:	0f be       	out	0x3f, r0	; 63
    1cfa:	0f 90       	pop	r0
    1cfc:	1f 90       	pop	r1
    1cfe:	18 95       	reti

00001d00 <__vector_10>:
    1d00:	1f 92       	push	r1
    1d02:	0f 92       	push	r0
    1d04:	0f b6       	in	r0, 0x3f	; 63
    1d06:	0f 92       	push	r0
    1d08:	11 24       	eor	r1, r1
    1d0a:	4f 93       	push	r20
    1d0c:	5f 93       	push	r21
    1d0e:	6f 93       	push	r22
    1d10:	7f 93       	push	r23
    1d12:	8f 93       	push	r24
    1d14:	9f 93       	push	r25
    1d16:	af 93       	push	r26
    1d18:	bf 93       	push	r27
    1d1a:	80 91 db 07 	lds	r24, 0x07DB	; 0x8007db <Count.1715>
    1d1e:	90 91 dc 07 	lds	r25, 0x07DC	; 0x8007dc <Count.1715+0x1>
    1d22:	a0 91 dd 07 	lds	r26, 0x07DD	; 0x8007dd <Count.1715+0x2>
    1d26:	b0 91 de 07 	lds	r27, 0x07DE	; 0x8007de <Count.1715+0x3>
    1d2a:	01 96       	adiw	r24, 0x01	; 1
    1d2c:	a1 1d       	adc	r26, r1
    1d2e:	b1 1d       	adc	r27, r1
    1d30:	80 93 db 07 	sts	0x07DB, r24	; 0x8007db <Count.1715>
    1d34:	90 93 dc 07 	sts	0x07DC, r25	; 0x8007dc <Count.1715+0x1>
    1d38:	a0 93 dd 07 	sts	0x07DD, r26	; 0x8007dd <Count.1715+0x2>
    1d3c:	b0 93 de 07 	sts	0x07DE, r27	; 0x8007de <Count.1715+0x3>
    1d40:	81 30       	cpi	r24, 0x01	; 1
    1d42:	91 05       	cpc	r25, r1
    1d44:	a1 05       	cpc	r26, r1
    1d46:	b1 05       	cpc	r27, r1
    1d48:	b9 f4       	brne	.+46     	; 0x1d78 <__vector_10+0x78>
    1d4a:	40 91 e7 07 	lds	r20, 0x07E7	; 0x8007e7 <Timer0_Num_OVF>
    1d4e:	50 91 e8 07 	lds	r21, 0x07E8	; 0x8007e8 <Timer0_Num_OVF+0x1>
    1d52:	60 e0       	ldi	r22, 0x00	; 0
    1d54:	70 e0       	ldi	r23, 0x00	; 0
    1d56:	84 17       	cp	r24, r20
    1d58:	95 07       	cpc	r25, r21
    1d5a:	a6 07       	cpc	r26, r22
    1d5c:	b7 07       	cpc	r27, r23
    1d5e:	61 f4       	brne	.+24     	; 0x1d78 <__vector_10+0x78>
    1d60:	10 92 db 07 	sts	0x07DB, r1	; 0x8007db <Count.1715>
    1d64:	10 92 dc 07 	sts	0x07DC, r1	; 0x8007dc <Count.1715+0x1>
    1d68:	10 92 dd 07 	sts	0x07DD, r1	; 0x8007dd <Count.1715+0x2>
    1d6c:	10 92 de 07 	sts	0x07DE, r1	; 0x8007de <Count.1715+0x3>
    1d70:	80 91 e6 07 	lds	r24, 0x07E6	; 0x8007e6 <Timer0_Init_Value>
    1d74:	8c bf       	out	0x3c, r24	; 60
    1d76:	1e c0       	rjmp	.+60     	; 0x1db4 <__vector_10+0xb4>
    1d78:	81 30       	cpi	r24, 0x01	; 1
    1d7a:	91 05       	cpc	r25, r1
    1d7c:	a1 05       	cpc	r26, r1
    1d7e:	b1 05       	cpc	r27, r1
    1d80:	19 f4       	brne	.+6      	; 0x1d88 <__vector_10+0x88>
    1d82:	8f ef       	ldi	r24, 0xFF	; 255
    1d84:	8c bf       	out	0x3c, r24	; 60
    1d86:	16 c0       	rjmp	.+44     	; 0x1db4 <__vector_10+0xb4>
    1d88:	40 91 e7 07 	lds	r20, 0x07E7	; 0x8007e7 <Timer0_Num_OVF>
    1d8c:	50 91 e8 07 	lds	r21, 0x07E8	; 0x8007e8 <Timer0_Num_OVF+0x1>
    1d90:	60 e0       	ldi	r22, 0x00	; 0
    1d92:	70 e0       	ldi	r23, 0x00	; 0
    1d94:	84 17       	cp	r24, r20
    1d96:	95 07       	cpc	r25, r21
    1d98:	a6 07       	cpc	r26, r22
    1d9a:	b7 07       	cpc	r27, r23
    1d9c:	59 f4       	brne	.+22     	; 0x1db4 <__vector_10+0xb4>
    1d9e:	10 92 db 07 	sts	0x07DB, r1	; 0x8007db <Count.1715>
    1da2:	10 92 dc 07 	sts	0x07DC, r1	; 0x8007dc <Count.1715+0x1>
    1da6:	10 92 dd 07 	sts	0x07DD, r1	; 0x8007dd <Count.1715+0x2>
    1daa:	10 92 de 07 	sts	0x07DE, r1	; 0x8007de <Count.1715+0x3>
    1dae:	80 91 e6 07 	lds	r24, 0x07E6	; 0x8007e6 <Timer0_Init_Value>
    1db2:	8c bf       	out	0x3c, r24	; 60
    1db4:	bf 91       	pop	r27
    1db6:	af 91       	pop	r26
    1db8:	9f 91       	pop	r25
    1dba:	8f 91       	pop	r24
    1dbc:	7f 91       	pop	r23
    1dbe:	6f 91       	pop	r22
    1dc0:	5f 91       	pop	r21
    1dc2:	4f 91       	pop	r20
    1dc4:	0f 90       	pop	r0
    1dc6:	0f be       	out	0x3f, r0	; 63
    1dc8:	0f 90       	pop	r0
    1dca:	1f 90       	pop	r1
    1dcc:	18 95       	reti

00001dce <Timer2_Init>:
    1dce:	8f b7       	in	r24, 0x3f	; 63
    1dd0:	80 68       	ori	r24, 0x80	; 128
    1dd2:	8f bf       	out	0x3f, r24	; 63
    1dd4:	85 b5       	in	r24, 0x25	; 37
    1dd6:	87 7f       	andi	r24, 0xF7	; 247
    1dd8:	85 bd       	out	0x25, r24	; 37
    1dda:	85 b5       	in	r24, 0x25	; 37
    1ddc:	8f 7b       	andi	r24, 0xBF	; 191
    1dde:	85 bd       	out	0x25, r24	; 37
    1de0:	89 b7       	in	r24, 0x39	; 57
    1de2:	80 64       	ori	r24, 0x40	; 64
    1de4:	89 bf       	out	0x39, r24	; 57
    1de6:	08 95       	ret

00001de8 <Timer2_SetDelay>:
    1de8:	0f 93       	push	r16
    1dea:	1f 93       	push	r17
    1dec:	9b 01       	movw	r18, r22
    1dee:	ac 01       	movw	r20, r24
    1df0:	a8 ee       	ldi	r26, 0xE8	; 232
    1df2:	b3 e0       	ldi	r27, 0x03	; 3
    1df4:	0e 94 0e 1e 	call	0x3c1c	; 0x3c1c <__muluhisi3>
    1df8:	8b 01       	movw	r16, r22
    1dfa:	9c 01       	movw	r18, r24
    1dfc:	68 94       	set
    1dfe:	15 f8       	bld	r1, 5
    1e00:	36 95       	lsr	r19
    1e02:	27 95       	ror	r18
    1e04:	17 95       	ror	r17
    1e06:	07 95       	ror	r16
    1e08:	16 94       	lsr	r1
    1e0a:	d1 f7       	brne	.-12     	; 0x1e00 <Timer2_SetDelay+0x18>
    1e0c:	01 30       	cpi	r16, 0x01	; 1
    1e0e:	41 e0       	ldi	r20, 0x01	; 1
    1e10:	14 07       	cpc	r17, r20
    1e12:	21 05       	cpc	r18, r1
    1e14:	31 05       	cpc	r19, r1
    1e16:	60 f4       	brcc	.+24     	; 0x1e30 <Timer2_SetDelay+0x48>
    1e18:	80 2f       	mov	r24, r16
    1e1a:	81 95       	neg	r24
    1e1c:	80 93 e3 07 	sts	0x07E3, r24	; 0x8007e3 <Timer2_Init_Value>
    1e20:	84 bd       	out	0x24, r24	; 36
    1e22:	81 e0       	ldi	r24, 0x01	; 1
    1e24:	90 e0       	ldi	r25, 0x00	; 0
    1e26:	90 93 e5 07 	sts	0x07E5, r25	; 0x8007e5 <Timer2_Num_OVF+0x1>
    1e2a:	80 93 e4 07 	sts	0x07E4, r24	; 0x8007e4 <Timer2_Num_OVF>
    1e2e:	24 c0       	rjmp	.+72     	; 0x1e78 <Timer2_SetDelay+0x90>
    1e30:	01 11       	cpse	r16, r1
    1e32:	0c c0       	rjmp	.+24     	; 0x1e4c <Timer2_SetDelay+0x64>
    1e34:	ab 01       	movw	r20, r22
    1e36:	bc 01       	movw	r22, r24
    1e38:	03 2e       	mov	r0, r19
    1e3a:	3e e0       	ldi	r19, 0x0E	; 14
    1e3c:	76 95       	lsr	r23
    1e3e:	67 95       	ror	r22
    1e40:	57 95       	ror	r21
    1e42:	47 95       	ror	r20
    1e44:	3a 95       	dec	r19
    1e46:	d1 f7       	brne	.-12     	; 0x1e3c <Timer2_SetDelay+0x54>
    1e48:	30 2d       	mov	r19, r0
    1e4a:	0d c0       	rjmp	.+26     	; 0x1e66 <Timer2_SetDelay+0x7e>
    1e4c:	ab 01       	movw	r20, r22
    1e4e:	bc 01       	movw	r22, r24
    1e50:	03 2e       	mov	r0, r19
    1e52:	3e e0       	ldi	r19, 0x0E	; 14
    1e54:	76 95       	lsr	r23
    1e56:	67 95       	ror	r22
    1e58:	57 95       	ror	r21
    1e5a:	47 95       	ror	r20
    1e5c:	3a 95       	dec	r19
    1e5e:	d1 f7       	brne	.-12     	; 0x1e54 <Timer2_SetDelay+0x6c>
    1e60:	30 2d       	mov	r19, r0
    1e62:	4f 5f       	subi	r20, 0xFF	; 255
    1e64:	5f 4f       	sbci	r21, 0xFF	; 255
    1e66:	50 93 e5 07 	sts	0x07E5, r21	; 0x8007e5 <Timer2_Num_OVF+0x1>
    1e6a:	40 93 e4 07 	sts	0x07E4, r20	; 0x8007e4 <Timer2_Num_OVF>
    1e6e:	80 2f       	mov	r24, r16
    1e70:	81 95       	neg	r24
    1e72:	80 93 e3 07 	sts	0x07E3, r24	; 0x8007e3 <Timer2_Init_Value>
    1e76:	84 bd       	out	0x24, r24	; 36
    1e78:	1f 91       	pop	r17
    1e7a:	0f 91       	pop	r16
    1e7c:	08 95       	ret

00001e7e <Timer2_Start>:
    1e7e:	85 b5       	in	r24, 0x25	; 37
    1e80:	87 60       	ori	r24, 0x07	; 7
    1e82:	85 bd       	out	0x25, r24	; 37
    1e84:	08 95       	ret

00001e86 <Timer2_Stop>:
    1e86:	85 b5       	in	r24, 0x25	; 37
    1e88:	88 7f       	andi	r24, 0xF8	; 248
    1e8a:	85 bd       	out	0x25, r24	; 37
    1e8c:	08 95       	ret

00001e8e <__vector_5>:
    1e8e:	1f 92       	push	r1
    1e90:	0f 92       	push	r0
    1e92:	0f b6       	in	r0, 0x3f	; 63
    1e94:	0f 92       	push	r0
    1e96:	11 24       	eor	r1, r1
    1e98:	2f 93       	push	r18
    1e9a:	3f 93       	push	r19
    1e9c:	4f 93       	push	r20
    1e9e:	5f 93       	push	r21
    1ea0:	6f 93       	push	r22
    1ea2:	7f 93       	push	r23
    1ea4:	8f 93       	push	r24
    1ea6:	9f 93       	push	r25
    1ea8:	af 93       	push	r26
    1eaa:	bf 93       	push	r27
    1eac:	ef 93       	push	r30
    1eae:	ff 93       	push	r31
    1eb0:	80 91 d7 07 	lds	r24, 0x07D7	; 0x8007d7 <Count.1759>
    1eb4:	90 91 d8 07 	lds	r25, 0x07D8	; 0x8007d8 <Count.1759+0x1>
    1eb8:	a0 91 d9 07 	lds	r26, 0x07D9	; 0x8007d9 <Count.1759+0x2>
    1ebc:	b0 91 da 07 	lds	r27, 0x07DA	; 0x8007da <Count.1759+0x3>
    1ec0:	01 96       	adiw	r24, 0x01	; 1
    1ec2:	a1 1d       	adc	r26, r1
    1ec4:	b1 1d       	adc	r27, r1
    1ec6:	80 93 d7 07 	sts	0x07D7, r24	; 0x8007d7 <Count.1759>
    1eca:	90 93 d8 07 	sts	0x07D8, r25	; 0x8007d8 <Count.1759+0x1>
    1ece:	a0 93 d9 07 	sts	0x07D9, r26	; 0x8007d9 <Count.1759+0x2>
    1ed2:	b0 93 da 07 	sts	0x07DA, r27	; 0x8007da <Count.1759+0x3>
    1ed6:	40 91 e4 07 	lds	r20, 0x07E4	; 0x8007e4 <Timer2_Num_OVF>
    1eda:	50 91 e5 07 	lds	r21, 0x07E5	; 0x8007e5 <Timer2_Num_OVF+0x1>
    1ede:	60 e0       	ldi	r22, 0x00	; 0
    1ee0:	70 e0       	ldi	r23, 0x00	; 0
    1ee2:	84 17       	cp	r24, r20
    1ee4:	95 07       	cpc	r25, r21
    1ee6:	a6 07       	cpc	r26, r22
    1ee8:	b7 07       	cpc	r27, r23
    1eea:	a1 f4       	brne	.+40     	; 0x1f14 <__vector_5+0x86>
    1eec:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    1ef0:	81 11       	cpse	r24, r1
    1ef2:	03 c0       	rjmp	.+6      	; 0x1efa <__vector_5+0x6c>
    1ef4:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
    1ef8:	02 c0       	rjmp	.+4      	; 0x1efe <__vector_5+0x70>
    1efa:	0e 94 43 0f 	call	0x1e86	; 0x1e86 <Timer2_Stop>
    1efe:	10 92 d7 07 	sts	0x07D7, r1	; 0x8007d7 <Count.1759>
    1f02:	10 92 d8 07 	sts	0x07D8, r1	; 0x8007d8 <Count.1759+0x1>
    1f06:	10 92 d9 07 	sts	0x07D9, r1	; 0x8007d9 <Count.1759+0x2>
    1f0a:	10 92 da 07 	sts	0x07DA, r1	; 0x8007da <Count.1759+0x3>
    1f0e:	80 91 e3 07 	lds	r24, 0x07E3	; 0x8007e3 <Timer2_Init_Value>
    1f12:	84 bd       	out	0x24, r24	; 36
    1f14:	ff 91       	pop	r31
    1f16:	ef 91       	pop	r30
    1f18:	bf 91       	pop	r27
    1f1a:	af 91       	pop	r26
    1f1c:	9f 91       	pop	r25
    1f1e:	8f 91       	pop	r24
    1f20:	7f 91       	pop	r23
    1f22:	6f 91       	pop	r22
    1f24:	5f 91       	pop	r21
    1f26:	4f 91       	pop	r20
    1f28:	3f 91       	pop	r19
    1f2a:	2f 91       	pop	r18
    1f2c:	0f 90       	pop	r0
    1f2e:	0f be       	out	0x3f, r0	; 63
    1f30:	0f 90       	pop	r0
    1f32:	1f 90       	pop	r1
    1f34:	18 95       	reti

00001f36 <__vector_4>:
    1f36:	1f 92       	push	r1
    1f38:	0f 92       	push	r0
    1f3a:	0f b6       	in	r0, 0x3f	; 63
    1f3c:	0f 92       	push	r0
    1f3e:	11 24       	eor	r1, r1
    1f40:	4f 93       	push	r20
    1f42:	5f 93       	push	r21
    1f44:	6f 93       	push	r22
    1f46:	7f 93       	push	r23
    1f48:	8f 93       	push	r24
    1f4a:	9f 93       	push	r25
    1f4c:	af 93       	push	r26
    1f4e:	bf 93       	push	r27
    1f50:	80 91 d3 07 	lds	r24, 0x07D3	; 0x8007d3 <Count.1765>
    1f54:	90 91 d4 07 	lds	r25, 0x07D4	; 0x8007d4 <Count.1765+0x1>
    1f58:	a0 91 d5 07 	lds	r26, 0x07D5	; 0x8007d5 <Count.1765+0x2>
    1f5c:	b0 91 d6 07 	lds	r27, 0x07D6	; 0x8007d6 <Count.1765+0x3>
    1f60:	01 96       	adiw	r24, 0x01	; 1
    1f62:	a1 1d       	adc	r26, r1
    1f64:	b1 1d       	adc	r27, r1
    1f66:	80 93 d3 07 	sts	0x07D3, r24	; 0x8007d3 <Count.1765>
    1f6a:	90 93 d4 07 	sts	0x07D4, r25	; 0x8007d4 <Count.1765+0x1>
    1f6e:	a0 93 d5 07 	sts	0x07D5, r26	; 0x8007d5 <Count.1765+0x2>
    1f72:	b0 93 d6 07 	sts	0x07D6, r27	; 0x8007d6 <Count.1765+0x3>
    1f76:	81 30       	cpi	r24, 0x01	; 1
    1f78:	91 05       	cpc	r25, r1
    1f7a:	a1 05       	cpc	r26, r1
    1f7c:	b1 05       	cpc	r27, r1
    1f7e:	b9 f4       	brne	.+46     	; 0x1fae <__vector_4+0x78>
    1f80:	40 91 e4 07 	lds	r20, 0x07E4	; 0x8007e4 <Timer2_Num_OVF>
    1f84:	50 91 e5 07 	lds	r21, 0x07E5	; 0x8007e5 <Timer2_Num_OVF+0x1>
    1f88:	60 e0       	ldi	r22, 0x00	; 0
    1f8a:	70 e0       	ldi	r23, 0x00	; 0
    1f8c:	84 17       	cp	r24, r20
    1f8e:	95 07       	cpc	r25, r21
    1f90:	a6 07       	cpc	r26, r22
    1f92:	b7 07       	cpc	r27, r23
    1f94:	61 f4       	brne	.+24     	; 0x1fae <__vector_4+0x78>
    1f96:	10 92 d3 07 	sts	0x07D3, r1	; 0x8007d3 <Count.1765>
    1f9a:	10 92 d4 07 	sts	0x07D4, r1	; 0x8007d4 <Count.1765+0x1>
    1f9e:	10 92 d5 07 	sts	0x07D5, r1	; 0x8007d5 <Count.1765+0x2>
    1fa2:	10 92 d6 07 	sts	0x07D6, r1	; 0x8007d6 <Count.1765+0x3>
    1fa6:	80 91 e3 07 	lds	r24, 0x07E3	; 0x8007e3 <Timer2_Init_Value>
    1faa:	83 bd       	out	0x23, r24	; 35
    1fac:	1e c0       	rjmp	.+60     	; 0x1fea <__vector_4+0xb4>
    1fae:	81 30       	cpi	r24, 0x01	; 1
    1fb0:	91 05       	cpc	r25, r1
    1fb2:	a1 05       	cpc	r26, r1
    1fb4:	b1 05       	cpc	r27, r1
    1fb6:	19 f4       	brne	.+6      	; 0x1fbe <__vector_4+0x88>
    1fb8:	8f ef       	ldi	r24, 0xFF	; 255
    1fba:	83 bd       	out	0x23, r24	; 35
    1fbc:	16 c0       	rjmp	.+44     	; 0x1fea <__vector_4+0xb4>
    1fbe:	40 91 e4 07 	lds	r20, 0x07E4	; 0x8007e4 <Timer2_Num_OVF>
    1fc2:	50 91 e5 07 	lds	r21, 0x07E5	; 0x8007e5 <Timer2_Num_OVF+0x1>
    1fc6:	60 e0       	ldi	r22, 0x00	; 0
    1fc8:	70 e0       	ldi	r23, 0x00	; 0
    1fca:	84 17       	cp	r24, r20
    1fcc:	95 07       	cpc	r25, r21
    1fce:	a6 07       	cpc	r26, r22
    1fd0:	b7 07       	cpc	r27, r23
    1fd2:	59 f4       	brne	.+22     	; 0x1fea <__vector_4+0xb4>
    1fd4:	10 92 d3 07 	sts	0x07D3, r1	; 0x8007d3 <Count.1765>
    1fd8:	10 92 d4 07 	sts	0x07D4, r1	; 0x8007d4 <Count.1765+0x1>
    1fdc:	10 92 d5 07 	sts	0x07D5, r1	; 0x8007d5 <Count.1765+0x2>
    1fe0:	10 92 d6 07 	sts	0x07D6, r1	; 0x8007d6 <Count.1765+0x3>
    1fe4:	80 91 e3 07 	lds	r24, 0x07E3	; 0x8007e3 <Timer2_Init_Value>
    1fe8:	83 bd       	out	0x23, r24	; 35
    1fea:	bf 91       	pop	r27
    1fec:	af 91       	pop	r26
    1fee:	9f 91       	pop	r25
    1ff0:	8f 91       	pop	r24
    1ff2:	7f 91       	pop	r23
    1ff4:	6f 91       	pop	r22
    1ff6:	5f 91       	pop	r21
    1ff8:	4f 91       	pop	r20
    1ffa:	0f 90       	pop	r0
    1ffc:	0f be       	out	0x3f, r0	; 63
    1ffe:	0f 90       	pop	r0
    2000:	1f 90       	pop	r1
    2002:	18 95       	reti

00002004 <UART_Init>:
Uint8 Temp_Display = 0;
Uint8 First_Check = 0;

void UART_Init(void) {
        // Global Interrupt
        SREG |= Global_INT << 7;
    2004:	8f b7       	in	r24, 0x3f	; 63
    2006:	80 68       	ori	r24, 0x80	; 128
    2008:	8f bf       	out	0x3f, r24	; 63

        // Peripheral Interrupt
        UCSRB = (UART_TX_INT << 6) | (UART_RX_INT << 7) | (UCSRB & 0X3F);
    200a:	8a b1       	in	r24, 0x0a	; 10
    200c:	80 6c       	ori	r24, 0xC0	; 192
    200e:	8a b9       	out	0x0a, r24	; 10

        // TX Pin Direction
        DIO_SetPin_Dir(DIO_PORTD, PIN_1, PIN_OUT);
    2010:	41 e0       	ldi	r20, 0x01	; 1
    2012:	61 e0       	ldi	r22, 0x01	; 1
    2014:	83 e0       	ldi	r24, 0x03	; 3
    2016:	0e 94 23 03 	call	0x646	; 0x646 <DIO_SetPin_Dir>

        // RX Pin Direction
        DIO_SetPin_Dir(DIO_PORTD, PIN_0, PIN_IN);
    201a:	40 e0       	ldi	r20, 0x00	; 0
    201c:	60 e0       	ldi	r22, 0x00	; 0
    201e:	83 e0       	ldi	r24, 0x03	; 3
    2020:	0e 94 23 03 	call	0x646	; 0x646 <DIO_SetPin_Dir>

        // UART Receiver/ Transmitter Enable
        UCSRB = (1 << 3) | (1 << 4) | (UCSRB & 0XE7);
    2024:	8a b1       	in	r24, 0x0a	; 10
    2026:	88 61       	ori	r24, 0x18	; 24
    2028:	8a b9       	out	0x0a, r24	; 10

        // UART Doubled Speed Mode
        UCSRA = (UART_Doubled_Speed << 1) | (UCSRA & 0XFD);
    202a:	8b b1       	in	r24, 0x0b	; 11
    202c:	82 60       	ori	r24, 0x02	; 2
    202e:	8b b9       	out	0x0b, r24	; 11

        // Parity Bit Mode
        // Data Bits Mode
        // Stop Bit  Mode
        UCSRC = (1 << 7) | (UART_Data_Bits << 1) | (UART_Stop_Bits << 3) | (UART_Parity_Mode << 4) | (UCSRC & 0X41);
    2030:	80 b5       	in	r24, 0x20	; 32
    2032:	81 74       	andi	r24, 0x41	; 65
    2034:	86 6a       	ori	r24, 0xA6	; 166
    2036:	80 bd       	out	0x20, r24	; 32

        // UART Baud Rate
        UBRRL = (Uint8) UART_Baud_Rate;
    2038:	8f ec       	ldi	r24, 0xCF	; 207
    203a:	89 b9       	out	0x09, r24	; 9
        UBRRH = (UART_Baud_Rate >> 8);
    203c:	10 bc       	out	0x20, r1	; 32
    203e:	08 95       	ret

00002040 <UART_TX_Char>:
}

void UART_TX_Char(Uint8 data) {
        // Sending Data
        UDR = data;
    2040:	8c b9       	out	0x0c, r24	; 12

        // Checking the data is sent
        while (!Get_Bit(UCSRA, 5));
    2042:	5d 9b       	sbis	0x0b, 5	; 11
    2044:	fe cf       	rjmp	.-4      	; 0x2042 <UART_TX_Char+0x2>
}
    2046:	08 95       	ret

00002048 <UART_TX_Str>:

void UART_TX_Str(Uint8 * str) {
    2048:	0f 93       	push	r16
    204a:	1f 93       	push	r17
    204c:	cf 93       	push	r28
    204e:	8c 01       	movw	r16, r24
        for (Uint8 i = 0; str[i] != '\n'; i++) {
    2050:	c0 e0       	ldi	r28, 0x00	; 0
    2052:	03 c0       	rjmp	.+6      	; 0x205a <UART_TX_Str+0x12>
                UART_TX_Char(str[i]);
    2054:	0e 94 20 10 	call	0x2040	; 0x2040 <UART_TX_Char>
        // Checking the data is sent
        while (!Get_Bit(UCSRA, 5));
}

void UART_TX_Str(Uint8 * str) {
        for (Uint8 i = 0; str[i] != '\n'; i++) {
    2058:	cf 5f       	subi	r28, 0xFF	; 255
    205a:	f8 01       	movw	r30, r16
    205c:	ec 0f       	add	r30, r28
    205e:	f1 1d       	adc	r31, r1
    2060:	80 81       	ld	r24, Z
    2062:	8a 30       	cpi	r24, 0x0A	; 10
    2064:	b9 f7       	brne	.-18     	; 0x2054 <UART_TX_Str+0xc>
                UART_TX_Char(str[i]);
        }
}
    2066:	cf 91       	pop	r28
    2068:	1f 91       	pop	r17
    206a:	0f 91       	pop	r16
    206c:	08 95       	ret

0000206e <UART_RX_Char>:
Uint8 UART_RX_Char(void) {
        // Receiving data 
        Uint8 Value = 0;

        // Checking the data is received 
        while (!Get_Bit(UCSRA, 5));
    206e:	5d 9b       	sbis	0x0b, 5	; 11
    2070:	fe cf       	rjmp	.-4      	; 0x206e <UART_RX_Char>

        // Storing the data received in a variable
        Value = UDR;
    2072:	8c b1       	in	r24, 0x0c	; 12
        return Value;
}
    2074:	08 95       	ret

00002076 <__vector_13>:

ISR(USART_RXC_vect) {
    2076:	1f 92       	push	r1
    2078:	0f 92       	push	r0
    207a:	0f b6       	in	r0, 0x3f	; 63
    207c:	0f 92       	push	r0
    207e:	11 24       	eor	r1, r1
    2080:	4f 92       	push	r4
    2082:	5f 92       	push	r5
    2084:	6f 92       	push	r6
    2086:	7f 92       	push	r7
    2088:	8f 92       	push	r8
    208a:	9f 92       	push	r9
    208c:	af 92       	push	r10
    208e:	bf 92       	push	r11
    2090:	cf 92       	push	r12
    2092:	df 92       	push	r13
    2094:	ef 92       	push	r14
    2096:	ff 92       	push	r15
    2098:	0f 93       	push	r16
    209a:	1f 93       	push	r17
    209c:	2f 93       	push	r18
    209e:	3f 93       	push	r19
    20a0:	4f 93       	push	r20
    20a2:	5f 93       	push	r21
    20a4:	6f 93       	push	r22
    20a6:	7f 93       	push	r23
    20a8:	8f 93       	push	r24
    20aa:	9f 93       	push	r25
    20ac:	af 93       	push	r26
    20ae:	bf 93       	push	r27
    20b0:	ef 93       	push	r30
    20b2:	ff 93       	push	r31
    20b4:	cf 93       	push	r28
    20b6:	df 93       	push	r29
    20b8:	cd b7       	in	r28, 0x3d	; 61
    20ba:	de b7       	in	r29, 0x3e	; 62
    20bc:	2a 97       	sbiw	r28, 0x0a	; 10
    20be:	de bf       	out	0x3e, r29	; 62
    20c0:	cd bf       	out	0x3d, r28	; 61
        // Write UART receive handler here
        /*---------> Where all the UART system work <---------*/

        // Initialization of local arrays used for taking username and password of any user
        Uint8 User[4] = {
    20c2:	19 82       	std	Y+1, r1	; 0x01
    20c4:	1a 82       	std	Y+2, r1	; 0x02
    20c6:	1b 82       	std	Y+3, r1	; 0x03
    20c8:	1c 82       	std	Y+4, r1	; 0x04
                0
        };
        Uint8 Pass[4] = {
    20ca:	1d 82       	std	Y+5, r1	; 0x05
    20cc:	1e 82       	std	Y+6, r1	; 0x06
    20ce:	1f 82       	std	Y+7, r1	; 0x07
    20d0:	18 86       	std	Y+8, r1	; 0x08
                0
        };

        // if the there is no keypad user start the timer that clear LCD if there is keypad user don't clear the LCD 
        if (!eme_check)
    20d2:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    20d6:	81 11       	cpse	r24, r1
    20d8:	02 c0       	rjmp	.+4      	; 0x20de <__vector_13+0x68>
                Timer2_Start();
    20da:	0e 94 3f 0f 	call	0x1e7e	; 0x1e7e <Timer2_Start>

        // For login the system where SYS_Check value is 0 	
        if (!SYS_Check) {
    20de:	80 91 f4 07 	lds	r24, 0x07F4	; 0x8007f4 <SYS_Check>
    20e2:	81 11       	cpse	r24, r1
    20e4:	07 c2       	rjmp	.+1038   	; 0x24f4 <__vector_13+0x47e>
                while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    20e6:	5f 9b       	sbis	0x0b, 7	; 11
    20e8:	fe cf       	rjmp	.-4      	; 0x20e6 <__vector_13+0x70>
                A_U_Check = UDR; // Receiving the character 
    20ea:	8c b1       	in	r24, 0x0c	; 12
    20ec:	80 93 f3 07 	sts	0x07F3, r24	; 0x8007f3 <A_U_Check>

                // 3 times for login if the user exceed 3 times the alarm will fire
                for (Uint8 i = 0; i < 3; i++) {
    20f0:	91 2c       	mov	r9, r1
    20f2:	fc c1       	rjmp	.+1016   	; 0x24ec <__vector_13+0x476>
                        // Login as admin
                        if (A_U_Check == '1') {
    20f4:	80 91 f3 07 	lds	r24, 0x07F3	; 0x8007f3 <A_U_Check>
    20f8:	81 33       	cpi	r24, 0x31	; 49
    20fa:	09 f0       	breq	.+2      	; 0x20fe <__vector_13+0x88>
    20fc:	e2 c0       	rjmp	.+452    	; 0x22c2 <__vector_13+0x24c>
                                // Admin enter the system
                                /*------------->Entering Username<-------------*/
                                UART_TX_Str("\r\n");
    20fe:	8a ed       	ldi	r24, 0xDA	; 218
    2100:	92 e0       	ldi	r25, 0x02	; 2
    2102:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("\r\n");
    2106:	8a ed       	ldi	r24, 0xDA	; 218
    2108:	92 e0       	ldi	r25, 0x02	; 2
    210a:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("Please enter your username\r\n");
    210e:	8b e8       	ldi	r24, 0x8B	; 139
    2110:	92 e0       	ldi	r25, 0x02	; 2
    2112:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("\r\n");
    2116:	8a ed       	ldi	r24, 0xDA	; 218
    2118:	92 e0       	ldi	r25, 0x02	; 2
    211a:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>

                                for (Uint8 i = 0; i < 4; i++) {
    211e:	10 e0       	ldi	r17, 0x00	; 0
    2120:	0e c0       	rjmp	.+28     	; 0x213e <__vector_13+0xc8>
                                        while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    2122:	5f 9b       	sbis	0x0b, 7	; 11
    2124:	fe cf       	rjmp	.-4      	; 0x2122 <__vector_13+0xac>
                                        User[i] = UART_RX_Char(); // Receiving the character in username array
    2126:	e1 2e       	mov	r14, r17
    2128:	f1 2c       	mov	r15, r1
    212a:	0e 94 37 10 	call	0x206e	; 0x206e <UART_RX_Char>
    212e:	e1 e0       	ldi	r30, 0x01	; 1
    2130:	f0 e0       	ldi	r31, 0x00	; 0
    2132:	ec 0f       	add	r30, r28
    2134:	fd 1f       	adc	r31, r29
    2136:	ee 0d       	add	r30, r14
    2138:	ff 1d       	adc	r31, r15
    213a:	80 83       	st	Z, r24
                                UART_TX_Str("\r\n");
                                UART_TX_Str("\r\n");
                                UART_TX_Str("Please enter your username\r\n");
                                UART_TX_Str("\r\n");

                                for (Uint8 i = 0; i < 4; i++) {
    213c:	1f 5f       	subi	r17, 0xFF	; 255
    213e:	14 30       	cpi	r17, 0x04	; 4
    2140:	80 f3       	brcs	.-32     	; 0x2122 <__vector_13+0xac>
                                        while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
                                        User[i] = UART_RX_Char(); // Receiving the character in username array
                                }

                                /*------------->Entering Password<-------------*/
                                UART_TX_Str("\r\n");
    2142:	8a ed       	ldi	r24, 0xDA	; 218
    2144:	92 e0       	ldi	r25, 0x02	; 2
    2146:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("\r\n");
    214a:	8a ed       	ldi	r24, 0xDA	; 218
    214c:	92 e0       	ldi	r25, 0x02	; 2
    214e:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("Please enter your password\r\n");
    2152:	88 ea       	ldi	r24, 0xA8	; 168
    2154:	92 e0       	ldi	r25, 0x02	; 2
    2156:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("\r\n");
    215a:	8a ed       	ldi	r24, 0xDA	; 218
    215c:	92 e0       	ldi	r25, 0x02	; 2
    215e:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>

                                for (Uint8 i = 0; i < 4; i++) {
    2162:	10 e0       	ldi	r17, 0x00	; 0
    2164:	0e c0       	rjmp	.+28     	; 0x2182 <__vector_13+0x10c>
                                        while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    2166:	5f 9b       	sbis	0x0b, 7	; 11
    2168:	fe cf       	rjmp	.-4      	; 0x2166 <__vector_13+0xf0>
                                        Pass[i] = UART_RX_Char(); // Receiving the character in password array
    216a:	e1 2e       	mov	r14, r17
    216c:	f1 2c       	mov	r15, r1
    216e:	0e 94 37 10 	call	0x206e	; 0x206e <UART_RX_Char>
    2172:	e5 e0       	ldi	r30, 0x05	; 5
    2174:	f0 e0       	ldi	r31, 0x00	; 0
    2176:	ec 0f       	add	r30, r28
    2178:	fd 1f       	adc	r31, r29
    217a:	ee 0d       	add	r30, r14
    217c:	ff 1d       	adc	r31, r15
    217e:	80 83       	st	Z, r24
                                UART_TX_Str("\r\n");
                                UART_TX_Str("\r\n");
                                UART_TX_Str("Please enter your password\r\n");
                                UART_TX_Str("\r\n");

                                for (Uint8 i = 0; i < 4; i++) {
    2180:	1f 5f       	subi	r17, 0xFF	; 255
    2182:	14 30       	cpi	r17, 0x04	; 4
    2184:	80 f3       	brcs	.-32     	; 0x2166 <__vector_13+0xf0>
    2186:	81 2c       	mov	r8, r1
    2188:	82 c0       	rjmp	.+260    	; 0x228e <__vector_13+0x218>

                                /*---------------> Checking Username & Password<---------------*/

                                for (Uint8 Check_Counter = 0; Check_Counter <= AD_Counter; Check_Counter += 4) {
                                        /*----------------->Username Check<------------------*/
                                        if (User[0] == EEPROM_ReadByte(5, Check_Counter + 1) && User[1] == EEPROM_ReadByte(5, Check_Counter + 2) && User[2] == EEPROM_ReadByte(5, Check_Counter + 3) && User[3] == EEPROM_ReadByte(5, Check_Counter + 4)) {
    218a:	c9 80       	ldd	r12, Y+1	; 0x01
    218c:	d1 2c       	mov	r13, r1
    218e:	08 2d       	mov	r16, r8
    2190:	10 e0       	ldi	r17, 0x00	; 0
    2192:	78 01       	movw	r14, r16
    2194:	8f ef       	ldi	r24, 0xFF	; 255
    2196:	e8 1a       	sub	r14, r24
    2198:	f8 0a       	sbc	r15, r24
    219a:	b7 01       	movw	r22, r14
    219c:	85 e0       	ldi	r24, 0x05	; 5
    219e:	90 e0       	ldi	r25, 0x00	; 0
    21a0:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    21a4:	c8 16       	cp	r12, r24
    21a6:	d9 06       	cpc	r13, r25
    21a8:	09 f0       	breq	.+2      	; 0x21ac <__vector_13+0x136>
    21aa:	6f c0       	rjmp	.+222    	; 0x228a <__vector_13+0x214>
    21ac:	ca 80       	ldd	r12, Y+2	; 0x02
    21ae:	d1 2c       	mov	r13, r1
    21b0:	38 01       	movw	r6, r16
    21b2:	82 e0       	ldi	r24, 0x02	; 2
    21b4:	68 0e       	add	r6, r24
    21b6:	71 1c       	adc	r7, r1
    21b8:	b3 01       	movw	r22, r6
    21ba:	85 e0       	ldi	r24, 0x05	; 5
    21bc:	90 e0       	ldi	r25, 0x00	; 0
    21be:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    21c2:	c8 16       	cp	r12, r24
    21c4:	d9 06       	cpc	r13, r25
    21c6:	09 f0       	breq	.+2      	; 0x21ca <__vector_13+0x154>
    21c8:	60 c0       	rjmp	.+192    	; 0x228a <__vector_13+0x214>
    21ca:	ab 80       	ldd	r10, Y+3	; 0x03
    21cc:	b1 2c       	mov	r11, r1
    21ce:	68 01       	movw	r12, r16
    21d0:	83 e0       	ldi	r24, 0x03	; 3
    21d2:	c8 0e       	add	r12, r24
    21d4:	d1 1c       	adc	r13, r1
    21d6:	b6 01       	movw	r22, r12
    21d8:	85 e0       	ldi	r24, 0x05	; 5
    21da:	90 e0       	ldi	r25, 0x00	; 0
    21dc:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    21e0:	a8 16       	cp	r10, r24
    21e2:	b9 06       	cpc	r11, r25
    21e4:	09 f0       	breq	.+2      	; 0x21e8 <__vector_13+0x172>
    21e6:	51 c0       	rjmp	.+162    	; 0x228a <__vector_13+0x214>
    21e8:	ac 80       	ldd	r10, Y+4	; 0x04
    21ea:	b1 2c       	mov	r11, r1
    21ec:	0c 5f       	subi	r16, 0xFC	; 252
    21ee:	1f 4f       	sbci	r17, 0xFF	; 255
    21f0:	b8 01       	movw	r22, r16
    21f2:	85 e0       	ldi	r24, 0x05	; 5
    21f4:	90 e0       	ldi	r25, 0x00	; 0
    21f6:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    21fa:	a8 16       	cp	r10, r24
    21fc:	b9 06       	cpc	r11, r25
    21fe:	09 f0       	breq	.+2      	; 0x2202 <__vector_13+0x18c>
    2200:	44 c0       	rjmp	.+136    	; 0x228a <__vector_13+0x214>
                                                /*----------------->Password Check<------------------*/

                                                if (Pass[0] == EEPROM_ReadByte(6, Check_Counter + 1) && Pass[1] == EEPROM_ReadByte(6, Check_Counter + 2) && Pass[2] == EEPROM_ReadByte(6, Check_Counter + 3) && Pass[3] == EEPROM_ReadByte(6, Check_Counter + 4)) {
    2202:	ad 80       	ldd	r10, Y+5	; 0x05
    2204:	b1 2c       	mov	r11, r1
    2206:	b7 01       	movw	r22, r14
    2208:	86 e0       	ldi	r24, 0x06	; 6
    220a:	90 e0       	ldi	r25, 0x00	; 0
    220c:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    2210:	a8 16       	cp	r10, r24
    2212:	b9 06       	cpc	r11, r25
    2214:	d1 f5       	brne	.+116    	; 0x228a <__vector_13+0x214>
    2216:	ee 80       	ldd	r14, Y+6	; 0x06
    2218:	f1 2c       	mov	r15, r1
    221a:	b3 01       	movw	r22, r6
    221c:	86 e0       	ldi	r24, 0x06	; 6
    221e:	90 e0       	ldi	r25, 0x00	; 0
    2220:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    2224:	e8 16       	cp	r14, r24
    2226:	f9 06       	cpc	r15, r25
    2228:	81 f5       	brne	.+96     	; 0x228a <__vector_13+0x214>
    222a:	ef 80       	ldd	r14, Y+7	; 0x07
    222c:	f1 2c       	mov	r15, r1
    222e:	b6 01       	movw	r22, r12
    2230:	86 e0       	ldi	r24, 0x06	; 6
    2232:	90 e0       	ldi	r25, 0x00	; 0
    2234:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    2238:	e8 16       	cp	r14, r24
    223a:	f9 06       	cpc	r15, r25
    223c:	31 f5       	brne	.+76     	; 0x228a <__vector_13+0x214>
    223e:	e8 84       	ldd	r14, Y+8	; 0x08
    2240:	f1 2c       	mov	r15, r1
    2242:	b8 01       	movw	r22, r16
    2244:	86 e0       	ldi	r24, 0x06	; 6
    2246:	90 e0       	ldi	r25, 0x00	; 0
    2248:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    224c:	e8 16       	cp	r14, r24
    224e:	f9 06       	cpc	r15, r25
    2250:	e1 f4       	brne	.+56     	; 0x228a <__vector_13+0x214>
                                                        /*----------------->right Username & Password<-----------------*/
                                                        UART_TX_Str("\r\n");
    2252:	8a ed       	ldi	r24, 0xDA	; 218
    2254:	92 e0       	ldi	r25, 0x02	; 2
    2256:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                                        UART_TX_Str("\r\n");
    225a:	8a ed       	ldi	r24, 0xDA	; 218
    225c:	92 e0       	ldi	r25, 0x02	; 2
    225e:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                                        UART_TX_Str("Admin exist, Welcome!\r\n");
    2262:	85 ec       	ldi	r24, 0xC5	; 197
    2264:	92 e0       	ldi	r25, 0x02	; 2
    2266:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                                        UART_TX_Str("\r\n");
    226a:	8a ed       	ldi	r24, 0xDA	; 218
    226c:	92 e0       	ldi	r25, 0x02	; 2
    226e:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                                        Check_Counter = AD_Counter + 1; // Exiting the Check for loop
    2272:	80 90 70 00 	lds	r8, 0x0070	; 0x800070 <AD_Counter>
    2276:	83 94       	inc	r8
                                                        SYS_Check = 1; // Means that admin entered the system (Admin = 1) 
    2278:	81 e0       	ldi	r24, 0x01	; 1
    227a:	80 93 f4 07 	sts	0x07F4, r24	; 0x8007f4 <SYS_Check>
                                                        CMD_Check = 1; // *Not Important to Know* it used to not take UART_Get value variable after login the system as 0 value
    227e:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <CMD_Check>
                                                        i = 5; // Exiting the Alarm for loop  
    2282:	0f 2e       	mov	r0, r31
    2284:	f5 e0       	ldi	r31, 0x05	; 5
    2286:	9f 2e       	mov	r9, r31
    2288:	f0 2d       	mov	r31, r0
                                        Pass[i] = UART_RX_Char(); // Receiving the character in password array
                                }

                                /*---------------> Checking Username & Password<---------------*/

                                for (Uint8 Check_Counter = 0; Check_Counter <= AD_Counter; Check_Counter += 4) {
    228a:	84 e0       	ldi	r24, 0x04	; 4
    228c:	88 0e       	add	r8, r24
    228e:	80 91 70 00 	lds	r24, 0x0070	; 0x800070 <AD_Counter>
    2292:	88 15       	cp	r24, r8
    2294:	08 f0       	brcs	.+2      	; 0x2298 <__vector_13+0x222>
    2296:	79 cf       	rjmp	.-270    	; 0x218a <__vector_13+0x114>
                                                }
                                        }
                                }

                                /*----------------->Wrong Username or Password<-----------------*/
                                if (!SYS_Check) {
    2298:	80 91 f4 07 	lds	r24, 0x07F4	; 0x8007f4 <SYS_Check>
    229c:	81 11       	cpse	r24, r1
    229e:	19 c1       	rjmp	.+562    	; 0x24d2 <__vector_13+0x45c>
                                        UART_TX_Str("\r\n");
    22a0:	8a ed       	ldi	r24, 0xDA	; 218
    22a2:	92 e0       	ldi	r25, 0x02	; 2
    22a4:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                        UART_TX_Str("\r\n");
    22a8:	8a ed       	ldi	r24, 0xDA	; 218
    22aa:	92 e0       	ldi	r25, 0x02	; 2
    22ac:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                        UART_TX_Str("Admin does not exist. Please try again\r\n");
    22b0:	8d ed       	ldi	r24, 0xDD	; 221
    22b2:	92 e0       	ldi	r25, 0x02	; 2
    22b4:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                        UART_TX_Str("\r\n");
    22b8:	8a ed       	ldi	r24, 0xDA	; 218
    22ba:	92 e0       	ldi	r25, 0x02	; 2
    22bc:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
    22c0:	08 c1       	rjmp	.+528    	; 0x24d2 <__vector_13+0x45c>
                                }

                        }
                        // Login as UART user
                        else if (A_U_Check == '2') {
    22c2:	82 33       	cpi	r24, 0x32	; 50
    22c4:	09 f0       	breq	.+2      	; 0x22c8 <__vector_13+0x252>
    22c6:	df c0       	rjmp	.+446    	; 0x2486 <__vector_13+0x410>
                                // PC user enter the system
                                /*------------->Entering Username<-------------*/
                                UART_TX_Str("\r\n");
    22c8:	8a ed       	ldi	r24, 0xDA	; 218
    22ca:	92 e0       	ldi	r25, 0x02	; 2
    22cc:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("Please enter your username\r\n");
    22d0:	8b e8       	ldi	r24, 0x8B	; 139
    22d2:	92 e0       	ldi	r25, 0x02	; 2
    22d4:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("\r\n");
    22d8:	8a ed       	ldi	r24, 0xDA	; 218
    22da:	92 e0       	ldi	r25, 0x02	; 2
    22dc:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>

                                for (Uint8 i = 0; i < 4; i++) {
    22e0:	10 e0       	ldi	r17, 0x00	; 0
    22e2:	0e c0       	rjmp	.+28     	; 0x2300 <__vector_13+0x28a>
                                        while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    22e4:	5f 9b       	sbis	0x0b, 7	; 11
    22e6:	fe cf       	rjmp	.-4      	; 0x22e4 <__vector_13+0x26e>
                                        User[i] = UART_RX_Char(); // Receiving the character in username array
    22e8:	e1 2e       	mov	r14, r17
    22ea:	f1 2c       	mov	r15, r1
    22ec:	0e 94 37 10 	call	0x206e	; 0x206e <UART_RX_Char>
    22f0:	e1 e0       	ldi	r30, 0x01	; 1
    22f2:	f0 e0       	ldi	r31, 0x00	; 0
    22f4:	ec 0f       	add	r30, r28
    22f6:	fd 1f       	adc	r31, r29
    22f8:	ee 0d       	add	r30, r14
    22fa:	ff 1d       	adc	r31, r15
    22fc:	80 83       	st	Z, r24
                                /*------------->Entering Username<-------------*/
                                UART_TX_Str("\r\n");
                                UART_TX_Str("Please enter your username\r\n");
                                UART_TX_Str("\r\n");

                                for (Uint8 i = 0; i < 4; i++) {
    22fe:	1f 5f       	subi	r17, 0xFF	; 255
    2300:	14 30       	cpi	r17, 0x04	; 4
    2302:	80 f3       	brcs	.-32     	; 0x22e4 <__vector_13+0x26e>
                                        while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
                                        User[i] = UART_RX_Char(); // Receiving the character in username array
                                }

                                /*------------->Entering Password<-------------*/
                                UART_TX_Str("\r\n");
    2304:	8a ed       	ldi	r24, 0xDA	; 218
    2306:	92 e0       	ldi	r25, 0x02	; 2
    2308:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("\r\n");
    230c:	8a ed       	ldi	r24, 0xDA	; 218
    230e:	92 e0       	ldi	r25, 0x02	; 2
    2310:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("Please enter your password\r\n");
    2314:	88 ea       	ldi	r24, 0xA8	; 168
    2316:	92 e0       	ldi	r25, 0x02	; 2
    2318:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("\r\n");
    231c:	8a ed       	ldi	r24, 0xDA	; 218
    231e:	92 e0       	ldi	r25, 0x02	; 2
    2320:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>

                                for (Uint8 i = 0; i < 4; i++) {
    2324:	10 e0       	ldi	r17, 0x00	; 0
    2326:	0e c0       	rjmp	.+28     	; 0x2344 <__vector_13+0x2ce>
                                        while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    2328:	5f 9b       	sbis	0x0b, 7	; 11
    232a:	fe cf       	rjmp	.-4      	; 0x2328 <__vector_13+0x2b2>
                                        Pass[i] = UART_RX_Char(); // Receiving the character in password array
    232c:	e1 2e       	mov	r14, r17
    232e:	f1 2c       	mov	r15, r1
    2330:	0e 94 37 10 	call	0x206e	; 0x206e <UART_RX_Char>
    2334:	e5 e0       	ldi	r30, 0x05	; 5
    2336:	f0 e0       	ldi	r31, 0x00	; 0
    2338:	ec 0f       	add	r30, r28
    233a:	fd 1f       	adc	r31, r29
    233c:	ee 0d       	add	r30, r14
    233e:	ff 1d       	adc	r31, r15
    2340:	80 83       	st	Z, r24
                                UART_TX_Str("\r\n");
                                UART_TX_Str("\r\n");
                                UART_TX_Str("Please enter your password\r\n");
                                UART_TX_Str("\r\n");

                                for (Uint8 i = 0; i < 4; i++) {
    2342:	1f 5f       	subi	r17, 0xFF	; 255
    2344:	14 30       	cpi	r17, 0x04	; 4
    2346:	80 f3       	brcs	.-32     	; 0x2328 <__vector_13+0x2b2>
    2348:	b1 2c       	mov	r11, r1
    234a:	83 c0       	rjmp	.+262    	; 0x2452 <__vector_13+0x3dc>
                                }

                                /*---------------> Checking Username & Password<---------------*/
                                for (Uint8 Check_Counter = 0; Check_Counter <= PC_Counter; Check_Counter += 4) {
                                        /*----------------->Username Check<------------------*/
                                        if (User[0] == EEPROM_ReadByte(2, Check_Counter + 1) && User[1] == EEPROM_ReadByte(2, Check_Counter + 2) && User[2] == EEPROM_ReadByte(2, Check_Counter + 3) && User[3] == EEPROM_ReadByte(2, Check_Counter + 4)) {
    234c:	c9 80       	ldd	r12, Y+1	; 0x01
    234e:	d1 2c       	mov	r13, r1
    2350:	0b 2d       	mov	r16, r11
    2352:	10 e0       	ldi	r17, 0x00	; 0
    2354:	78 01       	movw	r14, r16
    2356:	8f ef       	ldi	r24, 0xFF	; 255
    2358:	e8 1a       	sub	r14, r24
    235a:	f8 0a       	sbc	r15, r24
    235c:	b7 01       	movw	r22, r14
    235e:	82 e0       	ldi	r24, 0x02	; 2
    2360:	90 e0       	ldi	r25, 0x00	; 0
    2362:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    2366:	c8 16       	cp	r12, r24
    2368:	d9 06       	cpc	r13, r25
    236a:	09 f0       	breq	.+2      	; 0x236e <__vector_13+0x2f8>
    236c:	70 c0       	rjmp	.+224    	; 0x244e <__vector_13+0x3d8>
    236e:	ca 80       	ldd	r12, Y+2	; 0x02
    2370:	d1 2c       	mov	r13, r1
    2372:	28 01       	movw	r4, r16
    2374:	82 e0       	ldi	r24, 0x02	; 2
    2376:	48 0e       	add	r4, r24
    2378:	51 1c       	adc	r5, r1
    237a:	b2 01       	movw	r22, r4
    237c:	82 e0       	ldi	r24, 0x02	; 2
    237e:	90 e0       	ldi	r25, 0x00	; 0
    2380:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    2384:	c8 16       	cp	r12, r24
    2386:	d9 06       	cpc	r13, r25
    2388:	09 f0       	breq	.+2      	; 0x238c <__vector_13+0x316>
    238a:	61 c0       	rjmp	.+194    	; 0x244e <__vector_13+0x3d8>
    238c:	cb 80       	ldd	r12, Y+3	; 0x03
    238e:	d1 2c       	mov	r13, r1
    2390:	38 01       	movw	r6, r16
    2392:	83 e0       	ldi	r24, 0x03	; 3
    2394:	68 0e       	add	r6, r24
    2396:	71 1c       	adc	r7, r1
    2398:	b3 01       	movw	r22, r6
    239a:	82 e0       	ldi	r24, 0x02	; 2
    239c:	90 e0       	ldi	r25, 0x00	; 0
    239e:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    23a2:	c8 16       	cp	r12, r24
    23a4:	d9 06       	cpc	r13, r25
    23a6:	09 f0       	breq	.+2      	; 0x23aa <__vector_13+0x334>
    23a8:	52 c0       	rjmp	.+164    	; 0x244e <__vector_13+0x3d8>
    23aa:	cc 80       	ldd	r12, Y+4	; 0x04
    23ac:	d1 2c       	mov	r13, r1
    23ae:	0c 5f       	subi	r16, 0xFC	; 252
    23b0:	1f 4f       	sbci	r17, 0xFF	; 255
    23b2:	b8 01       	movw	r22, r16
    23b4:	82 e0       	ldi	r24, 0x02	; 2
    23b6:	90 e0       	ldi	r25, 0x00	; 0
    23b8:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    23bc:	c8 16       	cp	r12, r24
    23be:	d9 06       	cpc	r13, r25
    23c0:	09 f0       	breq	.+2      	; 0x23c4 <__vector_13+0x34e>
    23c2:	45 c0       	rjmp	.+138    	; 0x244e <__vector_13+0x3d8>
                                                /*----------------->Password Check<------------------*/
                                                if (Pass[0] == EEPROM_ReadByte(3, Check_Counter + 1) && Pass[1] == EEPROM_ReadByte(3, Check_Counter + 2) && Pass[2] == EEPROM_ReadByte(3, Check_Counter + 3) && Pass[3] == EEPROM_ReadByte(3, Check_Counter + 4)) {
    23c4:	cd 80       	ldd	r12, Y+5	; 0x05
    23c6:	d1 2c       	mov	r13, r1
    23c8:	b7 01       	movw	r22, r14
    23ca:	83 e0       	ldi	r24, 0x03	; 3
    23cc:	90 e0       	ldi	r25, 0x00	; 0
    23ce:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    23d2:	c8 16       	cp	r12, r24
    23d4:	d9 06       	cpc	r13, r25
    23d6:	d9 f5       	brne	.+118    	; 0x244e <__vector_13+0x3d8>
    23d8:	ee 80       	ldd	r14, Y+6	; 0x06
    23da:	f1 2c       	mov	r15, r1
    23dc:	b2 01       	movw	r22, r4
    23de:	83 e0       	ldi	r24, 0x03	; 3
    23e0:	90 e0       	ldi	r25, 0x00	; 0
    23e2:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    23e6:	e8 16       	cp	r14, r24
    23e8:	f9 06       	cpc	r15, r25
    23ea:	89 f5       	brne	.+98     	; 0x244e <__vector_13+0x3d8>
    23ec:	ef 80       	ldd	r14, Y+7	; 0x07
    23ee:	f1 2c       	mov	r15, r1
    23f0:	b3 01       	movw	r22, r6
    23f2:	83 e0       	ldi	r24, 0x03	; 3
    23f4:	90 e0       	ldi	r25, 0x00	; 0
    23f6:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    23fa:	e8 16       	cp	r14, r24
    23fc:	f9 06       	cpc	r15, r25
    23fe:	39 f5       	brne	.+78     	; 0x244e <__vector_13+0x3d8>
    2400:	e8 84       	ldd	r14, Y+8	; 0x08
    2402:	f1 2c       	mov	r15, r1
    2404:	b8 01       	movw	r22, r16
    2406:	83 e0       	ldi	r24, 0x03	; 3
    2408:	90 e0       	ldi	r25, 0x00	; 0
    240a:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    240e:	e8 16       	cp	r14, r24
    2410:	f9 06       	cpc	r15, r25
    2412:	e9 f4       	brne	.+58     	; 0x244e <__vector_13+0x3d8>
                                                        /*----------------->right Username & Password<-----------------*/
                                                        UART_TX_Str("\r\n");
    2414:	8a ed       	ldi	r24, 0xDA	; 218
    2416:	92 e0       	ldi	r25, 0x02	; 2
    2418:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                                        UART_TX_Str("\r\n");
    241c:	8a ed       	ldi	r24, 0xDA	; 218
    241e:	92 e0       	ldi	r25, 0x02	; 2
    2420:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                                        UART_TX_Str("User exist, Welcome!\r\n");
    2424:	86 e0       	ldi	r24, 0x06	; 6
    2426:	93 e0       	ldi	r25, 0x03	; 3
    2428:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                                        UART_TX_Str("\r\n");
    242c:	8a ed       	ldi	r24, 0xDA	; 218
    242e:	92 e0       	ldi	r25, 0x02	; 2
    2430:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                                        Check_Counter = PC_Counter + 1; // Exiting the Check for loop
    2434:	b0 90 f0 07 	lds	r11, 0x07F0	; 0x8007f0 <PC_Counter>
    2438:	b3 94       	inc	r11
                                                        SYS_Check = 2; // Means that UART user entered the system (PC user = 1)
    243a:	82 e0       	ldi	r24, 0x02	; 2
    243c:	80 93 f4 07 	sts	0x07F4, r24	; 0x8007f4 <SYS_Check>
                                                        CMD_Check = 1; // *Not Important to Know* it used to not take UART_Get value variable after login the system as 0 value
    2440:	81 e0       	ldi	r24, 0x01	; 1
    2442:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <CMD_Check>
                                                        i = 5; // Exiting the Alarm for loop
    2446:	0f 2e       	mov	r0, r31
    2448:	f5 e0       	ldi	r31, 0x05	; 5
    244a:	9f 2e       	mov	r9, r31
    244c:	f0 2d       	mov	r31, r0
                                        while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
                                        Pass[i] = UART_RX_Char(); // Receiving the character in password array
                                }

                                /*---------------> Checking Username & Password<---------------*/
                                for (Uint8 Check_Counter = 0; Check_Counter <= PC_Counter; Check_Counter += 4) {
    244e:	84 e0       	ldi	r24, 0x04	; 4
    2450:	b8 0e       	add	r11, r24
    2452:	80 91 f0 07 	lds	r24, 0x07F0	; 0x8007f0 <PC_Counter>
    2456:	8b 15       	cp	r24, r11
    2458:	08 f0       	brcs	.+2      	; 0x245c <__vector_13+0x3e6>
    245a:	78 cf       	rjmp	.-272    	; 0x234c <__vector_13+0x2d6>
                                                }
                                        }
                                }

                                /*----------------->Wrong Username or Password<-----------------*/
                                if (!SYS_Check) {
    245c:	80 91 f4 07 	lds	r24, 0x07F4	; 0x8007f4 <SYS_Check>
    2460:	81 11       	cpse	r24, r1
    2462:	37 c0       	rjmp	.+110    	; 0x24d2 <__vector_13+0x45c>
                                        UART_TX_Str("\r\n");
    2464:	8a ed       	ldi	r24, 0xDA	; 218
    2466:	92 e0       	ldi	r25, 0x02	; 2
    2468:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                        UART_TX_Str("\r\n");
    246c:	8a ed       	ldi	r24, 0xDA	; 218
    246e:	92 e0       	ldi	r25, 0x02	; 2
    2470:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                        UART_TX_Str("User does not exist. Please try again\r\n");
    2474:	8d e1       	ldi	r24, 0x1D	; 29
    2476:	93 e0       	ldi	r25, 0x03	; 3
    2478:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                        UART_TX_Str("\r\n");
    247c:	8a ed       	ldi	r24, 0xDA	; 218
    247e:	92 e0       	ldi	r25, 0x02	; 2
    2480:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
    2484:	26 c0       	rjmp	.+76     	; 0x24d2 <__vector_13+0x45c>
                                }
                        }
                        // If user entered wrong command
                        else {
                                UART_TX_Str("\r\n");
    2486:	8a ed       	ldi	r24, 0xDA	; 218
    2488:	92 e0       	ldi	r25, 0x02	; 2
    248a:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("\r\n");
    248e:	8a ed       	ldi	r24, 0xDA	; 218
    2490:	92 e0       	ldi	r25, 0x02	; 2
    2492:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("Please enter command number\r\n");
    2496:	85 e4       	ldi	r24, 0x45	; 69
    2498:	93 e0       	ldi	r25, 0x03	; 3
    249a:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("\r\n");
    249e:	8a ed       	ldi	r24, 0xDA	; 218
    24a0:	92 e0       	ldi	r25, 0x02	; 2
    24a2:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("\r\n");
    24a6:	8a ed       	ldi	r24, 0xDA	; 218
    24a8:	92 e0       	ldi	r25, 0x02	; 2
    24aa:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("1.Enter Admin\r\n");
    24ae:	8c e6       	ldi	r24, 0x6C	; 108
    24b0:	92 e0       	ldi	r25, 0x02	; 2
    24b2:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("2.Enter User\r\n");
    24b6:	8c e7       	ldi	r24, 0x7C	; 124
    24b8:	92 e0       	ldi	r25, 0x02	; 2
    24ba:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("\r\n");
    24be:	8a ed       	ldi	r24, 0xDA	; 218
    24c0:	92 e0       	ldi	r25, 0x02	; 2
    24c2:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                i--;
    24c6:	9a 94       	dec	r9
                                while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    24c8:	5f 9b       	sbis	0x0b, 7	; 11
    24ca:	fe cf       	rjmp	.-4      	; 0x24c8 <__vector_13+0x452>
                                A_U_Check = UDR; // Receiving the character
    24cc:	8c b1       	in	r24, 0x0c	; 12
    24ce:	80 93 f3 07 	sts	0x07F3, r24	; 0x8007f3 <A_U_Check>
                        }

                        // Case of firing alarm (3 times wrong username/password) 
                        if (i == 2) {
    24d2:	82 e0       	ldi	r24, 0x02	; 2
    24d4:	98 12       	cpse	r9, r24
    24d6:	09 c0       	rjmp	.+18     	; 0x24ea <__vector_13+0x474>
                                LCD_Clear();
    24d8:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                LCD_Write_String("Firing Alarm!");
    24dc:	8b e0       	ldi	r24, 0x0B	; 11
    24de:	92 e0       	ldi	r25, 0x02	; 2
    24e0:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>

                                while (1) {
                                        Alarm_Fn(); // Interrupt function that polling the system and does not exit except with reset pin
    24e4:	0e 94 1a 07 	call	0xe34	; 0xe34 <Alarm_Fn>
    24e8:	fd cf       	rjmp	.-6      	; 0x24e4 <__vector_13+0x46e>
        if (!SYS_Check) {
                while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
                A_U_Check = UDR; // Receiving the character 

                // 3 times for login if the user exceed 3 times the alarm will fire
                for (Uint8 i = 0; i < 3; i++) {
    24ea:	93 94       	inc	r9
    24ec:	82 e0       	ldi	r24, 0x02	; 2
    24ee:	89 15       	cp	r24, r9
    24f0:	08 f0       	brcs	.+2      	; 0x24f4 <__vector_13+0x47e>
    24f2:	00 ce       	rjmp	.-1024   	; 0x20f4 <__vector_13+0x7e>
                        }
                }
        }

        /*----------> Admin Loged-in <----------*/
        if (SYS_Check == 1) {
    24f4:	80 91 f4 07 	lds	r24, 0x07F4	; 0x8007f4 <SYS_Check>
    24f8:	81 30       	cpi	r24, 0x01	; 1
    24fa:	09 f0       	breq	.+2      	; 0x24fe <__vector_13+0x488>
    24fc:	3d c6       	rjmp	.+3194   	; 0x3178 <__vector_13+0x1102>
                // *Not Important to Know* it used to not take UART_Get value variable after login the system as 0 value (do nothing after entering the system)
                if (!CMD_Check) {
    24fe:	80 91 f2 07 	lds	r24, 0x07F2	; 0x8007f2 <CMD_Check>
    2502:	81 11       	cpse	r24, r1
    2504:	04 c0       	rjmp	.+8      	; 0x250e <__vector_13+0x498>
                        UART_GetValue = UDR;
    2506:	8c b1       	in	r24, 0x0c	; 12
    2508:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <UART_GetValue>
    250c:	05 c0       	rjmp	.+10     	; 0x2518 <__vector_13+0x4a2>
                } else {
                        UART_GetValue = 8;
    250e:	88 e0       	ldi	r24, 0x08	; 8
    2510:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <UART_GetValue>
                        CMD_Check = 0;
    2514:	10 92 f2 07 	sts	0x07F2, r1	; 0x8007f2 <CMD_Check>
                }

                if (UART_GetValue == '1') {
    2518:	80 91 f5 07 	lds	r24, 0x07F5	; 0x8007f5 <UART_GetValue>
    251c:	81 33       	cpi	r24, 0x31	; 49
    251e:	b9 f4       	brne	.+46     	; 0x254e <__vector_13+0x4d8>
                        // Open the door
                        Servoo_Motor(316); // 316 gives 90 degree servo rotation 
    2520:	6c e3       	ldi	r22, 0x3C	; 60
    2522:	71 e0       	ldi	r23, 0x01	; 1
    2524:	80 e0       	ldi	r24, 0x00	; 0
    2526:	90 e0       	ldi	r25, 0x00	; 0
    2528:	0e 94 be 0d 	call	0x1b7c	; 0x1b7c <Servoo_Motor>
                        // If there is no keypad user, using LCD to write the operating device
                        if (!eme_check) {
    252c:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    2530:	81 11       	cpse	r24, r1
    2532:	b3 c5       	rjmp	.+2918   	; 0x309a <__vector_13+0x1024>
                                LCD_Clear();
    2534:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                LCD_Write_String("Door Opened!");
    2538:	83 e6       	ldi	r24, 0x63	; 99
    253a:	93 e0       	ldi	r25, 0x03	; 3
    253c:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                                Timer2_SetDelay(2000); // Clearing LCD after 2 seconds using timer 2
    2540:	60 ed       	ldi	r22, 0xD0	; 208
    2542:	77 e0       	ldi	r23, 0x07	; 7
    2544:	80 e0       	ldi	r24, 0x00	; 0
    2546:	90 e0       	ldi	r25, 0x00	; 0
    2548:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <Timer2_SetDelay>
    254c:	a6 c5       	rjmp	.+2892   	; 0x309a <__vector_13+0x1024>
                        }
                } else if (UART_GetValue == '2') {
    254e:	82 33       	cpi	r24, 0x32	; 50
    2550:	b9 f4       	brne	.+46     	; 0x2580 <__vector_13+0x50a>
                        // Close the door
                        Servoo_Motor(97); // 97 gives 0 degree servo
    2552:	61 e6       	ldi	r22, 0x61	; 97
    2554:	70 e0       	ldi	r23, 0x00	; 0
    2556:	80 e0       	ldi	r24, 0x00	; 0
    2558:	90 e0       	ldi	r25, 0x00	; 0
    255a:	0e 94 be 0d 	call	0x1b7c	; 0x1b7c <Servoo_Motor>
                        // If there is no keypad user, using LCD to write the operating device
                        if (!eme_check) {
    255e:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    2562:	81 11       	cpse	r24, r1
    2564:	9a c5       	rjmp	.+2868   	; 0x309a <__vector_13+0x1024>
                                LCD_Clear();
    2566:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                LCD_Write_String("Door Closed!");
    256a:	80 e7       	ldi	r24, 0x70	; 112
    256c:	93 e0       	ldi	r25, 0x03	; 3
    256e:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                                Timer2_SetDelay(2000); // Clearing LCD after 2 seconds using timer 2
    2572:	60 ed       	ldi	r22, 0xD0	; 208
    2574:	77 e0       	ldi	r23, 0x07	; 7
    2576:	80 e0       	ldi	r24, 0x00	; 0
    2578:	90 e0       	ldi	r25, 0x00	; 0
    257a:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <Timer2_SetDelay>
    257e:	8d c5       	rjmp	.+2842   	; 0x309a <__vector_13+0x1024>
                        }
                } else if (UART_GetValue == '3') {
    2580:	83 33       	cpi	r24, 0x33	; 51
    2582:	09 f0       	breq	.+2      	; 0x2586 <__vector_13+0x510>
    2584:	8e c0       	rjmp	.+284    	; 0x26a2 <__vector_13+0x62c>
                        // Open lamps
                        UART_TX_Str("\r\n");
    2586:	8a ed       	ldi	r24, 0xDA	; 218
    2588:	92 e0       	ldi	r25, 0x02	; 2
    258a:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    258e:	8a ed       	ldi	r24, 0xDA	; 218
    2590:	92 e0       	ldi	r25, 0x02	; 2
    2592:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("Which lamp do you want to be opened(From 1 to 5)\r\n");
    2596:	8d e7       	ldi	r24, 0x7D	; 125
    2598:	93 e0       	ldi	r25, 0x03	; 3
    259a:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("6.All Lamps\r\n");
    259e:	80 eb       	ldi	r24, 0xB0	; 176
    25a0:	93 e0       	ldi	r25, 0x03	; 3
    25a2:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    25a6:	8a ed       	ldi	r24, 0xDA	; 218
    25a8:	92 e0       	ldi	r25, 0x02	; 2
    25aa:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>

                        while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    25ae:	5f 9b       	sbis	0x0b, 7	; 11
    25b0:	fe cf       	rjmp	.-4      	; 0x25ae <__vector_13+0x538>
                        UART_GetValue = UART_RX_Char(); // Receiving the command
    25b2:	0e 94 37 10 	call	0x206e	; 0x206e <UART_RX_Char>
    25b6:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <UART_GetValue>

                        // Open first lamp
                        if (UART_GetValue == '1') {
    25ba:	81 33       	cpi	r24, 0x31	; 49
    25bc:	69 f4       	brne	.+26     	; 0x25d8 <__vector_13+0x562>
                                LED0_ON();
    25be:	0e 94 ac 0c 	call	0x1958	; 0x1958 <LED0_ON>
                                // If there is no keypad user, using LCD to write the operating device
                                if (!eme_check) {
    25c2:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    25c6:	81 11       	cpse	r24, r1
    25c8:	61 c0       	rjmp	.+194    	; 0x268c <__vector_13+0x616>
                                        LCD_Clear();
    25ca:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                        LCD_Write_String("Lamp(1) Opened");
    25ce:	8e eb       	ldi	r24, 0xBE	; 190
    25d0:	93 e0       	ldi	r25, 0x03	; 3
    25d2:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
    25d6:	5a c0       	rjmp	.+180    	; 0x268c <__vector_13+0x616>
                                }
                        }
                        // Open second lamp
                        else if (UART_GetValue == '2') {
    25d8:	82 33       	cpi	r24, 0x32	; 50
    25da:	69 f4       	brne	.+26     	; 0x25f6 <__vector_13+0x580>
                                LED1_ON();
    25dc:	0e 94 c8 0c 	call	0x1990	; 0x1990 <LED1_ON>
                                // If there is no keypad user, using LCD to write the operating device
                                if (!eme_check) {
    25e0:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    25e4:	81 11       	cpse	r24, r1
    25e6:	52 c0       	rjmp	.+164    	; 0x268c <__vector_13+0x616>
                                        LCD_Clear();
    25e8:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                        LCD_Write_String("Lamp(2) Opened");
    25ec:	8d ec       	ldi	r24, 0xCD	; 205
    25ee:	93 e0       	ldi	r25, 0x03	; 3
    25f0:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
    25f4:	4b c0       	rjmp	.+150    	; 0x268c <__vector_13+0x616>
                                }
                        }
                        // Open third lamp			
                        else if (UART_GetValue == '3') {
    25f6:	83 33       	cpi	r24, 0x33	; 51
    25f8:	69 f4       	brne	.+26     	; 0x2614 <__vector_13+0x59e>
                                LED2_ON();
    25fa:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LED2_ON>
                                // If there is no keypad user, using LCD to write the operating device
                                if (!eme_check) {
    25fe:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    2602:	81 11       	cpse	r24, r1
    2604:	43 c0       	rjmp	.+134    	; 0x268c <__vector_13+0x616>
                                        LCD_Clear();
    2606:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                        LCD_Write_String("Lamp(3) Opened");
    260a:	8c ed       	ldi	r24, 0xDC	; 220
    260c:	93 e0       	ldi	r25, 0x03	; 3
    260e:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
    2612:	3c c0       	rjmp	.+120    	; 0x268c <__vector_13+0x616>
                                }
                        }
                        // Open fourth lamp
                        else if (UART_GetValue == '4') {
    2614:	84 33       	cpi	r24, 0x34	; 52
    2616:	69 f4       	brne	.+26     	; 0x2632 <__vector_13+0x5bc>
                                LED3_ON();
    2618:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <LED3_ON>
                                // If there is no keypad user, using LCD to write the operating device
                                if (!eme_check) {
    261c:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    2620:	81 11       	cpse	r24, r1
    2622:	34 c0       	rjmp	.+104    	; 0x268c <__vector_13+0x616>
                                        LCD_Clear();
    2624:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                        LCD_Write_String("Lamp(4) Opened");
    2628:	8b ee       	ldi	r24, 0xEB	; 235
    262a:	93 e0       	ldi	r25, 0x03	; 3
    262c:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
    2630:	2d c0       	rjmp	.+90     	; 0x268c <__vector_13+0x616>
                                }
                        }
                        // Open fifth lamp
                        else if (UART_GetValue == '5') {
    2632:	85 33       	cpi	r24, 0x35	; 53
    2634:	69 f4       	brne	.+26     	; 0x2650 <__vector_13+0x5da>
                                LED4_ON();
    2636:	0e 94 1c 0d 	call	0x1a38	; 0x1a38 <LED4_ON>
                                // If there is no keypad user, using LCD to write the operating device
                                if (!eme_check) {
    263a:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    263e:	81 11       	cpse	r24, r1
    2640:	25 c0       	rjmp	.+74     	; 0x268c <__vector_13+0x616>
                                        LCD_Clear();
    2642:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                        LCD_Write_String("Lamp(5) Opened");
    2646:	8a ef       	ldi	r24, 0xFA	; 250
    2648:	93 e0       	ldi	r25, 0x03	; 3
    264a:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
    264e:	1e c0       	rjmp	.+60     	; 0x268c <__vector_13+0x616>
                                }
                        }
                        // Open all lamps
                        else if (UART_GetValue == '6') {
    2650:	86 33       	cpi	r24, 0x36	; 54
    2652:	e1 f4       	brne	.+56     	; 0x268c <__vector_13+0x616>
                                LED0_ON();
    2654:	0e 94 ac 0c 	call	0x1958	; 0x1958 <LED0_ON>
                                LED1_ON();
    2658:	0e 94 c8 0c 	call	0x1990	; 0x1990 <LED1_ON>
                                LED2_ON();
    265c:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LED2_ON>
                                LED3_ON();
    2660:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <LED3_ON>
                                LED4_ON();
    2664:	0e 94 1c 0d 	call	0x1a38	; 0x1a38 <LED4_ON>
                                // If there is no keypad user, using LCD to write the operating device
                                if (!eme_check) {
    2668:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    266c:	81 11       	cpse	r24, r1
    266e:	0e c0       	rjmp	.+28     	; 0x268c <__vector_13+0x616>
                                        LCD_Clear();
    2670:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                        LCD_Write_String("All Lamps Are");
    2674:	89 e0       	ldi	r24, 0x09	; 9
    2676:	94 e0       	ldi	r25, 0x04	; 4
    2678:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                                        LCD_Goto(1, 0);
    267c:	60 e0       	ldi	r22, 0x00	; 0
    267e:	81 e0       	ldi	r24, 0x01	; 1
    2680:	0e 94 83 0c 	call	0x1906	; 0x1906 <LCD_Goto>
                                        LCD_Write_String("Opened");
    2684:	86 ec       	ldi	r24, 0xC6	; 198
    2686:	93 e0       	ldi	r25, 0x03	; 3
    2688:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                                }
                        }
                        // If there is no keypad user, using LCD to write & clear the operating device
                        if (!eme_check)
    268c:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    2690:	81 11       	cpse	r24, r1
    2692:	03 c5       	rjmp	.+2566   	; 0x309a <__vector_13+0x1024>
                                Timer2_SetDelay(2000); // Clearing LCD after 2 seconds using timer 2
    2694:	60 ed       	ldi	r22, 0xD0	; 208
    2696:	77 e0       	ldi	r23, 0x07	; 7
    2698:	80 e0       	ldi	r24, 0x00	; 0
    269a:	90 e0       	ldi	r25, 0x00	; 0
    269c:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <Timer2_SetDelay>
    26a0:	fc c4       	rjmp	.+2552   	; 0x309a <__vector_13+0x1024>
                } else if (UART_GetValue == '4') {
    26a2:	84 33       	cpi	r24, 0x34	; 52
    26a4:	09 f0       	breq	.+2      	; 0x26a8 <__vector_13+0x632>
    26a6:	8e c0       	rjmp	.+284    	; 0x27c4 <__vector_13+0x74e>
                        // Close lamps
                        UART_TX_Str("\r\n");
    26a8:	8a ed       	ldi	r24, 0xDA	; 218
    26aa:	92 e0       	ldi	r25, 0x02	; 2
    26ac:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    26b0:	8a ed       	ldi	r24, 0xDA	; 218
    26b2:	92 e0       	ldi	r25, 0x02	; 2
    26b4:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("Which lamp do you want to be Closed(From 1 to 5)\r\n");
    26b8:	87 e1       	ldi	r24, 0x17	; 23
    26ba:	94 e0       	ldi	r25, 0x04	; 4
    26bc:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("6.All Lamps\r\n");
    26c0:	80 eb       	ldi	r24, 0xB0	; 176
    26c2:	93 e0       	ldi	r25, 0x03	; 3
    26c4:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    26c8:	8a ed       	ldi	r24, 0xDA	; 218
    26ca:	92 e0       	ldi	r25, 0x02	; 2
    26cc:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>

                        while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    26d0:	5f 9b       	sbis	0x0b, 7	; 11
    26d2:	fe cf       	rjmp	.-4      	; 0x26d0 <__vector_13+0x65a>
                        UART_GetValue = UART_RX_Char(); // Receiving the command
    26d4:	0e 94 37 10 	call	0x206e	; 0x206e <UART_RX_Char>
    26d8:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <UART_GetValue>

                        // CLose first lamp
                        if (UART_GetValue == '1') {
    26dc:	81 33       	cpi	r24, 0x31	; 49
    26de:	69 f4       	brne	.+26     	; 0x26fa <__vector_13+0x684>
                                LED0_OFF();
    26e0:	0e 94 b2 0c 	call	0x1964	; 0x1964 <LED0_OFF>
                                // If there is no keypad user, using LCD to write the operating device
                                if (!eme_check) {
    26e4:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    26e8:	81 11       	cpse	r24, r1
    26ea:	61 c0       	rjmp	.+194    	; 0x27ae <__vector_13+0x738>
                                        LCD_Clear();
    26ec:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                        LCD_Write_String("Lamp(1) Closed");
    26f0:	8a e4       	ldi	r24, 0x4A	; 74
    26f2:	94 e0       	ldi	r25, 0x04	; 4
    26f4:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
    26f8:	5a c0       	rjmp	.+180    	; 0x27ae <__vector_13+0x738>
                                }
                        }
                        // Close second lamp
                        else if (UART_GetValue == '2') {
    26fa:	82 33       	cpi	r24, 0x32	; 50
    26fc:	69 f4       	brne	.+26     	; 0x2718 <__vector_13+0x6a2>
                                LED1_OFF();
    26fe:	0e 94 ce 0c 	call	0x199c	; 0x199c <LED1_OFF>
                                // If there is no keypad user, using LCD to write the operating device
                                if (!eme_check) {
    2702:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    2706:	81 11       	cpse	r24, r1
    2708:	52 c0       	rjmp	.+164    	; 0x27ae <__vector_13+0x738>
                                        LCD_Clear();
    270a:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                        LCD_Write_String("Lamp(2) Closed");
    270e:	89 e5       	ldi	r24, 0x59	; 89
    2710:	94 e0       	ldi	r25, 0x04	; 4
    2712:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
    2716:	4b c0       	rjmp	.+150    	; 0x27ae <__vector_13+0x738>
                                }
                        }
                        // Close third lamp
                        else if (UART_GetValue == '3') {
    2718:	83 33       	cpi	r24, 0x33	; 51
    271a:	69 f4       	brne	.+26     	; 0x2736 <__vector_13+0x6c0>
                                LED2_OFF();
    271c:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <LED2_OFF>
                                // If there is no keypad user, using LCD to write the operating device
                                if (!eme_check) {
    2720:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    2724:	81 11       	cpse	r24, r1
    2726:	43 c0       	rjmp	.+134    	; 0x27ae <__vector_13+0x738>
                                        LCD_Clear();
    2728:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                        LCD_Write_String("Lamp(3) Closed");
    272c:	88 e6       	ldi	r24, 0x68	; 104
    272e:	94 e0       	ldi	r25, 0x04	; 4
    2730:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
    2734:	3c c0       	rjmp	.+120    	; 0x27ae <__vector_13+0x738>
                                }
                        }
                        // Close fourth lamp
                        else if (UART_GetValue == '4') {
    2736:	84 33       	cpi	r24, 0x34	; 52
    2738:	69 f4       	brne	.+26     	; 0x2754 <__vector_13+0x6de>
                                LED3_OFF();
    273a:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <LED3_OFF>
                                // If there is no keypad user, using LCD to write the operating device
                                if (!eme_check) {
    273e:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    2742:	81 11       	cpse	r24, r1
    2744:	34 c0       	rjmp	.+104    	; 0x27ae <__vector_13+0x738>
                                        LCD_Clear();
    2746:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                        LCD_Write_String("Lamp(4) Closed");
    274a:	87 e7       	ldi	r24, 0x77	; 119
    274c:	94 e0       	ldi	r25, 0x04	; 4
    274e:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
    2752:	2d c0       	rjmp	.+90     	; 0x27ae <__vector_13+0x738>
                                }
                        }
                        // Close fifth lamp
                        else if (UART_GetValue == '5') {
    2754:	85 33       	cpi	r24, 0x35	; 53
    2756:	69 f4       	brne	.+26     	; 0x2772 <__vector_13+0x6fc>
                                LED4_OFF();
    2758:	0e 94 22 0d 	call	0x1a44	; 0x1a44 <LED4_OFF>
                                // If there is no keypad user, using LCD to write the operating device
                                if (!eme_check) {
    275c:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    2760:	81 11       	cpse	r24, r1
    2762:	25 c0       	rjmp	.+74     	; 0x27ae <__vector_13+0x738>
                                        LCD_Clear();
    2764:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                        LCD_Write_String("Lamp(5) Closed");
    2768:	86 e8       	ldi	r24, 0x86	; 134
    276a:	94 e0       	ldi	r25, 0x04	; 4
    276c:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
    2770:	1e c0       	rjmp	.+60     	; 0x27ae <__vector_13+0x738>
                                }
                        }
                        // Close all lamps
                        else if (UART_GetValue == '6') {
    2772:	86 33       	cpi	r24, 0x36	; 54
    2774:	e1 f4       	brne	.+56     	; 0x27ae <__vector_13+0x738>
                                LED0_OFF();
    2776:	0e 94 b2 0c 	call	0x1964	; 0x1964 <LED0_OFF>
                                LED1_OFF();
    277a:	0e 94 ce 0c 	call	0x199c	; 0x199c <LED1_OFF>
                                LED2_OFF();
    277e:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <LED2_OFF>
                                LED3_OFF();
    2782:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <LED3_OFF>
                                LED4_OFF();
    2786:	0e 94 22 0d 	call	0x1a44	; 0x1a44 <LED4_OFF>
                                LCD_Clear();
    278a:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                // If there is no keypad user, using LCD to write the operating device
                                if (!eme_check) {
    278e:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    2792:	81 11       	cpse	r24, r1
    2794:	0c c0       	rjmp	.+24     	; 0x27ae <__vector_13+0x738>
                                        LCD_Write_String("All Lamps Are");
    2796:	89 e0       	ldi	r24, 0x09	; 9
    2798:	94 e0       	ldi	r25, 0x04	; 4
    279a:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                                        LCD_Goto(1, 0);
    279e:	60 e0       	ldi	r22, 0x00	; 0
    27a0:	81 e0       	ldi	r24, 0x01	; 1
    27a2:	0e 94 83 0c 	call	0x1906	; 0x1906 <LCD_Goto>
                                        LCD_Write_String("Closed");
    27a6:	82 e5       	ldi	r24, 0x52	; 82
    27a8:	94 e0       	ldi	r25, 0x04	; 4
    27aa:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                                }
                        }
                        // If there is no keypad user, using LCD to write & clear the operating device
                        if (!eme_check)
    27ae:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    27b2:	81 11       	cpse	r24, r1
    27b4:	72 c4       	rjmp	.+2276   	; 0x309a <__vector_13+0x1024>
                                Timer2_SetDelay(2000); // Clearing LCD after 2 seconds using timer 2
    27b6:	60 ed       	ldi	r22, 0xD0	; 208
    27b8:	77 e0       	ldi	r23, 0x07	; 7
    27ba:	80 e0       	ldi	r24, 0x00	; 0
    27bc:	90 e0       	ldi	r25, 0x00	; 0
    27be:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <Timer2_SetDelay>
    27c2:	6b c4       	rjmp	.+2262   	; 0x309a <__vector_13+0x1024>
                } else if (UART_GetValue == '5') {
    27c4:	85 33       	cpi	r24, 0x35	; 53
    27c6:	09 f0       	breq	.+2      	; 0x27ca <__vector_13+0x754>
    27c8:	cf c0       	rjmp	.+414    	; 0x2968 <__vector_13+0x8f2>
                        /*Dimmer circuit*/
                        UART_TX_Str("\r\n");
    27ca:	8a ed       	ldi	r24, 0xDA	; 218
    27cc:	92 e0       	ldi	r25, 0x02	; 2
    27ce:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    27d2:	8a ed       	ldi	r24, 0xDA	; 218
    27d4:	92 e0       	ldi	r25, 0x02	; 2
    27d6:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("Please enter the percentage of the lamp\r\n");
    27da:	85 e9       	ldi	r24, 0x95	; 149
    27dc:	94 e0       	ldi	r25, 0x04	; 4
    27de:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    27e2:	8a ed       	ldi	r24, 0xDA	; 218
    27e4:	92 e0       	ldi	r25, 0x02	; 2
    27e6:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>

                        Dimmer_Value = 0; // making sure that dimmer value equal 0
    27ea:	10 92 e9 07 	sts	0x07E9, r1	; 0x8007e9 <Dimmer_Value>
    27ee:	10 92 ea 07 	sts	0x07EA, r1	; 0x8007ea <Dimmer_Value+0x1>
    27f2:	10 92 eb 07 	sts	0x07EB, r1	; 0x8007eb <Dimmer_Value+0x2>
    27f6:	10 92 ec 07 	sts	0x07EC, r1	; 0x8007ec <Dimmer_Value+0x3>

                        // Taking the dimmer value as characters 
                        for (Uint8 i = 0; i < 3; i++) {
    27fa:	00 e0       	ldi	r16, 0x00	; 0
    27fc:	38 c0       	rjmp	.+112    	; 0x286e <__vector_13+0x7f8>
                                while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    27fe:	5f 9b       	sbis	0x0b, 7	; 11
    2800:	fe cf       	rjmp	.-4      	; 0x27fe <__vector_13+0x788>
                                Dimmer_Array[i] = UART_RX_Char(); // Receiving dimmer character values
    2802:	e0 2e       	mov	r14, r16
    2804:	f1 2c       	mov	r15, r1
    2806:	0e 94 37 10 	call	0x206e	; 0x206e <UART_RX_Char>
    280a:	18 2f       	mov	r17, r24
    280c:	f7 01       	movw	r30, r14
    280e:	e3 51       	subi	r30, 0x13	; 19
    2810:	f8 4f       	sbci	r31, 0xF8	; 248
    2812:	80 83       	st	Z, r24

                                // Converting Dimmer value from characters to integer to send it as duty cycle to timer(0) 
                                if (Dimmer_Array[i] >= 48 && Dimmer_Array[i] <= 57) {
    2814:	80 ed       	ldi	r24, 0xD0	; 208
    2816:	81 0f       	add	r24, r17
    2818:	8a 30       	cpi	r24, 0x0A	; 10
    281a:	38 f5       	brcc	.+78     	; 0x286a <__vector_13+0x7f4>
                                        Dimmer_Value = Dimmer_Value * 10 + (Dimmer_Array[i] - 48);
    281c:	20 e0       	ldi	r18, 0x00	; 0
    281e:	30 e0       	ldi	r19, 0x00	; 0
    2820:	40 e2       	ldi	r20, 0x20	; 32
    2822:	51 e4       	ldi	r21, 0x41	; 65
    2824:	60 91 e9 07 	lds	r22, 0x07E9	; 0x8007e9 <Dimmer_Value>
    2828:	70 91 ea 07 	lds	r23, 0x07EA	; 0x8007ea <Dimmer_Value+0x1>
    282c:	80 91 eb 07 	lds	r24, 0x07EB	; 0x8007eb <Dimmer_Value+0x2>
    2830:	90 91 ec 07 	lds	r25, 0x07EC	; 0x8007ec <Dimmer_Value+0x3>
    2834:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <__mulsf3>
    2838:	6b 01       	movw	r12, r22
    283a:	7c 01       	movw	r14, r24
    283c:	61 2f       	mov	r22, r17
    283e:	70 e0       	ldi	r23, 0x00	; 0
    2840:	60 53       	subi	r22, 0x30	; 48
    2842:	71 09       	sbc	r23, r1
    2844:	07 2e       	mov	r0, r23
    2846:	00 0c       	add	r0, r0
    2848:	88 0b       	sbc	r24, r24
    284a:	99 0b       	sbc	r25, r25
    284c:	0e 94 b6 1c 	call	0x396c	; 0x396c <__floatsisf>
    2850:	a7 01       	movw	r20, r14
    2852:	96 01       	movw	r18, r12
    2854:	0e 94 a2 1b 	call	0x3744	; 0x3744 <__addsf3>
    2858:	60 93 e9 07 	sts	0x07E9, r22	; 0x8007e9 <Dimmer_Value>
    285c:	70 93 ea 07 	sts	0x07EA, r23	; 0x8007ea <Dimmer_Value+0x1>
    2860:	80 93 eb 07 	sts	0x07EB, r24	; 0x8007eb <Dimmer_Value+0x2>
    2864:	90 93 ec 07 	sts	0x07EC, r25	; 0x8007ec <Dimmer_Value+0x3>
    2868:	01 c0       	rjmp	.+2      	; 0x286c <__vector_13+0x7f6>
                                }
                                // if the value of character not from 48 to 57 (which is the number characters in ASCII table) these means that user entered the desired value and want to  escape other values 
                                else {
                                        i = 5; // Exiting the for loop in which user enter the character values of dimmer circuit
    286a:	05 e0       	ldi	r16, 0x05	; 5
                        UART_TX_Str("\r\n");

                        Dimmer_Value = 0; // making sure that dimmer value equal 0

                        // Taking the dimmer value as characters 
                        for (Uint8 i = 0; i < 3; i++) {
    286c:	0f 5f       	subi	r16, 0xFF	; 255
    286e:	03 30       	cpi	r16, 0x03	; 3
    2870:	30 f2       	brcs	.-116    	; 0x27fe <__vector_13+0x788>
                                }

                        }

                        // If there is no keypad user, using LCD to write the operating device
                        if (!eme_check) {
    2872:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    2876:	81 11       	cpse	r24, r1
    2878:	23 c0       	rjmp	.+70     	; 0x28c0 <__vector_13+0x84a>
                                LCD_Clear();
    287a:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                LCD_Write_String("Lamp ON!");
    287e:	8f eb       	ldi	r24, 0xBF	; 191
    2880:	94 e0       	ldi	r25, 0x04	; 4
    2882:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                                LCD_Goto(1, 0);
    2886:	60 e0       	ldi	r22, 0x00	; 0
    2888:	81 e0       	ldi	r24, 0x01	; 1
    288a:	0e 94 83 0c 	call	0x1906	; 0x1906 <LCD_Goto>
                                LCD_Write_String("Percentage:");
    288e:	88 ec       	ldi	r24, 0xC8	; 200
    2890:	94 e0       	ldi	r25, 0x04	; 4
    2892:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                                LCD_Write_Integer(Dimmer_Value);
    2896:	60 91 e9 07 	lds	r22, 0x07E9	; 0x8007e9 <Dimmer_Value>
    289a:	70 91 ea 07 	lds	r23, 0x07EA	; 0x8007ea <Dimmer_Value+0x1>
    289e:	80 91 eb 07 	lds	r24, 0x07EB	; 0x8007eb <Dimmer_Value+0x2>
    28a2:	90 91 ec 07 	lds	r25, 0x07EC	; 0x8007ec <Dimmer_Value+0x3>
    28a6:	0e 94 85 1c 	call	0x390a	; 0x390a <__fixunssfsi>
    28aa:	0e 94 0c 0c 	call	0x1818	; 0x1818 <LCD_Write_Integer>
                                LCD_Write_Char('%');
    28ae:	85 e2       	ldi	r24, 0x25	; 37
    28b0:	0e 94 b8 0b 	call	0x1770	; 0x1770 <LCD_Write_Char>
                                Timer2_SetDelay(2000);
    28b4:	60 ed       	ldi	r22, 0xD0	; 208
    28b6:	77 e0       	ldi	r23, 0x07	; 7
    28b8:	80 e0       	ldi	r24, 0x00	; 0
    28ba:	90 e0       	ldi	r25, 0x00	; 0
    28bc:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <Timer2_SetDelay>
                        }

                        // To avoid twitch of dimmer lamp
                        if (Dimmer_Value >= 58 && Dimmer_Value <= 60) {
    28c0:	c0 90 e9 07 	lds	r12, 0x07E9	; 0x8007e9 <Dimmer_Value>
    28c4:	d0 90 ea 07 	lds	r13, 0x07EA	; 0x8007ea <Dimmer_Value+0x1>
    28c8:	e0 90 eb 07 	lds	r14, 0x07EB	; 0x8007eb <Dimmer_Value+0x2>
    28cc:	f0 90 ec 07 	lds	r15, 0x07EC	; 0x8007ec <Dimmer_Value+0x3>
    28d0:	20 e0       	ldi	r18, 0x00	; 0
    28d2:	30 e0       	ldi	r19, 0x00	; 0
    28d4:	48 e6       	ldi	r20, 0x68	; 104
    28d6:	52 e4       	ldi	r21, 0x42	; 66
    28d8:	c7 01       	movw	r24, r14
    28da:	b6 01       	movw	r22, r12
    28dc:	0e 94 66 1d 	call	0x3acc	; 0x3acc <__gesf2>
    28e0:	88 23       	and	r24, r24
    28e2:	bc f0       	brlt	.+46     	; 0x2912 <__vector_13+0x89c>
    28e4:	20 e0       	ldi	r18, 0x00	; 0
    28e6:	30 e0       	ldi	r19, 0x00	; 0
    28e8:	40 e7       	ldi	r20, 0x70	; 112
    28ea:	52 e4       	ldi	r21, 0x42	; 66
    28ec:	c7 01       	movw	r24, r14
    28ee:	b6 01       	movw	r22, r12
    28f0:	0e 94 0e 1c 	call	0x381c	; 0x381c <__cmpsf2>
    28f4:	18 16       	cp	r1, r24
    28f6:	6c f0       	brlt	.+26     	; 0x2912 <__vector_13+0x89c>
                                Dimmer_Value = 55;
    28f8:	80 e0       	ldi	r24, 0x00	; 0
    28fa:	90 e0       	ldi	r25, 0x00	; 0
    28fc:	ac e5       	ldi	r26, 0x5C	; 92
    28fe:	b2 e4       	ldi	r27, 0x42	; 66
    2900:	80 93 e9 07 	sts	0x07E9, r24	; 0x8007e9 <Dimmer_Value>
    2904:	90 93 ea 07 	sts	0x07EA, r25	; 0x8007ea <Dimmer_Value+0x1>
    2908:	a0 93 eb 07 	sts	0x07EB, r26	; 0x8007eb <Dimmer_Value+0x2>
    290c:	b0 93 ec 07 	sts	0x07EC, r27	; 0x8007ec <Dimmer_Value+0x3>
    2910:	20 c0       	rjmp	.+64     	; 0x2952 <__vector_13+0x8dc>
                        } else if (Dimmer_Value > 60 && Dimmer_Value <= 62) {
    2912:	20 e0       	ldi	r18, 0x00	; 0
    2914:	30 e0       	ldi	r19, 0x00	; 0
    2916:	40 e7       	ldi	r20, 0x70	; 112
    2918:	52 e4       	ldi	r21, 0x42	; 66
    291a:	c7 01       	movw	r24, r14
    291c:	b6 01       	movw	r22, r12
    291e:	0e 94 66 1d 	call	0x3acc	; 0x3acc <__gesf2>
    2922:	18 16       	cp	r1, r24
    2924:	b4 f4       	brge	.+44     	; 0x2952 <__vector_13+0x8dc>
    2926:	20 e0       	ldi	r18, 0x00	; 0
    2928:	30 e0       	ldi	r19, 0x00	; 0
    292a:	48 e7       	ldi	r20, 0x78	; 120
    292c:	52 e4       	ldi	r21, 0x42	; 66
    292e:	c7 01       	movw	r24, r14
    2930:	b6 01       	movw	r22, r12
    2932:	0e 94 0e 1c 	call	0x381c	; 0x381c <__cmpsf2>
    2936:	18 16       	cp	r1, r24
    2938:	64 f0       	brlt	.+24     	; 0x2952 <__vector_13+0x8dc>
                                Dimmer_Value = 65;
    293a:	80 e0       	ldi	r24, 0x00	; 0
    293c:	90 e0       	ldi	r25, 0x00	; 0
    293e:	a2 e8       	ldi	r26, 0x82	; 130
    2940:	b2 e4       	ldi	r27, 0x42	; 66
    2942:	80 93 e9 07 	sts	0x07E9, r24	; 0x8007e9 <Dimmer_Value>
    2946:	90 93 ea 07 	sts	0x07EA, r25	; 0x8007ea <Dimmer_Value+0x1>
    294a:	a0 93 eb 07 	sts	0x07EB, r26	; 0x8007eb <Dimmer_Value+0x2>
    294e:	b0 93 ec 07 	sts	0x07EC, r27	; 0x8007ec <Dimmer_Value+0x3>
                        }

                        PWM0_Gen(Dimmer_Value); // Sending dimmer as duty cycle to timer(0)
    2952:	60 91 e9 07 	lds	r22, 0x07E9	; 0x8007e9 <Dimmer_Value>
    2956:	70 91 ea 07 	lds	r23, 0x07EA	; 0x8007ea <Dimmer_Value+0x1>
    295a:	80 91 eb 07 	lds	r24, 0x07EB	; 0x8007eb <Dimmer_Value+0x2>
    295e:	90 91 ec 07 	lds	r25, 0x07EC	; 0x8007ec <Dimmer_Value+0x3>
    2962:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <PWM0_Gen>
    2966:	99 c3       	rjmp	.+1842   	; 0x309a <__vector_13+0x1024>
                } else if (UART_GetValue == '6') {
    2968:	86 33       	cpi	r24, 0x36	; 54
    296a:	09 f0       	breq	.+2      	; 0x296e <__vector_13+0x8f8>
    296c:	50 c0       	rjmp	.+160    	; 0x2a0e <__vector_13+0x998>
                        /*--------------->Display temperature<----------------*/
                        // Declaring temperature array which take the temperature value from temperature integer that take its value from the temperature
                        Uint8 Temp_array[2] = {
    296e:	1a 86       	std	Y+10, r1	; 0x0a
    2970:	19 86       	std	Y+9, r1	; 0x09
                                0
                        };
                        Uint8 Temp_Divide = Temp; // Saving the value in other variable to do some operations
    2972:	90 91 ce 07 	lds	r25, 0x07CE	; 0x8007ce <__data_end>

                        // Converting the integer value to characters and saved in the temperature array
                        for (Uint8 i = 0; i < 2; i++) {
    2976:	20 e0       	ldi	r18, 0x00	; 0
    2978:	17 c0       	rjmp	.+46     	; 0x29a8 <__vector_13+0x932>
                                Temp_array[i] = Temp_Divide % 10;
    297a:	e9 e0       	ldi	r30, 0x09	; 9
    297c:	f0 e0       	ldi	r31, 0x00	; 0
    297e:	ec 0f       	add	r30, r28
    2980:	fd 1f       	adc	r31, r29
    2982:	e2 0f       	add	r30, r18
    2984:	f1 1d       	adc	r31, r1
    2986:	8d ec       	ldi	r24, 0xCD	; 205
    2988:	98 9f       	mul	r25, r24
    298a:	81 2d       	mov	r24, r1
    298c:	11 24       	eor	r1, r1
    298e:	86 95       	lsr	r24
    2990:	86 95       	lsr	r24
    2992:	86 95       	lsr	r24
    2994:	48 2f       	mov	r20, r24
    2996:	44 0f       	add	r20, r20
    2998:	34 2f       	mov	r19, r20
    299a:	33 0f       	add	r19, r19
    299c:	33 0f       	add	r19, r19
    299e:	34 0f       	add	r19, r20
    29a0:	93 1b       	sub	r25, r19
    29a2:	90 83       	st	Z, r25
                                Temp_Divide /= 10;
    29a4:	98 2f       	mov	r25, r24
                                0
                        };
                        Uint8 Temp_Divide = Temp; // Saving the value in other variable to do some operations

                        // Converting the integer value to characters and saved in the temperature array
                        for (Uint8 i = 0; i < 2; i++) {
    29a6:	2f 5f       	subi	r18, 0xFF	; 255
    29a8:	22 30       	cpi	r18, 0x02	; 2
    29aa:	38 f3       	brcs	.-50     	; 0x297a <__vector_13+0x904>
                                Temp_array[i] = Temp_Divide % 10;
                                Temp_Divide /= 10;
                        }

                        // Display the temperature
                        UART_TX_Str("\r\n");
    29ac:	8a ed       	ldi	r24, 0xDA	; 218
    29ae:	92 e0       	ldi	r25, 0x02	; 2
    29b0:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    29b4:	8a ed       	ldi	r24, 0xDA	; 218
    29b6:	92 e0       	ldi	r25, 0x02	; 2
    29b8:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("Temperature:\r\n");
    29bc:	84 ed       	ldi	r24, 0xD4	; 212
    29be:	94 e0       	ldi	r25, 0x04	; 4
    29c0:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Char(Temp_array[1] + 48);
    29c4:	8a 85       	ldd	r24, Y+10	; 0x0a
    29c6:	80 5d       	subi	r24, 0xD0	; 208
    29c8:	0e 94 20 10 	call	0x2040	; 0x2040 <UART_TX_Char>
                        UART_TX_Char(Temp_array[0] + 48);
    29cc:	89 85       	ldd	r24, Y+9	; 0x09
    29ce:	80 5d       	subi	r24, 0xD0	; 208
    29d0:	0e 94 20 10 	call	0x2040	; 0x2040 <UART_TX_Char>
                        UART_TX_Str("\r\n");
    29d4:	8a ed       	ldi	r24, 0xDA	; 218
    29d6:	92 e0       	ldi	r25, 0x02	; 2
    29d8:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>

                        // If there is no keypad user, using LCD to write the operating device
                        if (!eme_check) {
    29dc:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    29e0:	81 11       	cpse	r24, r1
    29e2:	5b c3       	rjmp	.+1718   	; 0x309a <__vector_13+0x1024>
                                LCD_Clear();
    29e4:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                LCD_Write_String("Temperature:");
    29e8:	8e e0       	ldi	r24, 0x0E	; 14
    29ea:	91 e0       	ldi	r25, 0x01	; 1
    29ec:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                                LCD_Write_Integer(Temp);
    29f0:	60 91 ce 07 	lds	r22, 0x07CE	; 0x8007ce <__data_end>
    29f4:	70 91 cf 07 	lds	r23, 0x07CF	; 0x8007cf <__data_end+0x1>
    29f8:	80 e0       	ldi	r24, 0x00	; 0
    29fa:	90 e0       	ldi	r25, 0x00	; 0
    29fc:	0e 94 0c 0c 	call	0x1818	; 0x1818 <LCD_Write_Integer>
                                Timer2_SetDelay(2000);
    2a00:	60 ed       	ldi	r22, 0xD0	; 208
    2a02:	77 e0       	ldi	r23, 0x07	; 7
    2a04:	80 e0       	ldi	r24, 0x00	; 0
    2a06:	90 e0       	ldi	r25, 0x00	; 0
    2a08:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <Timer2_SetDelay>
    2a0c:	46 c3       	rjmp	.+1676   	; 0x309a <__vector_13+0x1024>
                        }
                } else if (UART_GetValue == '7') {
    2a0e:	87 33       	cpi	r24, 0x37	; 55
    2a10:	09 f0       	breq	.+2      	; 0x2a14 <__vector_13+0x99e>
    2a12:	10 c1       	rjmp	.+544    	; 0x2c34 <__vector_13+0xbbe>
                        // Add new user

                        /*-------------->Determine The Type of User<---------------*/
                        UART_TX_Str("\r\n");
    2a14:	8a ed       	ldi	r24, 0xDA	; 218
    2a16:	92 e0       	ldi	r25, 0x02	; 2
    2a18:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    2a1c:	8a ed       	ldi	r24, 0xDA	; 218
    2a1e:	92 e0       	ldi	r25, 0x02	; 2
    2a20:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("1.Keypad user\r\n");
    2a24:	83 ee       	ldi	r24, 0xE3	; 227
    2a26:	94 e0       	ldi	r25, 0x04	; 4
    2a28:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("2.PC user\r\n");
    2a2c:	83 ef       	ldi	r24, 0xF3	; 243
    2a2e:	94 e0       	ldi	r25, 0x04	; 4
    2a30:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("3.AD user\r\n");
    2a34:	8f ef       	ldi	r24, 0xFF	; 255
    2a36:	94 e0       	ldi	r25, 0x04	; 4
    2a38:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>

                        while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    2a3c:	5f 9b       	sbis	0x0b, 7	; 11
    2a3e:	fe cf       	rjmp	.-4      	; 0x2a3c <__vector_13+0x9c6>
                        UART_GetValue = UART_RX_Char(); // Receiving the command
    2a40:	0e 94 37 10 	call	0x206e	; 0x206e <UART_RX_Char>
    2a44:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <UART_GetValue>

                        if (UART_GetValue == '1') {
    2a48:	81 33       	cpi	r24, 0x31	; 49
    2a4a:	09 f0       	breq	.+2      	; 0x2a4e <__vector_13+0x9d8>
    2a4c:	4b c0       	rjmp	.+150    	; 0x2ae4 <__vector_13+0xa6e>
                                /*--------------->Adding Keypad User<-------------------*/
                                Uint8 j = 0;

                                /*----------------->Adding New Username<-----------------*/
                                UART_TX_Str("\r\n");
    2a4e:	8a ed       	ldi	r24, 0xDA	; 218
    2a50:	92 e0       	ldi	r25, 0x02	; 2
    2a52:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("\r\n");
    2a56:	8a ed       	ldi	r24, 0xDA	; 218
    2a58:	92 e0       	ldi	r25, 0x02	; 2
    2a5a:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("Please enter 4 numbers as username\r\n");
    2a5e:	8b e0       	ldi	r24, 0x0B	; 11
    2a60:	95 e0       	ldi	r25, 0x05	; 5
    2a62:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                for (Uint8 i = 0; i < 4; i++) {
    2a66:	10 e0       	ldi	r17, 0x00	; 0
    2a68:	0f c0       	rjmp	.+30     	; 0x2a88 <__vector_13+0xa12>
                                        j = i + 1;
    2a6a:	1f 5f       	subi	r17, 0xFF	; 255
                                        while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    2a6c:	5f 9b       	sbis	0x0b, 7	; 11
    2a6e:	fe cf       	rjmp	.-4      	; 0x2a6c <__vector_13+0x9f6>
                                        User[i] = UART_RX_Char(); // Receiving the character in username array
    2a70:	0e 94 37 10 	call	0x206e	; 0x206e <UART_RX_Char>
                                        EEPROM_WriteByte(0, j += KP_Counter, User[i]); // Adding the username in EEPROM
    2a74:	60 91 f1 07 	lds	r22, 0x07F1	; 0x8007f1 <KP_Counter>
    2a78:	61 0f       	add	r22, r17
    2a7a:	48 2f       	mov	r20, r24
    2a7c:	50 e0       	ldi	r21, 0x00	; 0
    2a7e:	70 e0       	ldi	r23, 0x00	; 0
    2a80:	80 e0       	ldi	r24, 0x00	; 0
    2a82:	90 e0       	ldi	r25, 0x00	; 0
    2a84:	0e 94 9e 04 	call	0x93c	; 0x93c <EEPROM_WriteByte>

                                /*----------------->Adding New Username<-----------------*/
                                UART_TX_Str("\r\n");
                                UART_TX_Str("\r\n");
                                UART_TX_Str("Please enter 4 numbers as username\r\n");
                                for (Uint8 i = 0; i < 4; i++) {
    2a88:	14 30       	cpi	r17, 0x04	; 4
    2a8a:	78 f3       	brcs	.-34     	; 0x2a6a <__vector_13+0x9f4>
                                        User[i] = UART_RX_Char(); // Receiving the character in username array
                                        EEPROM_WriteByte(0, j += KP_Counter, User[i]); // Adding the username in EEPROM
                                }

                                /*----------------->Adding New Password<-----------------*/
                                UART_TX_Str("\r\n");
    2a8c:	8a ed       	ldi	r24, 0xDA	; 218
    2a8e:	92 e0       	ldi	r25, 0x02	; 2
    2a90:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("\r\n");
    2a94:	8a ed       	ldi	r24, 0xDA	; 218
    2a96:	92 e0       	ldi	r25, 0x02	; 2
    2a98:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("Please enter 4 numbers as password\r\n");
    2a9c:	80 e3       	ldi	r24, 0x30	; 48
    2a9e:	95 e0       	ldi	r25, 0x05	; 5
    2aa0:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                for (Uint8 i = 0; i < 4; i++) {
    2aa4:	10 e0       	ldi	r17, 0x00	; 0
    2aa6:	0f c0       	rjmp	.+30     	; 0x2ac6 <__vector_13+0xa50>
                                        j = i + 1;
    2aa8:	1f 5f       	subi	r17, 0xFF	; 255
                                        while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    2aaa:	5f 9b       	sbis	0x0b, 7	; 11
    2aac:	fe cf       	rjmp	.-4      	; 0x2aaa <__vector_13+0xa34>
                                        Pass[i] = UART_RX_Char(); // Receiving the character in password array
    2aae:	0e 94 37 10 	call	0x206e	; 0x206e <UART_RX_Char>
                                        EEPROM_WriteByte(1, j += KP_Counter, Pass[i]); // Adding the password in EEPROM
    2ab2:	60 91 f1 07 	lds	r22, 0x07F1	; 0x8007f1 <KP_Counter>
    2ab6:	61 0f       	add	r22, r17
    2ab8:	48 2f       	mov	r20, r24
    2aba:	50 e0       	ldi	r21, 0x00	; 0
    2abc:	70 e0       	ldi	r23, 0x00	; 0
    2abe:	81 e0       	ldi	r24, 0x01	; 1
    2ac0:	90 e0       	ldi	r25, 0x00	; 0
    2ac2:	0e 94 9e 04 	call	0x93c	; 0x93c <EEPROM_WriteByte>

                                /*----------------->Adding New Password<-----------------*/
                                UART_TX_Str("\r\n");
                                UART_TX_Str("\r\n");
                                UART_TX_Str("Please enter 4 numbers as password\r\n");
                                for (Uint8 i = 0; i < 4; i++) {
    2ac6:	14 30       	cpi	r17, 0x04	; 4
    2ac8:	78 f3       	brcs	.-34     	; 0x2aa8 <__vector_13+0xa32>
                                        while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
                                        Pass[i] = UART_RX_Char(); // Receiving the character in password array
                                        EEPROM_WriteByte(1, j += KP_Counter, Pass[i]); // Adding the password in EEPROM
                                }

                                KP_Counter += 4; // Counter to determine the number of keypad users
    2aca:	40 91 f1 07 	lds	r20, 0x07F1	; 0x8007f1 <KP_Counter>
    2ace:	4c 5f       	subi	r20, 0xFC	; 252
    2ad0:	40 93 f1 07 	sts	0x07F1, r20	; 0x8007f1 <KP_Counter>
                                EEPROM_WriteByte(4, 0, KP_Counter); // Saving the counter in EEPROM
    2ad4:	50 e0       	ldi	r21, 0x00	; 0
    2ad6:	60 e0       	ldi	r22, 0x00	; 0
    2ad8:	70 e0       	ldi	r23, 0x00	; 0
    2ada:	84 e0       	ldi	r24, 0x04	; 4
    2adc:	90 e0       	ldi	r25, 0x00	; 0
    2ade:	0e 94 9e 04 	call	0x93c	; 0x93c <EEPROM_WriteByte>
    2ae2:	9b c0       	rjmp	.+310    	; 0x2c1a <__vector_13+0xba4>
                        } else if (UART_GetValue == '2') {
    2ae4:	82 33       	cpi	r24, 0x32	; 50
    2ae6:	09 f0       	breq	.+2      	; 0x2aea <__vector_13+0xa74>
    2ae8:	4b c0       	rjmp	.+150    	; 0x2b80 <__vector_13+0xb0a>
                                /*--------------->Adding PC User<-------------------*/
                                Uint8 j = 0;

                                /*----------------->Adding New Username<-----------------*/
                                UART_TX_Str("\r\n");
    2aea:	8a ed       	ldi	r24, 0xDA	; 218
    2aec:	92 e0       	ldi	r25, 0x02	; 2
    2aee:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("\r\n");
    2af2:	8a ed       	ldi	r24, 0xDA	; 218
    2af4:	92 e0       	ldi	r25, 0x02	; 2
    2af6:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("Please enter 4 numbers as username\r\n");
    2afa:	8b e0       	ldi	r24, 0x0B	; 11
    2afc:	95 e0       	ldi	r25, 0x05	; 5
    2afe:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                for (Uint8 i = 0; i < 4; i++) {
    2b02:	10 e0       	ldi	r17, 0x00	; 0
    2b04:	0f c0       	rjmp	.+30     	; 0x2b24 <__vector_13+0xaae>
                                        j = i + 1;
    2b06:	1f 5f       	subi	r17, 0xFF	; 255
                                        while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    2b08:	5f 9b       	sbis	0x0b, 7	; 11
    2b0a:	fe cf       	rjmp	.-4      	; 0x2b08 <__vector_13+0xa92>
                                        User[i] = UART_RX_Char(); // Receiving the character in username array
    2b0c:	0e 94 37 10 	call	0x206e	; 0x206e <UART_RX_Char>
                                        EEPROM_WriteByte(2, j += PC_Counter, User[i]); // Adding the username in EEPROM
    2b10:	60 91 f0 07 	lds	r22, 0x07F0	; 0x8007f0 <PC_Counter>
    2b14:	61 0f       	add	r22, r17
    2b16:	48 2f       	mov	r20, r24
    2b18:	50 e0       	ldi	r21, 0x00	; 0
    2b1a:	70 e0       	ldi	r23, 0x00	; 0
    2b1c:	82 e0       	ldi	r24, 0x02	; 2
    2b1e:	90 e0       	ldi	r25, 0x00	; 0
    2b20:	0e 94 9e 04 	call	0x93c	; 0x93c <EEPROM_WriteByte>

                                /*----------------->Adding New Username<-----------------*/
                                UART_TX_Str("\r\n");
                                UART_TX_Str("\r\n");
                                UART_TX_Str("Please enter 4 numbers as username\r\n");
                                for (Uint8 i = 0; i < 4; i++) {
    2b24:	14 30       	cpi	r17, 0x04	; 4
    2b26:	78 f3       	brcs	.-34     	; 0x2b06 <__vector_13+0xa90>
                                        User[i] = UART_RX_Char(); // Receiving the character in username array
                                        EEPROM_WriteByte(2, j += PC_Counter, User[i]); // Adding the username in EEPROM
                                }

                                /*----------------->Adding New Password<-----------------*/
                                UART_TX_Str("\r\n");
    2b28:	8a ed       	ldi	r24, 0xDA	; 218
    2b2a:	92 e0       	ldi	r25, 0x02	; 2
    2b2c:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("\r\n");
    2b30:	8a ed       	ldi	r24, 0xDA	; 218
    2b32:	92 e0       	ldi	r25, 0x02	; 2
    2b34:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("Please enter 4 numbers as password\r\n");
    2b38:	80 e3       	ldi	r24, 0x30	; 48
    2b3a:	95 e0       	ldi	r25, 0x05	; 5
    2b3c:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                for (Uint8 i = 0; i < 4; i++) {
    2b40:	10 e0       	ldi	r17, 0x00	; 0
    2b42:	0f c0       	rjmp	.+30     	; 0x2b62 <__vector_13+0xaec>
                                        j = i + 1;
    2b44:	1f 5f       	subi	r17, 0xFF	; 255
                                        while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    2b46:	5f 9b       	sbis	0x0b, 7	; 11
    2b48:	fe cf       	rjmp	.-4      	; 0x2b46 <__vector_13+0xad0>
                                        Pass[i] = UART_RX_Char(); // Receiving the character in password array
    2b4a:	0e 94 37 10 	call	0x206e	; 0x206e <UART_RX_Char>
                                        EEPROM_WriteByte(3, j += PC_Counter, Pass[i]); // Adding the password in EEPROM
    2b4e:	60 91 f0 07 	lds	r22, 0x07F0	; 0x8007f0 <PC_Counter>
    2b52:	61 0f       	add	r22, r17
    2b54:	48 2f       	mov	r20, r24
    2b56:	50 e0       	ldi	r21, 0x00	; 0
    2b58:	70 e0       	ldi	r23, 0x00	; 0
    2b5a:	83 e0       	ldi	r24, 0x03	; 3
    2b5c:	90 e0       	ldi	r25, 0x00	; 0
    2b5e:	0e 94 9e 04 	call	0x93c	; 0x93c <EEPROM_WriteByte>

                                /*----------------->Adding New Password<-----------------*/
                                UART_TX_Str("\r\n");
                                UART_TX_Str("\r\n");
                                UART_TX_Str("Please enter 4 numbers as password\r\n");
                                for (Uint8 i = 0; i < 4; i++) {
    2b62:	14 30       	cpi	r17, 0x04	; 4
    2b64:	78 f3       	brcs	.-34     	; 0x2b44 <__vector_13+0xace>
                                        while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
                                        Pass[i] = UART_RX_Char(); // Receiving the character in password array
                                        EEPROM_WriteByte(3, j += PC_Counter, Pass[i]); // Adding the password in EEPROM
                                }

                                PC_Counter += 4; // Counter to determine the number of PC users
    2b66:	40 91 f0 07 	lds	r20, 0x07F0	; 0x8007f0 <PC_Counter>
    2b6a:	4c 5f       	subi	r20, 0xFC	; 252
    2b6c:	40 93 f0 07 	sts	0x07F0, r20	; 0x8007f0 <PC_Counter>
                                EEPROM_WriteByte(4, 1, PC_Counter); // Saving the counter in EEPROM
    2b70:	50 e0       	ldi	r21, 0x00	; 0
    2b72:	61 e0       	ldi	r22, 0x01	; 1
    2b74:	70 e0       	ldi	r23, 0x00	; 0
    2b76:	84 e0       	ldi	r24, 0x04	; 4
    2b78:	90 e0       	ldi	r25, 0x00	; 0
    2b7a:	0e 94 9e 04 	call	0x93c	; 0x93c <EEPROM_WriteByte>
    2b7e:	4d c0       	rjmp	.+154    	; 0x2c1a <__vector_13+0xba4>
                        } else if (UART_GetValue == '3') {
    2b80:	83 33       	cpi	r24, 0x33	; 51
    2b82:	09 f0       	breq	.+2      	; 0x2b86 <__vector_13+0xb10>
    2b84:	4a c0       	rjmp	.+148    	; 0x2c1a <__vector_13+0xba4>
                                /*--------------->Adding Admin User<-------------------*/
                                Uint8 j = 0;

                                /*----------------->Adding New Username<-----------------*/
                                UART_TX_Str("\r\n");
    2b86:	8a ed       	ldi	r24, 0xDA	; 218
    2b88:	92 e0       	ldi	r25, 0x02	; 2
    2b8a:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("\r\n");
    2b8e:	8a ed       	ldi	r24, 0xDA	; 218
    2b90:	92 e0       	ldi	r25, 0x02	; 2
    2b92:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("Please enter 4 numbers as username\r\n");
    2b96:	8b e0       	ldi	r24, 0x0B	; 11
    2b98:	95 e0       	ldi	r25, 0x05	; 5
    2b9a:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                for (Uint8 i = 0; i < 4; i++) {
    2b9e:	10 e0       	ldi	r17, 0x00	; 0
    2ba0:	0f c0       	rjmp	.+30     	; 0x2bc0 <__vector_13+0xb4a>
                                        j = i + 1;
    2ba2:	1f 5f       	subi	r17, 0xFF	; 255
                                        while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    2ba4:	5f 9b       	sbis	0x0b, 7	; 11
    2ba6:	fe cf       	rjmp	.-4      	; 0x2ba4 <__vector_13+0xb2e>
                                        User[i] = UART_RX_Char(); // Receiving the character in username array
    2ba8:	0e 94 37 10 	call	0x206e	; 0x206e <UART_RX_Char>
                                        EEPROM_WriteByte(5, j += AD_Counter, User[i]); // Adding the username in EEPROM
    2bac:	60 91 70 00 	lds	r22, 0x0070	; 0x800070 <AD_Counter>
    2bb0:	61 0f       	add	r22, r17
    2bb2:	48 2f       	mov	r20, r24
    2bb4:	50 e0       	ldi	r21, 0x00	; 0
    2bb6:	70 e0       	ldi	r23, 0x00	; 0
    2bb8:	85 e0       	ldi	r24, 0x05	; 5
    2bba:	90 e0       	ldi	r25, 0x00	; 0
    2bbc:	0e 94 9e 04 	call	0x93c	; 0x93c <EEPROM_WriteByte>

                                /*----------------->Adding New Username<-----------------*/
                                UART_TX_Str("\r\n");
                                UART_TX_Str("\r\n");
                                UART_TX_Str("Please enter 4 numbers as username\r\n");
                                for (Uint8 i = 0; i < 4; i++) {
    2bc0:	14 30       	cpi	r17, 0x04	; 4
    2bc2:	78 f3       	brcs	.-34     	; 0x2ba2 <__vector_13+0xb2c>
                                        User[i] = UART_RX_Char(); // Receiving the character in username array
                                        EEPROM_WriteByte(5, j += AD_Counter, User[i]); // Adding the username in EEPROM
                                }

                                /*----------------->Adding New Password<-----------------*/
                                UART_TX_Str("\r\n");
    2bc4:	8a ed       	ldi	r24, 0xDA	; 218
    2bc6:	92 e0       	ldi	r25, 0x02	; 2
    2bc8:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("\r\n");
    2bcc:	8a ed       	ldi	r24, 0xDA	; 218
    2bce:	92 e0       	ldi	r25, 0x02	; 2
    2bd0:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("Please enter 4 numbers as password\r\n");
    2bd4:	80 e3       	ldi	r24, 0x30	; 48
    2bd6:	95 e0       	ldi	r25, 0x05	; 5
    2bd8:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                for (Uint8 i = 0; i < 4; i++) {
    2bdc:	10 e0       	ldi	r17, 0x00	; 0
    2bde:	0f c0       	rjmp	.+30     	; 0x2bfe <__vector_13+0xb88>
                                        j = i + 1;
    2be0:	1f 5f       	subi	r17, 0xFF	; 255
                                        while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    2be2:	5f 9b       	sbis	0x0b, 7	; 11
    2be4:	fe cf       	rjmp	.-4      	; 0x2be2 <__vector_13+0xb6c>
                                        Pass[i] = UART_RX_Char(); // Receiving the character in password array
    2be6:	0e 94 37 10 	call	0x206e	; 0x206e <UART_RX_Char>
                                        EEPROM_WriteByte(6, j += AD_Counter, Pass[i]); // Adding the password in EEPROM
    2bea:	60 91 70 00 	lds	r22, 0x0070	; 0x800070 <AD_Counter>
    2bee:	61 0f       	add	r22, r17
    2bf0:	48 2f       	mov	r20, r24
    2bf2:	50 e0       	ldi	r21, 0x00	; 0
    2bf4:	70 e0       	ldi	r23, 0x00	; 0
    2bf6:	86 e0       	ldi	r24, 0x06	; 6
    2bf8:	90 e0       	ldi	r25, 0x00	; 0
    2bfa:	0e 94 9e 04 	call	0x93c	; 0x93c <EEPROM_WriteByte>

                                /*----------------->Adding New Password<-----------------*/
                                UART_TX_Str("\r\n");
                                UART_TX_Str("\r\n");
                                UART_TX_Str("Please enter 4 numbers as password\r\n");
                                for (Uint8 i = 0; i < 4; i++) {
    2bfe:	14 30       	cpi	r17, 0x04	; 4
    2c00:	78 f3       	brcs	.-34     	; 0x2be0 <__vector_13+0xb6a>
                                        while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
                                        Pass[i] = UART_RX_Char(); // Receiving the character in password array
                                        EEPROM_WriteByte(6, j += AD_Counter, Pass[i]); // Adding the password in EEPROM
                                }

                                AD_Counter += 4; // Counter to determine the number of PC users
    2c02:	40 91 70 00 	lds	r20, 0x0070	; 0x800070 <AD_Counter>
    2c06:	4c 5f       	subi	r20, 0xFC	; 252
    2c08:	40 93 70 00 	sts	0x0070, r20	; 0x800070 <AD_Counter>
                                EEPROM_WriteByte(4, 2, AD_Counter); // Saving the counter in EEPROM
    2c0c:	50 e0       	ldi	r21, 0x00	; 0
    2c0e:	62 e0       	ldi	r22, 0x02	; 2
    2c10:	70 e0       	ldi	r23, 0x00	; 0
    2c12:	84 e0       	ldi	r24, 0x04	; 4
    2c14:	90 e0       	ldi	r25, 0x00	; 0
    2c16:	0e 94 9e 04 	call	0x93c	; 0x93c <EEPROM_WriteByte>
                        }

                        /*------------>Added Successfully<-------------------*/
                        UART_TX_Str("\r\n");
    2c1a:	8a ed       	ldi	r24, 0xDA	; 218
    2c1c:	92 e0       	ldi	r25, 0x02	; 2
    2c1e:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    2c22:	8a ed       	ldi	r24, 0xDA	; 218
    2c24:	92 e0       	ldi	r25, 0x02	; 2
    2c26:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("User added successfully\r\n");
    2c2a:	85 e5       	ldi	r24, 0x55	; 85
    2c2c:	95 e0       	ldi	r25, 0x05	; 5
    2c2e:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
    2c32:	33 c2       	rjmp	.+1126   	; 0x309a <__vector_13+0x1024>
                } else if (UART_GetValue == '8') {
    2c34:	88 33       	cpi	r24, 0x38	; 56
    2c36:	09 f0       	breq	.+2      	; 0x2c3a <__vector_13+0xbc4>
    2c38:	11 c2       	rjmp	.+1058   	; 0x305c <__vector_13+0xfe6>
                        // Delete an exist user
                        Uint8 j = 0;
                        UART_TX_Str("\r\n");
    2c3a:	8a ed       	ldi	r24, 0xDA	; 218
    2c3c:	92 e0       	ldi	r25, 0x02	; 2
    2c3e:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    2c42:	8a ed       	ldi	r24, 0xDA	; 218
    2c44:	92 e0       	ldi	r25, 0x02	; 2
    2c46:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("Do you want to delete keypad user , PC user or Admin user\r\n");
    2c4a:	8f e6       	ldi	r24, 0x6F	; 111
    2c4c:	95 e0       	ldi	r25, 0x05	; 5
    2c4e:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("1.Keypad User\r\n");
    2c52:	8b ea       	ldi	r24, 0xAB	; 171
    2c54:	95 e0       	ldi	r25, 0x05	; 5
    2c56:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("2.PC User\r\n");
    2c5a:	8b eb       	ldi	r24, 0xBB	; 187
    2c5c:	95 e0       	ldi	r25, 0x05	; 5
    2c5e:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("3.AD User\r\n");
    2c62:	87 ec       	ldi	r24, 0xC7	; 199
    2c64:	95 e0       	ldi	r25, 0x05	; 5
    2c66:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>

                        while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    2c6a:	5f 9b       	sbis	0x0b, 7	; 11
    2c6c:	fe cf       	rjmp	.-4      	; 0x2c6a <__vector_13+0xbf4>
                        UART_GetValue = UART_RX_Char(); // Receiving the command
    2c6e:	0e 94 37 10 	call	0x206e	; 0x206e <UART_RX_Char>
    2c72:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <UART_GetValue>

                        /*--------------->Deleting Keypad User<-------------------*/
                        if (UART_GetValue == '1') {
    2c76:	81 33       	cpi	r24, 0x31	; 49
    2c78:	09 f0       	breq	.+2      	; 0x2c7c <__vector_13+0xc06>
    2c7a:	9b c0       	rjmp	.+310    	; 0x2db2 <__vector_13+0xd3c>
                                UART_TX_Str("\r\n");
    2c7c:	8a ed       	ldi	r24, 0xDA	; 218
    2c7e:	92 e0       	ldi	r25, 0x02	; 2
    2c80:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("\r\n");
    2c84:	8a ed       	ldi	r24, 0xDA	; 218
    2c86:	92 e0       	ldi	r25, 0x02	; 2
    2c88:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("Please enter the KP username\r\n");
    2c8c:	83 ed       	ldi	r24, 0xD3	; 211
    2c8e:	95 e0       	ldi	r25, 0x05	; 5
    2c90:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>

                                for (Uint8 i = 0; i < 4; i++) {
    2c94:	10 e0       	ldi	r17, 0x00	; 0
    2c96:	0e c0       	rjmp	.+28     	; 0x2cb4 <__vector_13+0xc3e>
                                        while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    2c98:	5f 9b       	sbis	0x0b, 7	; 11
    2c9a:	fe cf       	rjmp	.-4      	; 0x2c98 <__vector_13+0xc22>
                                        User[i] = UART_RX_Char(); // Receiving the character in username array
    2c9c:	e1 2e       	mov	r14, r17
    2c9e:	f1 2c       	mov	r15, r1
    2ca0:	0e 94 37 10 	call	0x206e	; 0x206e <UART_RX_Char>
    2ca4:	e1 e0       	ldi	r30, 0x01	; 1
    2ca6:	f0 e0       	ldi	r31, 0x00	; 0
    2ca8:	ec 0f       	add	r30, r28
    2caa:	fd 1f       	adc	r31, r29
    2cac:	ee 0d       	add	r30, r14
    2cae:	ff 1d       	adc	r31, r15
    2cb0:	80 83       	st	Z, r24
                        if (UART_GetValue == '1') {
                                UART_TX_Str("\r\n");
                                UART_TX_Str("\r\n");
                                UART_TX_Str("Please enter the KP username\r\n");

                                for (Uint8 i = 0; i < 4; i++) {
    2cb2:	1f 5f       	subi	r17, 0xFF	; 255
    2cb4:	14 30       	cpi	r17, 0x04	; 4
    2cb6:	80 f3       	brcs	.-32     	; 0x2c98 <__vector_13+0xc22>
    2cb8:	10 e0       	ldi	r17, 0x00	; 0
    2cba:	f1 2c       	mov	r15, r1
    2cbc:	74 c0       	rjmp	.+232    	; 0x2da6 <__vector_13+0xd30>
                                }

                                /*---------------->Seaching For The User Want To Be Deleted<---------------------*/
                                for (Uint8 Check_Counter = 0; Check_Counter <= KP_Counter; Check_Counter += 4) {
                                        /*----------------->Username Check<------------------*/
                                        if (User[0] == EEPROM_ReadByte(0, Check_Counter + 1) && User[1] == EEPROM_ReadByte(0, Check_Counter + 2) && User[2] == EEPROM_ReadByte(0, Check_Counter + 3) && User[3] == EEPROM_ReadByte(0, Check_Counter + 4)) {
    2cbe:	a9 80       	ldd	r10, Y+1	; 0x01
    2cc0:	b1 2c       	mov	r11, r1
    2cc2:	c1 2e       	mov	r12, r17
    2cc4:	d1 2c       	mov	r13, r1
    2cc6:	b6 01       	movw	r22, r12
    2cc8:	6f 5f       	subi	r22, 0xFF	; 255
    2cca:	7f 4f       	sbci	r23, 0xFF	; 255
    2ccc:	80 e0       	ldi	r24, 0x00	; 0
    2cce:	90 e0       	ldi	r25, 0x00	; 0
    2cd0:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    2cd4:	a8 16       	cp	r10, r24
    2cd6:	b9 06       	cpc	r11, r25
    2cd8:	09 f0       	breq	.+2      	; 0x2cdc <__vector_13+0xc66>
    2cda:	64 c0       	rjmp	.+200    	; 0x2da4 <__vector_13+0xd2e>
    2cdc:	aa 80       	ldd	r10, Y+2	; 0x02
    2cde:	b1 2c       	mov	r11, r1
    2ce0:	b6 01       	movw	r22, r12
    2ce2:	6e 5f       	subi	r22, 0xFE	; 254
    2ce4:	7f 4f       	sbci	r23, 0xFF	; 255
    2ce6:	80 e0       	ldi	r24, 0x00	; 0
    2ce8:	90 e0       	ldi	r25, 0x00	; 0
    2cea:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    2cee:	a8 16       	cp	r10, r24
    2cf0:	b9 06       	cpc	r11, r25
    2cf2:	09 f0       	breq	.+2      	; 0x2cf6 <__vector_13+0xc80>
    2cf4:	57 c0       	rjmp	.+174    	; 0x2da4 <__vector_13+0xd2e>
    2cf6:	ab 80       	ldd	r10, Y+3	; 0x03
    2cf8:	b1 2c       	mov	r11, r1
    2cfa:	b6 01       	movw	r22, r12
    2cfc:	6d 5f       	subi	r22, 0xFD	; 253
    2cfe:	7f 4f       	sbci	r23, 0xFF	; 255
    2d00:	80 e0       	ldi	r24, 0x00	; 0
    2d02:	90 e0       	ldi	r25, 0x00	; 0
    2d04:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    2d08:	a8 16       	cp	r10, r24
    2d0a:	b9 06       	cpc	r11, r25
    2d0c:	09 f0       	breq	.+2      	; 0x2d10 <__vector_13+0xc9a>
    2d0e:	4a c0       	rjmp	.+148    	; 0x2da4 <__vector_13+0xd2e>
    2d10:	ac 80       	ldd	r10, Y+4	; 0x04
    2d12:	b1 2c       	mov	r11, r1
    2d14:	b6 01       	movw	r22, r12
    2d16:	6c 5f       	subi	r22, 0xFC	; 252
    2d18:	7f 4f       	sbci	r23, 0xFF	; 255
    2d1a:	80 e0       	ldi	r24, 0x00	; 0
    2d1c:	90 e0       	ldi	r25, 0x00	; 0
    2d1e:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    2d22:	a8 16       	cp	r10, r24
    2d24:	b9 06       	cpc	r11, r25
    2d26:	f1 f5       	brne	.+124    	; 0x2da4 <__vector_13+0xd2e>
                                                /*----------------->Exist  Username<-----------------*/
                                                // Shifting username/password characters and overwrite on the desired user to be deleted
                                                for (Uint8 Check_Counter_2 = Check_Counter + 1; Check_Counter_2 <= KP_Counter; Check_Counter_2++) {
    2d28:	1f 5f       	subi	r17, 0xFF	; 255
    2d2a:	1d c0       	rjmp	.+58     	; 0x2d66 <__vector_13+0xcf0>
                                                        EEPROM_WriteByte(0, Check_Counter_2, EEPROM_ReadByte(0, Check_Counter_2 + 4)); // Overwrite on the 4 characters of username in EEPROM Then shift all users place backward by shifting each character 4 places backward 
    2d2c:	e1 2e       	mov	r14, r17
    2d2e:	f1 2c       	mov	r15, r1
    2d30:	67 01       	movw	r12, r14
    2d32:	84 e0       	ldi	r24, 0x04	; 4
    2d34:	c8 0e       	add	r12, r24
    2d36:	d1 1c       	adc	r13, r1
    2d38:	b6 01       	movw	r22, r12
    2d3a:	80 e0       	ldi	r24, 0x00	; 0
    2d3c:	90 e0       	ldi	r25, 0x00	; 0
    2d3e:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    2d42:	ac 01       	movw	r20, r24
    2d44:	b7 01       	movw	r22, r14
    2d46:	80 e0       	ldi	r24, 0x00	; 0
    2d48:	90 e0       	ldi	r25, 0x00	; 0
    2d4a:	0e 94 9e 04 	call	0x93c	; 0x93c <EEPROM_WriteByte>
                                                        EEPROM_WriteByte(1, Check_Counter_2, EEPROM_ReadByte(1, Check_Counter_2 + 4)); // Overwrite on the 4 characters of password in EEPROM Then shift all users place backward by shifting each character 4 places backward
    2d4e:	b6 01       	movw	r22, r12
    2d50:	81 e0       	ldi	r24, 0x01	; 1
    2d52:	90 e0       	ldi	r25, 0x00	; 0
    2d54:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    2d58:	ac 01       	movw	r20, r24
    2d5a:	b7 01       	movw	r22, r14
    2d5c:	81 e0       	ldi	r24, 0x01	; 1
    2d5e:	90 e0       	ldi	r25, 0x00	; 0
    2d60:	0e 94 9e 04 	call	0x93c	; 0x93c <EEPROM_WriteByte>
                                for (Uint8 Check_Counter = 0; Check_Counter <= KP_Counter; Check_Counter += 4) {
                                        /*----------------->Username Check<------------------*/
                                        if (User[0] == EEPROM_ReadByte(0, Check_Counter + 1) && User[1] == EEPROM_ReadByte(0, Check_Counter + 2) && User[2] == EEPROM_ReadByte(0, Check_Counter + 3) && User[3] == EEPROM_ReadByte(0, Check_Counter + 4)) {
                                                /*----------------->Exist  Username<-----------------*/
                                                // Shifting username/password characters and overwrite on the desired user to be deleted
                                                for (Uint8 Check_Counter_2 = Check_Counter + 1; Check_Counter_2 <= KP_Counter; Check_Counter_2++) {
    2d64:	1f 5f       	subi	r17, 0xFF	; 255
    2d66:	40 91 f1 07 	lds	r20, 0x07F1	; 0x8007f1 <KP_Counter>
    2d6a:	41 17       	cp	r20, r17
    2d6c:	f8 f6       	brcc	.-66     	; 0x2d2c <__vector_13+0xcb6>
                                                        EEPROM_WriteByte(0, Check_Counter_2, EEPROM_ReadByte(0, Check_Counter_2 + 4)); // Overwrite on the 4 characters of username in EEPROM Then shift all users place backward by shifting each character 4 places backward 
                                                        EEPROM_WriteByte(1, Check_Counter_2, EEPROM_ReadByte(1, Check_Counter_2 + 4)); // Overwrite on the 4 characters of password in EEPROM Then shift all users place backward by shifting each character 4 places backward
                                                }

                                                KP_Counter -= 4; // Reduce the number of users in counter
    2d6e:	44 50       	subi	r20, 0x04	; 4
    2d70:	40 93 f1 07 	sts	0x07F1, r20	; 0x8007f1 <KP_Counter>
                                                EEPROM_WriteByte(4, 0, KP_Counter); // Saving the counter
    2d74:	50 e0       	ldi	r21, 0x00	; 0
    2d76:	60 e0       	ldi	r22, 0x00	; 0
    2d78:	70 e0       	ldi	r23, 0x00	; 0
    2d7a:	84 e0       	ldi	r24, 0x04	; 4
    2d7c:	90 e0       	ldi	r25, 0x00	; 0
    2d7e:	0e 94 9e 04 	call	0x93c	; 0x93c <EEPROM_WriteByte>
                                                Check_Counter = KP_Counter + 1; // Exiting the check for loop
    2d82:	10 91 f1 07 	lds	r17, 0x07F1	; 0x8007f1 <KP_Counter>
    2d86:	1f 5f       	subi	r17, 0xFF	; 255
                                                UART_TX_Str("\r\n");
    2d88:	8a ed       	ldi	r24, 0xDA	; 218
    2d8a:	92 e0       	ldi	r25, 0x02	; 2
    2d8c:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                                UART_TX_Str("\r\n");
    2d90:	8a ed       	ldi	r24, 0xDA	; 218
    2d92:	92 e0       	ldi	r25, 0x02	; 2
    2d94:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                                UART_TX_Str("User deleted successfully\r\n");
    2d98:	82 ef       	ldi	r24, 0xF2	; 242
    2d9a:	95 e0       	ldi	r25, 0x05	; 5
    2d9c:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                                j = 1; // To determine whether we find the user or not
    2da0:	ff 24       	eor	r15, r15
    2da2:	f3 94       	inc	r15
                                        while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
                                        User[i] = UART_RX_Char(); // Receiving the character in username array
                                }

                                /*---------------->Seaching For The User Want To Be Deleted<---------------------*/
                                for (Uint8 Check_Counter = 0; Check_Counter <= KP_Counter; Check_Counter += 4) {
    2da4:	1c 5f       	subi	r17, 0xFC	; 252
    2da6:	80 91 f1 07 	lds	r24, 0x07F1	; 0x8007f1 <KP_Counter>
    2daa:	81 17       	cp	r24, r17
    2dac:	08 f0       	brcs	.+2      	; 0x2db0 <__vector_13+0xd3a>
    2dae:	87 cf       	rjmp	.-242    	; 0x2cbe <__vector_13+0xc48>
    2db0:	46 c1       	rjmp	.+652    	; 0x303e <__vector_13+0xfc8>
                                                j = 1; // To determine whether we find the user or not
                                        }
                                }
                        }
                        /*--------------->Deleting PC User<-------------------*/
                        else if (UART_GetValue == '2') {
    2db2:	82 33       	cpi	r24, 0x32	; 50
    2db4:	09 f0       	breq	.+2      	; 0x2db8 <__vector_13+0xd42>
    2db6:	9b c0       	rjmp	.+310    	; 0x2eee <__vector_13+0xe78>
                                UART_TX_Str("\r\n");
    2db8:	8a ed       	ldi	r24, 0xDA	; 218
    2dba:	92 e0       	ldi	r25, 0x02	; 2
    2dbc:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("\r\n");
    2dc0:	8a ed       	ldi	r24, 0xDA	; 218
    2dc2:	92 e0       	ldi	r25, 0x02	; 2
    2dc4:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("Please enter the PC username\r\n");
    2dc8:	8e e0       	ldi	r24, 0x0E	; 14
    2dca:	96 e0       	ldi	r25, 0x06	; 6
    2dcc:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>

                                for (Uint8 i = 0; i < 4; i++) {
    2dd0:	10 e0       	ldi	r17, 0x00	; 0
    2dd2:	0e c0       	rjmp	.+28     	; 0x2df0 <__vector_13+0xd7a>
                                        while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    2dd4:	5f 9b       	sbis	0x0b, 7	; 11
    2dd6:	fe cf       	rjmp	.-4      	; 0x2dd4 <__vector_13+0xd5e>
                                        User[i] = UART_RX_Char(); // Receiving the character in username array
    2dd8:	e1 2e       	mov	r14, r17
    2dda:	f1 2c       	mov	r15, r1
    2ddc:	0e 94 37 10 	call	0x206e	; 0x206e <UART_RX_Char>
    2de0:	e1 e0       	ldi	r30, 0x01	; 1
    2de2:	f0 e0       	ldi	r31, 0x00	; 0
    2de4:	ec 0f       	add	r30, r28
    2de6:	fd 1f       	adc	r31, r29
    2de8:	ee 0d       	add	r30, r14
    2dea:	ff 1d       	adc	r31, r15
    2dec:	80 83       	st	Z, r24
                        else if (UART_GetValue == '2') {
                                UART_TX_Str("\r\n");
                                UART_TX_Str("\r\n");
                                UART_TX_Str("Please enter the PC username\r\n");

                                for (Uint8 i = 0; i < 4; i++) {
    2dee:	1f 5f       	subi	r17, 0xFF	; 255
    2df0:	14 30       	cpi	r17, 0x04	; 4
    2df2:	80 f3       	brcs	.-32     	; 0x2dd4 <__vector_13+0xd5e>
    2df4:	10 e0       	ldi	r17, 0x00	; 0
    2df6:	f1 2c       	mov	r15, r1
    2df8:	74 c0       	rjmp	.+232    	; 0x2ee2 <__vector_13+0xe6c>
                                }

                                /*---------------->Seaching For The User Want To Be Deleted<---------------------*/
                                for (Uint8 Check_Counter = 0; Check_Counter <= PC_Counter; Check_Counter += 4) {
                                        /*----------------->Username Check<------------------*/
                                        if (User[0] == EEPROM_ReadByte(2, Check_Counter + 1) && User[1] == EEPROM_ReadByte(2, Check_Counter + 2) && User[2] == EEPROM_ReadByte(2, Check_Counter + 3) && User[3] == EEPROM_ReadByte(2, Check_Counter + 4)) {
    2dfa:	a9 80       	ldd	r10, Y+1	; 0x01
    2dfc:	b1 2c       	mov	r11, r1
    2dfe:	c1 2e       	mov	r12, r17
    2e00:	d1 2c       	mov	r13, r1
    2e02:	b6 01       	movw	r22, r12
    2e04:	6f 5f       	subi	r22, 0xFF	; 255
    2e06:	7f 4f       	sbci	r23, 0xFF	; 255
    2e08:	82 e0       	ldi	r24, 0x02	; 2
    2e0a:	90 e0       	ldi	r25, 0x00	; 0
    2e0c:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    2e10:	a8 16       	cp	r10, r24
    2e12:	b9 06       	cpc	r11, r25
    2e14:	09 f0       	breq	.+2      	; 0x2e18 <__vector_13+0xda2>
    2e16:	64 c0       	rjmp	.+200    	; 0x2ee0 <__vector_13+0xe6a>
    2e18:	aa 80       	ldd	r10, Y+2	; 0x02
    2e1a:	b1 2c       	mov	r11, r1
    2e1c:	b6 01       	movw	r22, r12
    2e1e:	6e 5f       	subi	r22, 0xFE	; 254
    2e20:	7f 4f       	sbci	r23, 0xFF	; 255
    2e22:	82 e0       	ldi	r24, 0x02	; 2
    2e24:	90 e0       	ldi	r25, 0x00	; 0
    2e26:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    2e2a:	a8 16       	cp	r10, r24
    2e2c:	b9 06       	cpc	r11, r25
    2e2e:	09 f0       	breq	.+2      	; 0x2e32 <__vector_13+0xdbc>
    2e30:	57 c0       	rjmp	.+174    	; 0x2ee0 <__vector_13+0xe6a>
    2e32:	ab 80       	ldd	r10, Y+3	; 0x03
    2e34:	b1 2c       	mov	r11, r1
    2e36:	b6 01       	movw	r22, r12
    2e38:	6d 5f       	subi	r22, 0xFD	; 253
    2e3a:	7f 4f       	sbci	r23, 0xFF	; 255
    2e3c:	82 e0       	ldi	r24, 0x02	; 2
    2e3e:	90 e0       	ldi	r25, 0x00	; 0
    2e40:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    2e44:	a8 16       	cp	r10, r24
    2e46:	b9 06       	cpc	r11, r25
    2e48:	09 f0       	breq	.+2      	; 0x2e4c <__vector_13+0xdd6>
    2e4a:	4a c0       	rjmp	.+148    	; 0x2ee0 <__vector_13+0xe6a>
    2e4c:	ac 80       	ldd	r10, Y+4	; 0x04
    2e4e:	b1 2c       	mov	r11, r1
    2e50:	b6 01       	movw	r22, r12
    2e52:	6c 5f       	subi	r22, 0xFC	; 252
    2e54:	7f 4f       	sbci	r23, 0xFF	; 255
    2e56:	82 e0       	ldi	r24, 0x02	; 2
    2e58:	90 e0       	ldi	r25, 0x00	; 0
    2e5a:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    2e5e:	a8 16       	cp	r10, r24
    2e60:	b9 06       	cpc	r11, r25
    2e62:	f1 f5       	brne	.+124    	; 0x2ee0 <__vector_13+0xe6a>
                                                /*----------------->Exist  Username<-----------------*/
                                                // Shifting username/password characters and overwrite on the desired user to be deleted
                                                for (Uint8 Check_Counter_2 = Check_Counter + 1; Check_Counter_2 <= PC_Counter; Check_Counter_2++) {
    2e64:	1f 5f       	subi	r17, 0xFF	; 255
    2e66:	1d c0       	rjmp	.+58     	; 0x2ea2 <__vector_13+0xe2c>
                                                        EEPROM_WriteByte(2, Check_Counter_2, EEPROM_ReadByte(2, Check_Counter_2 + 4)); // Overwrite on the 4 characters of username in EEPROM Then shift all users place backward by shifting each character 4 places backward 
    2e68:	e1 2e       	mov	r14, r17
    2e6a:	f1 2c       	mov	r15, r1
    2e6c:	67 01       	movw	r12, r14
    2e6e:	84 e0       	ldi	r24, 0x04	; 4
    2e70:	c8 0e       	add	r12, r24
    2e72:	d1 1c       	adc	r13, r1
    2e74:	b6 01       	movw	r22, r12
    2e76:	82 e0       	ldi	r24, 0x02	; 2
    2e78:	90 e0       	ldi	r25, 0x00	; 0
    2e7a:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    2e7e:	ac 01       	movw	r20, r24
    2e80:	b7 01       	movw	r22, r14
    2e82:	82 e0       	ldi	r24, 0x02	; 2
    2e84:	90 e0       	ldi	r25, 0x00	; 0
    2e86:	0e 94 9e 04 	call	0x93c	; 0x93c <EEPROM_WriteByte>
                                                        EEPROM_WriteByte(3, Check_Counter_2, EEPROM_ReadByte(3, Check_Counter_2 + 4)); // Overwrite on the 4 characters of password in EEPROM Then shift all users place backward by shifting each character 4 places backward
    2e8a:	b6 01       	movw	r22, r12
    2e8c:	83 e0       	ldi	r24, 0x03	; 3
    2e8e:	90 e0       	ldi	r25, 0x00	; 0
    2e90:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    2e94:	ac 01       	movw	r20, r24
    2e96:	b7 01       	movw	r22, r14
    2e98:	83 e0       	ldi	r24, 0x03	; 3
    2e9a:	90 e0       	ldi	r25, 0x00	; 0
    2e9c:	0e 94 9e 04 	call	0x93c	; 0x93c <EEPROM_WriteByte>
                                for (Uint8 Check_Counter = 0; Check_Counter <= PC_Counter; Check_Counter += 4) {
                                        /*----------------->Username Check<------------------*/
                                        if (User[0] == EEPROM_ReadByte(2, Check_Counter + 1) && User[1] == EEPROM_ReadByte(2, Check_Counter + 2) && User[2] == EEPROM_ReadByte(2, Check_Counter + 3) && User[3] == EEPROM_ReadByte(2, Check_Counter + 4)) {
                                                /*----------------->Exist  Username<-----------------*/
                                                // Shifting username/password characters and overwrite on the desired user to be deleted
                                                for (Uint8 Check_Counter_2 = Check_Counter + 1; Check_Counter_2 <= PC_Counter; Check_Counter_2++) {
    2ea0:	1f 5f       	subi	r17, 0xFF	; 255
    2ea2:	40 91 f0 07 	lds	r20, 0x07F0	; 0x8007f0 <PC_Counter>
    2ea6:	41 17       	cp	r20, r17
    2ea8:	f8 f6       	brcc	.-66     	; 0x2e68 <__vector_13+0xdf2>
                                                        EEPROM_WriteByte(2, Check_Counter_2, EEPROM_ReadByte(2, Check_Counter_2 + 4)); // Overwrite on the 4 characters of username in EEPROM Then shift all users place backward by shifting each character 4 places backward 
                                                        EEPROM_WriteByte(3, Check_Counter_2, EEPROM_ReadByte(3, Check_Counter_2 + 4)); // Overwrite on the 4 characters of password in EEPROM Then shift all users place backward by shifting each character 4 places backward
                                                }

                                                PC_Counter -= 4; // Reduce the number of users in counter
    2eaa:	44 50       	subi	r20, 0x04	; 4
    2eac:	40 93 f0 07 	sts	0x07F0, r20	; 0x8007f0 <PC_Counter>
                                                EEPROM_WriteByte(4, 1, PC_Counter); // Saving the counter
    2eb0:	50 e0       	ldi	r21, 0x00	; 0
    2eb2:	61 e0       	ldi	r22, 0x01	; 1
    2eb4:	70 e0       	ldi	r23, 0x00	; 0
    2eb6:	84 e0       	ldi	r24, 0x04	; 4
    2eb8:	90 e0       	ldi	r25, 0x00	; 0
    2eba:	0e 94 9e 04 	call	0x93c	; 0x93c <EEPROM_WriteByte>
                                                Check_Counter = PC_Counter + 1; // Exiting the check for loop
    2ebe:	10 91 f0 07 	lds	r17, 0x07F0	; 0x8007f0 <PC_Counter>
    2ec2:	1f 5f       	subi	r17, 0xFF	; 255
                                                UART_TX_Str("\r\n");
    2ec4:	8a ed       	ldi	r24, 0xDA	; 218
    2ec6:	92 e0       	ldi	r25, 0x02	; 2
    2ec8:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                                UART_TX_Str("\r\n");
    2ecc:	8a ed       	ldi	r24, 0xDA	; 218
    2ece:	92 e0       	ldi	r25, 0x02	; 2
    2ed0:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                                UART_TX_Str("User deleted successfully\r\n");
    2ed4:	82 ef       	ldi	r24, 0xF2	; 242
    2ed6:	95 e0       	ldi	r25, 0x05	; 5
    2ed8:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                                j = 1; // To determine whether we find the user or not
    2edc:	ff 24       	eor	r15, r15
    2ede:	f3 94       	inc	r15
                                        while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
                                        User[i] = UART_RX_Char(); // Receiving the character in username array
                                }

                                /*---------------->Seaching For The User Want To Be Deleted<---------------------*/
                                for (Uint8 Check_Counter = 0; Check_Counter <= PC_Counter; Check_Counter += 4) {
    2ee0:	1c 5f       	subi	r17, 0xFC	; 252
    2ee2:	80 91 f0 07 	lds	r24, 0x07F0	; 0x8007f0 <PC_Counter>
    2ee6:	81 17       	cp	r24, r17
    2ee8:	08 f0       	brcs	.+2      	; 0x2eec <__vector_13+0xe76>
    2eea:	87 cf       	rjmp	.-242    	; 0x2dfa <__vector_13+0xd84>
    2eec:	a8 c0       	rjmp	.+336    	; 0x303e <__vector_13+0xfc8>
                                                j = 1; // To determine whether we find the user or not
                                        }
                                }
                        }
                        /*--------------->Deleting Admin User<-------------------*/
                        else if (UART_GetValue == '3') {
    2eee:	83 33       	cpi	r24, 0x33	; 51
    2ef0:	09 f0       	breq	.+2      	; 0x2ef4 <__vector_13+0xe7e>
    2ef2:	a4 c0       	rjmp	.+328    	; 0x303c <__vector_13+0xfc6>
                                UART_TX_Str("\r\n");
    2ef4:	8a ed       	ldi	r24, 0xDA	; 218
    2ef6:	92 e0       	ldi	r25, 0x02	; 2
    2ef8:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("\r\n");
    2efc:	8a ed       	ldi	r24, 0xDA	; 218
    2efe:	92 e0       	ldi	r25, 0x02	; 2
    2f00:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("Please enter the AD username\r\n");
    2f04:	8d e2       	ldi	r24, 0x2D	; 45
    2f06:	96 e0       	ldi	r25, 0x06	; 6
    2f08:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>

                                for (Uint8 i = 0; i < 4; i++) {
    2f0c:	10 e0       	ldi	r17, 0x00	; 0
    2f0e:	0e c0       	rjmp	.+28     	; 0x2f2c <__vector_13+0xeb6>
                                        while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    2f10:	5f 9b       	sbis	0x0b, 7	; 11
    2f12:	fe cf       	rjmp	.-4      	; 0x2f10 <__vector_13+0xe9a>
                                        User[i] = UART_RX_Char(); // Receiving the character in username array
    2f14:	e1 2e       	mov	r14, r17
    2f16:	f1 2c       	mov	r15, r1
    2f18:	0e 94 37 10 	call	0x206e	; 0x206e <UART_RX_Char>
    2f1c:	e1 e0       	ldi	r30, 0x01	; 1
    2f1e:	f0 e0       	ldi	r31, 0x00	; 0
    2f20:	ec 0f       	add	r30, r28
    2f22:	fd 1f       	adc	r31, r29
    2f24:	ee 0d       	add	r30, r14
    2f26:	ff 1d       	adc	r31, r15
    2f28:	80 83       	st	Z, r24
                        else if (UART_GetValue == '3') {
                                UART_TX_Str("\r\n");
                                UART_TX_Str("\r\n");
                                UART_TX_Str("Please enter the AD username\r\n");

                                for (Uint8 i = 0; i < 4; i++) {
    2f2a:	1f 5f       	subi	r17, 0xFF	; 255
    2f2c:	14 30       	cpi	r17, 0x04	; 4
    2f2e:	80 f3       	brcs	.-32     	; 0x2f10 <__vector_13+0xe9a>
    2f30:	04 e0       	ldi	r16, 0x04	; 4
    2f32:	f1 2c       	mov	r15, r1
    2f34:	7d c0       	rjmp	.+250    	; 0x3030 <__vector_13+0xfba>
                                }

                                /*---------------->Seaching For The User Want To Be Deleted<---------------------*/
                                for (Uint8 Check_Counter = 4; Check_Counter <= AD_Counter; Check_Counter += 4) {
                                        /*----------------->Username Check<------------------*/
                                        if (User[0] == EEPROM_ReadByte(5, Check_Counter + 1) && User[1] == EEPROM_ReadByte(5, Check_Counter + 2) && User[2] == EEPROM_ReadByte(5, Check_Counter + 3) && User[3] == EEPROM_ReadByte(5, Check_Counter + 4)) {
    2f36:	a9 80       	ldd	r10, Y+1	; 0x01
    2f38:	b1 2c       	mov	r11, r1
    2f3a:	c0 2e       	mov	r12, r16
    2f3c:	d1 2c       	mov	r13, r1
    2f3e:	b6 01       	movw	r22, r12
    2f40:	6f 5f       	subi	r22, 0xFF	; 255
    2f42:	7f 4f       	sbci	r23, 0xFF	; 255
    2f44:	85 e0       	ldi	r24, 0x05	; 5
    2f46:	90 e0       	ldi	r25, 0x00	; 0
    2f48:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    2f4c:	a8 16       	cp	r10, r24
    2f4e:	b9 06       	cpc	r11, r25
    2f50:	09 f0       	breq	.+2      	; 0x2f54 <__vector_13+0xede>
    2f52:	6d c0       	rjmp	.+218    	; 0x302e <__vector_13+0xfb8>
    2f54:	aa 80       	ldd	r10, Y+2	; 0x02
    2f56:	b1 2c       	mov	r11, r1
    2f58:	b6 01       	movw	r22, r12
    2f5a:	6e 5f       	subi	r22, 0xFE	; 254
    2f5c:	7f 4f       	sbci	r23, 0xFF	; 255
    2f5e:	85 e0       	ldi	r24, 0x05	; 5
    2f60:	90 e0       	ldi	r25, 0x00	; 0
    2f62:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    2f66:	a8 16       	cp	r10, r24
    2f68:	b9 06       	cpc	r11, r25
    2f6a:	09 f0       	breq	.+2      	; 0x2f6e <__vector_13+0xef8>
    2f6c:	60 c0       	rjmp	.+192    	; 0x302e <__vector_13+0xfb8>
    2f6e:	ab 80       	ldd	r10, Y+3	; 0x03
    2f70:	b1 2c       	mov	r11, r1
    2f72:	b6 01       	movw	r22, r12
    2f74:	6d 5f       	subi	r22, 0xFD	; 253
    2f76:	7f 4f       	sbci	r23, 0xFF	; 255
    2f78:	85 e0       	ldi	r24, 0x05	; 5
    2f7a:	90 e0       	ldi	r25, 0x00	; 0
    2f7c:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    2f80:	a8 16       	cp	r10, r24
    2f82:	b9 06       	cpc	r11, r25
    2f84:	09 f0       	breq	.+2      	; 0x2f88 <__vector_13+0xf12>
    2f86:	53 c0       	rjmp	.+166    	; 0x302e <__vector_13+0xfb8>
    2f88:	ac 80       	ldd	r10, Y+4	; 0x04
    2f8a:	b1 2c       	mov	r11, r1
    2f8c:	b6 01       	movw	r22, r12
    2f8e:	6c 5f       	subi	r22, 0xFC	; 252
    2f90:	7f 4f       	sbci	r23, 0xFF	; 255
    2f92:	85 e0       	ldi	r24, 0x05	; 5
    2f94:	90 e0       	ldi	r25, 0x00	; 0
    2f96:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    2f9a:	a8 16       	cp	r10, r24
    2f9c:	b9 06       	cpc	r11, r25
    2f9e:	09 f0       	breq	.+2      	; 0x2fa2 <__vector_13+0xf2c>
    2fa0:	46 c0       	rjmp	.+140    	; 0x302e <__vector_13+0xfb8>
                                                /*----------------->Exist  Username<-----------------*/
                                                for (Uint8 Check_Counter_2 = Check_Counter + 1; Check_Counter_2 <= AD_Counter; Check_Counter_2++) {
    2fa2:	11 e0       	ldi	r17, 0x01	; 1
    2fa4:	10 0f       	add	r17, r16
    2fa6:	1d c0       	rjmp	.+58     	; 0x2fe2 <__vector_13+0xf6c>
                                                        EEPROM_WriteByte(5, Check_Counter_2, EEPROM_ReadByte(5, Check_Counter_2 + 4)); // Overwrite on the 4 characters of username in EEPROM Then shift all users place backward by shifting each character 4 places backward
    2fa8:	e1 2e       	mov	r14, r17
    2faa:	f1 2c       	mov	r15, r1
    2fac:	67 01       	movw	r12, r14
    2fae:	84 e0       	ldi	r24, 0x04	; 4
    2fb0:	c8 0e       	add	r12, r24
    2fb2:	d1 1c       	adc	r13, r1
    2fb4:	b6 01       	movw	r22, r12
    2fb6:	85 e0       	ldi	r24, 0x05	; 5
    2fb8:	90 e0       	ldi	r25, 0x00	; 0
    2fba:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    2fbe:	ac 01       	movw	r20, r24
    2fc0:	b7 01       	movw	r22, r14
    2fc2:	85 e0       	ldi	r24, 0x05	; 5
    2fc4:	90 e0       	ldi	r25, 0x00	; 0
    2fc6:	0e 94 9e 04 	call	0x93c	; 0x93c <EEPROM_WriteByte>
                                                        EEPROM_WriteByte(6, Check_Counter_2, EEPROM_ReadByte(6, Check_Counter_2 + 4)); // Overwrite on the 4 characters of password in EEPROM Then shift all users place backward by shifting each character 4 places backward
    2fca:	b6 01       	movw	r22, r12
    2fcc:	86 e0       	ldi	r24, 0x06	; 6
    2fce:	90 e0       	ldi	r25, 0x00	; 0
    2fd0:	0e 94 bf 04 	call	0x97e	; 0x97e <EEPROM_ReadByte>
    2fd4:	ac 01       	movw	r20, r24
    2fd6:	b7 01       	movw	r22, r14
    2fd8:	86 e0       	ldi	r24, 0x06	; 6
    2fda:	90 e0       	ldi	r25, 0x00	; 0
    2fdc:	0e 94 9e 04 	call	0x93c	; 0x93c <EEPROM_WriteByte>
                                /*---------------->Seaching For The User Want To Be Deleted<---------------------*/
                                for (Uint8 Check_Counter = 4; Check_Counter <= AD_Counter; Check_Counter += 4) {
                                        /*----------------->Username Check<------------------*/
                                        if (User[0] == EEPROM_ReadByte(5, Check_Counter + 1) && User[1] == EEPROM_ReadByte(5, Check_Counter + 2) && User[2] == EEPROM_ReadByte(5, Check_Counter + 3) && User[3] == EEPROM_ReadByte(5, Check_Counter + 4)) {
                                                /*----------------->Exist  Username<-----------------*/
                                                for (Uint8 Check_Counter_2 = Check_Counter + 1; Check_Counter_2 <= AD_Counter; Check_Counter_2++) {
    2fe0:	1f 5f       	subi	r17, 0xFF	; 255
    2fe2:	80 91 70 00 	lds	r24, 0x0070	; 0x800070 <AD_Counter>
    2fe6:	81 17       	cp	r24, r17
    2fe8:	f8 f6       	brcc	.-66     	; 0x2fa8 <__vector_13+0xf32>
                                                        EEPROM_WriteByte(5, Check_Counter_2, EEPROM_ReadByte(5, Check_Counter_2 + 4)); // Overwrite on the 4 characters of username in EEPROM Then shift all users place backward by shifting each character 4 places backward
                                                        EEPROM_WriteByte(6, Check_Counter_2, EEPROM_ReadByte(6, Check_Counter_2 + 4)); // Overwrite on the 4 characters of password in EEPROM Then shift all users place backward by shifting each character 4 places backward
                                                }

                                                AD_Counter -= 4; // Reduce the number of users in counter
    2fea:	9c ef       	ldi	r25, 0xFC	; 252
    2fec:	98 0f       	add	r25, r24
    2fee:	90 93 70 00 	sts	0x0070, r25	; 0x800070 <AD_Counter>
                                                // To make sure that the main admin does not deleted
                                                if (Check_Counter == 0) {
    2ff2:	01 11       	cpse	r16, r1
    2ff4:	02 c0       	rjmp	.+4      	; 0x2ffa <__vector_13+0xf84>
                                                        AD_Counter += 4;
    2ff6:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <AD_Counter>
                                                }
                                                EEPROM_WriteByte(4, 2, AD_Counter); // Saving the counter
    2ffa:	40 91 70 00 	lds	r20, 0x0070	; 0x800070 <AD_Counter>
    2ffe:	50 e0       	ldi	r21, 0x00	; 0
    3000:	62 e0       	ldi	r22, 0x02	; 2
    3002:	70 e0       	ldi	r23, 0x00	; 0
    3004:	84 e0       	ldi	r24, 0x04	; 4
    3006:	90 e0       	ldi	r25, 0x00	; 0
    3008:	0e 94 9e 04 	call	0x93c	; 0x93c <EEPROM_WriteByte>
                                                Check_Counter = AD_Counter + 1; // Exiting the check for loop
    300c:	00 91 70 00 	lds	r16, 0x0070	; 0x800070 <AD_Counter>
    3010:	0f 5f       	subi	r16, 0xFF	; 255
                                                UART_TX_Str("\r\n");
    3012:	8a ed       	ldi	r24, 0xDA	; 218
    3014:	92 e0       	ldi	r25, 0x02	; 2
    3016:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                                UART_TX_Str("\r\n");
    301a:	8a ed       	ldi	r24, 0xDA	; 218
    301c:	92 e0       	ldi	r25, 0x02	; 2
    301e:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                                UART_TX_Str("User deleted successfully\r\n");
    3022:	82 ef       	ldi	r24, 0xF2	; 242
    3024:	95 e0       	ldi	r25, 0x05	; 5
    3026:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                                j = 1; // To determine whether we find the user or not
    302a:	ff 24       	eor	r15, r15
    302c:	f3 94       	inc	r15
                                        while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
                                        User[i] = UART_RX_Char(); // Receiving the character in username array
                                }

                                /*---------------->Seaching For The User Want To Be Deleted<---------------------*/
                                for (Uint8 Check_Counter = 4; Check_Counter <= AD_Counter; Check_Counter += 4) {
    302e:	0c 5f       	subi	r16, 0xFC	; 252
    3030:	80 91 70 00 	lds	r24, 0x0070	; 0x800070 <AD_Counter>
    3034:	80 17       	cp	r24, r16
    3036:	08 f0       	brcs	.+2      	; 0x303a <__vector_13+0xfc4>
    3038:	7e cf       	rjmp	.-260    	; 0x2f36 <__vector_13+0xec0>
    303a:	01 c0       	rjmp	.+2      	; 0x303e <__vector_13+0xfc8>
                        UART_TX_Str("\r\n");
                        UART_TX_Str("\r\n");
                        UART_TX_Str("User added successfully\r\n");
                } else if (UART_GetValue == '8') {
                        // Delete an exist user
                        Uint8 j = 0;
    303c:	f1 2c       	mov	r15, r1
                                                j = 1; // To determine whether we find the user or not
                                        }
                                }
                        }
                        // If we not find the user
                        if (!j) {
    303e:	f1 10       	cpse	r15, r1
    3040:	2c c0       	rjmp	.+88     	; 0x309a <__vector_13+0x1024>
                                UART_TX_Str("\r\n");
    3042:	8a ed       	ldi	r24, 0xDA	; 218
    3044:	92 e0       	ldi	r25, 0x02	; 2
    3046:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("\r\n");
    304a:	8a ed       	ldi	r24, 0xDA	; 218
    304c:	92 e0       	ldi	r25, 0x02	; 2
    304e:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("User is not exist\r\n");
    3052:	8c e4       	ldi	r24, 0x4C	; 76
    3054:	96 e0       	ldi	r25, 0x06	; 6
    3056:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
    305a:	1f c0       	rjmp	.+62     	; 0x309a <__vector_13+0x1024>
                        }
                } else if (UART_GetValue == '0') {
    305c:	80 33       	cpi	r24, 0x30	; 48
    305e:	79 f4       	brne	.+30     	; 0x307e <__vector_13+0x1008>
                        /*------------->Loging-Out From The System<--------------*/
                        SYS_Check = 0; // 0 is the value that take the system to the login operation
    3060:	10 92 f4 07 	sts	0x07F4, r1	; 0x8007f4 <SYS_Check>
                        UART_TX_Str("\r\n");
    3064:	8a ed       	ldi	r24, 0xDA	; 218
    3066:	92 e0       	ldi	r25, 0x02	; 2
    3068:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    306c:	8a ed       	ldi	r24, 0xDA	; 218
    306e:	92 e0       	ldi	r25, 0x02	; 2
    3070:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("Bye-Bye user\r\n");
    3074:	80 e6       	ldi	r24, 0x60	; 96
    3076:	96 e0       	ldi	r25, 0x06	; 6
    3078:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
    307c:	0e c0       	rjmp	.+28     	; 0x309a <__vector_13+0x1024>
                }

                // *Not Important to Know* where the CMD_Check take the system to do nothing and avoid any complicated link between login operation and admin logged-in oparation
                else if (UART_GetValue == 8) {
    307e:	88 30       	cpi	r24, 0x08	; 8
    3080:	61 f0       	breq	.+24     	; 0x309a <__vector_13+0x1024>

                }
                // If user entered wrong command
                else {
                        UART_TX_Str("\r\n");
    3082:	8a ed       	ldi	r24, 0xDA	; 218
    3084:	92 e0       	ldi	r25, 0x02	; 2
    3086:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    308a:	8a ed       	ldi	r24, 0xDA	; 218
    308c:	92 e0       	ldi	r25, 0x02	; 2
    308e:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("Please enter command number\r\n");
    3092:	85 e4       	ldi	r24, 0x45	; 69
    3094:	93 e0       	ldi	r25, 0x03	; 3
    3096:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                }

                // If there is a keypad user
                if (eme_check) {
    309a:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    309e:	88 23       	and	r24, r24
    30a0:	81 f0       	breq	.+32     	; 0x30c2 <__vector_13+0x104c>
                        if (UART_GetValue == '9') {
    30a2:	80 91 f5 07 	lds	r24, 0x07F5	; 0x8007f5 <UART_GetValue>
    30a6:	89 33       	cpi	r24, 0x39	; 57
    30a8:	61 f4       	brne	.+24     	; 0x30c2 <__vector_13+0x104c>
                                /*---------------->Firing Keypad User From The System<---------------*/
                                eme_check = 0; // 0 is the value that take the system to the login operation for keypad also
    30aa:	10 92 d1 07 	sts	0x07D1, r1	; 0x8007d1 <eme_check>
                                LCD_Clear();
    30ae:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                UART_TX_Str("\r\n");
    30b2:	8a ed       	ldi	r24, 0xDA	; 218
    30b4:	92 e0       	ldi	r25, 0x02	; 2
    30b6:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                                UART_TX_Str("Keypad user kicked out\r\n");
    30ba:	8f e6       	ldi	r24, 0x6F	; 111
    30bc:	96 e0       	ldi	r25, 0x06	; 6
    30be:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        }
                }

                /*--------------->Commands List<-----------------*/
                // If there is user
                if (SYS_Check) {
    30c2:	80 91 f4 07 	lds	r24, 0x07F4	; 0x8007f4 <SYS_Check>
    30c6:	88 23       	and	r24, r24
    30c8:	09 f4       	brne	.+2      	; 0x30cc <__vector_13+0x1056>
    30ca:	41 c0       	rjmp	.+130    	; 0x314e <__vector_13+0x10d8>
                        UART_TX_Str("\r\n");
    30cc:	8a ed       	ldi	r24, 0xDA	; 218
    30ce:	92 e0       	ldi	r25, 0x02	; 2
    30d0:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("Waiting for your command\r\n");
    30d4:	88 e8       	ldi	r24, 0x88	; 136
    30d6:	96 e0       	ldi	r25, 0x06	; 6
    30d8:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    30dc:	8a ed       	ldi	r24, 0xDA	; 218
    30de:	92 e0       	ldi	r25, 0x02	; 2
    30e0:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("1.Open the door\r\n");
    30e4:	83 ea       	ldi	r24, 0xA3	; 163
    30e6:	96 e0       	ldi	r25, 0x06	; 6
    30e8:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("2.Close the door\r\n");
    30ec:	85 eb       	ldi	r24, 0xB5	; 181
    30ee:	96 e0       	ldi	r25, 0x06	; 6
    30f0:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("3.Open lamps\r\n");
    30f4:	88 ec       	ldi	r24, 0xC8	; 200
    30f6:	96 e0       	ldi	r25, 0x06	; 6
    30f8:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("4.Close lamps\r\n");
    30fc:	87 ed       	ldi	r24, 0xD7	; 215
    30fe:	96 e0       	ldi	r25, 0x06	; 6
    3100:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("5.Variant lamp\r\n");
    3104:	87 ee       	ldi	r24, 0xE7	; 231
    3106:	96 e0       	ldi	r25, 0x06	; 6
    3108:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("6.Display the temperature\r\n");
    310c:	88 ef       	ldi	r24, 0xF8	; 248
    310e:	96 e0       	ldi	r25, 0x06	; 6
    3110:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("7.Add new user\r\n");
    3114:	84 e1       	ldi	r24, 0x14	; 20
    3116:	97 e0       	ldi	r25, 0x07	; 7
    3118:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("8.Delete exist user\r\n");
    311c:	85 e2       	ldi	r24, 0x25	; 37
    311e:	97 e0       	ldi	r25, 0x07	; 7
    3120:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        if (eme_check)
    3124:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    3128:	88 23       	and	r24, r24
    312a:	21 f0       	breq	.+8      	; 0x3134 <__vector_13+0x10be>
                                UART_TX_Str("9.Fire Keypad user\r\n");
    312c:	8b e3       	ldi	r24, 0x3B	; 59
    312e:	97 e0       	ldi	r25, 0x07	; 7
    3130:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("0.Logout\r\n");
    3134:	80 e5       	ldi	r24, 0x50	; 80
    3136:	97 e0       	ldi	r25, 0x07	; 7
    3138:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("Reply with the number of the command\r\n");
    313c:	8b e5       	ldi	r24, 0x5B	; 91
    313e:	97 e0       	ldi	r25, 0x07	; 7
    3140:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    3144:	8a ed       	ldi	r24, 0xDA	; 218
    3146:	92 e0       	ldi	r25, 0x02	; 2
    3148:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
    314c:	c9 c2       	rjmp	.+1426   	; 0x36e0 <__vector_13+0x166a>
                }
                // if there is not user
                else {
                        UART_TX_Str("\r\n");
    314e:	8a ed       	ldi	r24, 0xDA	; 218
    3150:	92 e0       	ldi	r25, 0x02	; 2
    3152:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    3156:	8a ed       	ldi	r24, 0xDA	; 218
    3158:	92 e0       	ldi	r25, 0x02	; 2
    315a:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("1.Enter Admin\r\n");
    315e:	8c e6       	ldi	r24, 0x6C	; 108
    3160:	92 e0       	ldi	r25, 0x02	; 2
    3162:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("2.Enter User\r\n");
    3166:	8c e7       	ldi	r24, 0x7C	; 124
    3168:	92 e0       	ldi	r25, 0x02	; 2
    316a:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    316e:	8a ed       	ldi	r24, 0xDA	; 218
    3170:	92 e0       	ldi	r25, 0x02	; 2
    3172:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
    3176:	b4 c2       	rjmp	.+1384   	; 0x36e0 <__vector_13+0x166a>
                }

        }
        /*----------> User Loged-in <----------*/
        else if (SYS_Check == 2) {
    3178:	82 30       	cpi	r24, 0x02	; 2
    317a:	09 f0       	breq	.+2      	; 0x317e <__vector_13+0x1108>
    317c:	b1 c2       	rjmp	.+1378   	; 0x36e0 <__vector_13+0x166a>
                UART_GetValue = UDR; // Receiving the command
    317e:	8c b1       	in	r24, 0x0c	; 12
    3180:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <UART_GetValue>

                // *Not Important to Know* it used to not take UART_Get value variable after login the system as 0 value (do nothing after entering the system)
                if (CMD_Check) {
    3184:	80 91 f2 07 	lds	r24, 0x07F2	; 0x8007f2 <CMD_Check>
    3188:	88 23       	and	r24, r24
    318a:	29 f0       	breq	.+10     	; 0x3196 <__vector_13+0x1120>
                        UART_GetValue = 8;
    318c:	88 e0       	ldi	r24, 0x08	; 8
    318e:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <UART_GetValue>
                        CMD_Check = 0;
    3192:	10 92 f2 07 	sts	0x07F2, r1	; 0x8007f2 <CMD_Check>
                }

                if (UART_GetValue == '1') {
    3196:	80 91 f5 07 	lds	r24, 0x07F5	; 0x8007f5 <UART_GetValue>
    319a:	81 33       	cpi	r24, 0x31	; 49
    319c:	09 f0       	breq	.+2      	; 0x31a0 <__vector_13+0x112a>
    319e:	8e c0       	rjmp	.+284    	; 0x32bc <__vector_13+0x1246>
                        // Open lamps
                        UART_TX_Str("\r\n");
    31a0:	8a ed       	ldi	r24, 0xDA	; 218
    31a2:	92 e0       	ldi	r25, 0x02	; 2
    31a4:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    31a8:	8a ed       	ldi	r24, 0xDA	; 218
    31aa:	92 e0       	ldi	r25, 0x02	; 2
    31ac:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("Which lamp do you want to be opened(From 1 to 5)\r\n");
    31b0:	8d e7       	ldi	r24, 0x7D	; 125
    31b2:	93 e0       	ldi	r25, 0x03	; 3
    31b4:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("6.All Lamps\r\n");
    31b8:	80 eb       	ldi	r24, 0xB0	; 176
    31ba:	93 e0       	ldi	r25, 0x03	; 3
    31bc:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    31c0:	8a ed       	ldi	r24, 0xDA	; 218
    31c2:	92 e0       	ldi	r25, 0x02	; 2
    31c4:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>

                        while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    31c8:	5f 9b       	sbis	0x0b, 7	; 11
    31ca:	fe cf       	rjmp	.-4      	; 0x31c8 <__vector_13+0x1152>
                        UART_GetValue = UART_RX_Char(); // Receiving the command
    31cc:	0e 94 37 10 	call	0x206e	; 0x206e <UART_RX_Char>
    31d0:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <UART_GetValue>

                        // Open first lamp
                        if (UART_GetValue == '1') {
    31d4:	81 33       	cpi	r24, 0x31	; 49
    31d6:	69 f4       	brne	.+26     	; 0x31f2 <__vector_13+0x117c>
                                LED0_ON();
    31d8:	0e 94 ac 0c 	call	0x1958	; 0x1958 <LED0_ON>
                                // If there is no keypad user, using LCD to write the operating device
                                if (!eme_check) {
    31dc:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    31e0:	81 11       	cpse	r24, r1
    31e2:	61 c0       	rjmp	.+194    	; 0x32a6 <__vector_13+0x1230>
                                        LCD_Clear();
    31e4:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                        LCD_Write_String("Lamp(1) Opened");
    31e8:	8e eb       	ldi	r24, 0xBE	; 190
    31ea:	93 e0       	ldi	r25, 0x03	; 3
    31ec:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
    31f0:	5a c0       	rjmp	.+180    	; 0x32a6 <__vector_13+0x1230>
                                }
                        }
                        // Open second lamp
                        else if (UART_GetValue == '2') {
    31f2:	82 33       	cpi	r24, 0x32	; 50
    31f4:	69 f4       	brne	.+26     	; 0x3210 <__vector_13+0x119a>
                                LED1_ON();
    31f6:	0e 94 c8 0c 	call	0x1990	; 0x1990 <LED1_ON>
                                // If there is no keypad user, using LCD to write the operating device
                                if (!eme_check) {
    31fa:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    31fe:	81 11       	cpse	r24, r1
    3200:	52 c0       	rjmp	.+164    	; 0x32a6 <__vector_13+0x1230>
                                        LCD_Clear();
    3202:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                        LCD_Write_String("Lamp(2) Opened");
    3206:	8d ec       	ldi	r24, 0xCD	; 205
    3208:	93 e0       	ldi	r25, 0x03	; 3
    320a:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
    320e:	4b c0       	rjmp	.+150    	; 0x32a6 <__vector_13+0x1230>
                                }
                        }
                        // Open third lamp
                        else if (UART_GetValue == '3') {
    3210:	83 33       	cpi	r24, 0x33	; 51
    3212:	69 f4       	brne	.+26     	; 0x322e <__vector_13+0x11b8>
                                LED2_ON();
    3214:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LED2_ON>
                                // If there is no keypad user, using LCD to write the operating device
                                if (!eme_check) {
    3218:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    321c:	81 11       	cpse	r24, r1
    321e:	43 c0       	rjmp	.+134    	; 0x32a6 <__vector_13+0x1230>
                                        LCD_Clear();
    3220:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                        LCD_Write_String("Lamp(3) Opened");
    3224:	8c ed       	ldi	r24, 0xDC	; 220
    3226:	93 e0       	ldi	r25, 0x03	; 3
    3228:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
    322c:	3c c0       	rjmp	.+120    	; 0x32a6 <__vector_13+0x1230>
                                }
                        }
                        // Open fourth lamp
                        else if (UART_GetValue == '4') {
    322e:	84 33       	cpi	r24, 0x34	; 52
    3230:	69 f4       	brne	.+26     	; 0x324c <__vector_13+0x11d6>
                                LED3_ON();
    3232:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <LED3_ON>
                                // If there is no keypad user, using LCD to write the operating device
                                if (!eme_check) {
    3236:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    323a:	81 11       	cpse	r24, r1
    323c:	34 c0       	rjmp	.+104    	; 0x32a6 <__vector_13+0x1230>
                                        LCD_Clear();
    323e:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                        LCD_Write_String("Lamp(4) Opened");
    3242:	8b ee       	ldi	r24, 0xEB	; 235
    3244:	93 e0       	ldi	r25, 0x03	; 3
    3246:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
    324a:	2d c0       	rjmp	.+90     	; 0x32a6 <__vector_13+0x1230>
                                }
                        }
                        // Open fifth lamp
                        else if (UART_GetValue == '5') {
    324c:	85 33       	cpi	r24, 0x35	; 53
    324e:	69 f4       	brne	.+26     	; 0x326a <__vector_13+0x11f4>
                                LED4_ON();
    3250:	0e 94 1c 0d 	call	0x1a38	; 0x1a38 <LED4_ON>
                                // If there is no keypad user, using LCD to write the operating device
                                if (!eme_check) {
    3254:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    3258:	81 11       	cpse	r24, r1
    325a:	25 c0       	rjmp	.+74     	; 0x32a6 <__vector_13+0x1230>
                                        LCD_Clear();
    325c:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                        LCD_Write_String("Lamp(5) Opened");
    3260:	8a ef       	ldi	r24, 0xFA	; 250
    3262:	93 e0       	ldi	r25, 0x03	; 3
    3264:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
    3268:	1e c0       	rjmp	.+60     	; 0x32a6 <__vector_13+0x1230>
                                }
                        }
                        // Open all lamps
                        else if (UART_GetValue == '6') {
    326a:	86 33       	cpi	r24, 0x36	; 54
    326c:	e1 f4       	brne	.+56     	; 0x32a6 <__vector_13+0x1230>
                                LED0_ON();
    326e:	0e 94 ac 0c 	call	0x1958	; 0x1958 <LED0_ON>
                                LED1_ON();
    3272:	0e 94 c8 0c 	call	0x1990	; 0x1990 <LED1_ON>
                                LED2_ON();
    3276:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <LED2_ON>
                                LED3_ON();
    327a:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <LED3_ON>
                                LED4_ON();
    327e:	0e 94 1c 0d 	call	0x1a38	; 0x1a38 <LED4_ON>
                                // If there is no keypad user, using LCD to write the operating device
                                if (!eme_check) {
    3282:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    3286:	81 11       	cpse	r24, r1
    3288:	0e c0       	rjmp	.+28     	; 0x32a6 <__vector_13+0x1230>
                                        LCD_Clear();
    328a:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                        LCD_Write_String("All Lamps Are");
    328e:	89 e0       	ldi	r24, 0x09	; 9
    3290:	94 e0       	ldi	r25, 0x04	; 4
    3292:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                                        LCD_Goto(1, 0);
    3296:	60 e0       	ldi	r22, 0x00	; 0
    3298:	81 e0       	ldi	r24, 0x01	; 1
    329a:	0e 94 83 0c 	call	0x1906	; 0x1906 <LCD_Goto>
                                        LCD_Write_String("Opened");
    329e:	86 ec       	ldi	r24, 0xC6	; 198
    32a0:	93 e0       	ldi	r25, 0x03	; 3
    32a2:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                                }
                        }
                        // If there is no keypad user, using LCD to write & clear the operating device
                        if (!eme_check)
    32a6:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    32aa:	81 11       	cpse	r24, r1
    32ac:	dc c1       	rjmp	.+952    	; 0x3666 <__vector_13+0x15f0>
                                Timer2_SetDelay(2000); // Clearing LCD after 2 seconds using timer 2
    32ae:	60 ed       	ldi	r22, 0xD0	; 208
    32b0:	77 e0       	ldi	r23, 0x07	; 7
    32b2:	80 e0       	ldi	r24, 0x00	; 0
    32b4:	90 e0       	ldi	r25, 0x00	; 0
    32b6:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <Timer2_SetDelay>
    32ba:	d5 c1       	rjmp	.+938    	; 0x3666 <__vector_13+0x15f0>
                } else if (UART_GetValue == '2') {
    32bc:	82 33       	cpi	r24, 0x32	; 50
    32be:	09 f0       	breq	.+2      	; 0x32c2 <__vector_13+0x124c>
    32c0:	8e c0       	rjmp	.+284    	; 0x33de <__vector_13+0x1368>
                        // Close lamps
                        UART_TX_Str("\r\n");
    32c2:	8a ed       	ldi	r24, 0xDA	; 218
    32c4:	92 e0       	ldi	r25, 0x02	; 2
    32c6:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    32ca:	8a ed       	ldi	r24, 0xDA	; 218
    32cc:	92 e0       	ldi	r25, 0x02	; 2
    32ce:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("Which lamp do you want to be Closed(From 1 to 5)\r\n");
    32d2:	87 e1       	ldi	r24, 0x17	; 23
    32d4:	94 e0       	ldi	r25, 0x04	; 4
    32d6:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("6.All Lamps\r\n");
    32da:	80 eb       	ldi	r24, 0xB0	; 176
    32dc:	93 e0       	ldi	r25, 0x03	; 3
    32de:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    32e2:	8a ed       	ldi	r24, 0xDA	; 218
    32e4:	92 e0       	ldi	r25, 0x02	; 2
    32e6:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>

                        while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    32ea:	5f 9b       	sbis	0x0b, 7	; 11
    32ec:	fe cf       	rjmp	.-4      	; 0x32ea <__vector_13+0x1274>
                        UART_GetValue = UART_RX_Char(); // Receiving the command
    32ee:	0e 94 37 10 	call	0x206e	; 0x206e <UART_RX_Char>
    32f2:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <UART_GetValue>

                        // CLose first lamp
                        if (UART_GetValue == '1') {
    32f6:	81 33       	cpi	r24, 0x31	; 49
    32f8:	69 f4       	brne	.+26     	; 0x3314 <__vector_13+0x129e>
                                LED0_OFF();
    32fa:	0e 94 b2 0c 	call	0x1964	; 0x1964 <LED0_OFF>
                                // If there is no keypad user, using LCD to write the operating device
                                if (!eme_check) {
    32fe:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    3302:	81 11       	cpse	r24, r1
    3304:	61 c0       	rjmp	.+194    	; 0x33c8 <__vector_13+0x1352>
                                        LCD_Clear();
    3306:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                        LCD_Write_String("Lamp(1) Closed");
    330a:	8a e4       	ldi	r24, 0x4A	; 74
    330c:	94 e0       	ldi	r25, 0x04	; 4
    330e:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
    3312:	5a c0       	rjmp	.+180    	; 0x33c8 <__vector_13+0x1352>
                                }
                        }
                        // Close second lamp
                        else if (UART_GetValue == '2') {
    3314:	82 33       	cpi	r24, 0x32	; 50
    3316:	69 f4       	brne	.+26     	; 0x3332 <__vector_13+0x12bc>
                                LED1_OFF();
    3318:	0e 94 ce 0c 	call	0x199c	; 0x199c <LED1_OFF>
                                // If there is no keypad user, using LCD to write the operating device
                                if (!eme_check) {
    331c:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    3320:	81 11       	cpse	r24, r1
    3322:	52 c0       	rjmp	.+164    	; 0x33c8 <__vector_13+0x1352>
                                        LCD_Clear();
    3324:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                        LCD_Write_String("Lamp(2) Closed");
    3328:	89 e5       	ldi	r24, 0x59	; 89
    332a:	94 e0       	ldi	r25, 0x04	; 4
    332c:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
    3330:	4b c0       	rjmp	.+150    	; 0x33c8 <__vector_13+0x1352>
                                }
                        }
                        // Close third lamp
                        else if (UART_GetValue == '3') {
    3332:	83 33       	cpi	r24, 0x33	; 51
    3334:	69 f4       	brne	.+26     	; 0x3350 <__vector_13+0x12da>
                                LED2_OFF();
    3336:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <LED2_OFF>
                                // If there is no keypad user, using LCD to write the operating device
                                if (!eme_check) {
    333a:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    333e:	81 11       	cpse	r24, r1
    3340:	43 c0       	rjmp	.+134    	; 0x33c8 <__vector_13+0x1352>
                                        LCD_Clear();
    3342:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                        LCD_Write_String("Lamp(3) Closed");
    3346:	88 e6       	ldi	r24, 0x68	; 104
    3348:	94 e0       	ldi	r25, 0x04	; 4
    334a:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
    334e:	3c c0       	rjmp	.+120    	; 0x33c8 <__vector_13+0x1352>
                                }
                        }
                        // Close fourth lamp
                        else if (UART_GetValue == '4') {
    3350:	84 33       	cpi	r24, 0x34	; 52
    3352:	69 f4       	brne	.+26     	; 0x336e <__vector_13+0x12f8>
                                LED3_OFF();
    3354:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <LED3_OFF>
                                // If there is no keypad user, using LCD to write the operating device
                                if (!eme_check) {
    3358:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    335c:	81 11       	cpse	r24, r1
    335e:	34 c0       	rjmp	.+104    	; 0x33c8 <__vector_13+0x1352>
                                        LCD_Clear();
    3360:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                        LCD_Write_String("Lamp(4) Closed");
    3364:	87 e7       	ldi	r24, 0x77	; 119
    3366:	94 e0       	ldi	r25, 0x04	; 4
    3368:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
    336c:	2d c0       	rjmp	.+90     	; 0x33c8 <__vector_13+0x1352>
                                }
                        }
                        // Close fifth lamp
                        else if (UART_GetValue == '5') {
    336e:	85 33       	cpi	r24, 0x35	; 53
    3370:	69 f4       	brne	.+26     	; 0x338c <__vector_13+0x1316>
                                LED4_OFF();
    3372:	0e 94 22 0d 	call	0x1a44	; 0x1a44 <LED4_OFF>
                                // If there is no keypad user, using LCD to write the operating device
                                if (!eme_check) {
    3376:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    337a:	81 11       	cpse	r24, r1
    337c:	25 c0       	rjmp	.+74     	; 0x33c8 <__vector_13+0x1352>
                                        LCD_Clear();
    337e:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                        LCD_Write_String("Lamp(5) Closed");
    3382:	86 e8       	ldi	r24, 0x86	; 134
    3384:	94 e0       	ldi	r25, 0x04	; 4
    3386:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
    338a:	1e c0       	rjmp	.+60     	; 0x33c8 <__vector_13+0x1352>
                                }
                        }
                        // Close all lamps
                        else if (UART_GetValue == '6') {
    338c:	86 33       	cpi	r24, 0x36	; 54
    338e:	e1 f4       	brne	.+56     	; 0x33c8 <__vector_13+0x1352>
                                LED0_OFF();
    3390:	0e 94 b2 0c 	call	0x1964	; 0x1964 <LED0_OFF>
                                LED1_OFF();
    3394:	0e 94 ce 0c 	call	0x199c	; 0x199c <LED1_OFF>
                                LED2_OFF();
    3398:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <LED2_OFF>
                                LED3_OFF();
    339c:	0e 94 06 0d 	call	0x1a0c	; 0x1a0c <LED3_OFF>
                                LED4_OFF();
    33a0:	0e 94 22 0d 	call	0x1a44	; 0x1a44 <LED4_OFF>
                                LCD_Clear();
    33a4:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                // If there is no keypad user, using LCD to write the operating device
                                if (!eme_check) {
    33a8:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    33ac:	81 11       	cpse	r24, r1
    33ae:	0c c0       	rjmp	.+24     	; 0x33c8 <__vector_13+0x1352>
                                        LCD_Write_String("All Lamps Are");
    33b0:	89 e0       	ldi	r24, 0x09	; 9
    33b2:	94 e0       	ldi	r25, 0x04	; 4
    33b4:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                                        LCD_Goto(1, 0);
    33b8:	60 e0       	ldi	r22, 0x00	; 0
    33ba:	81 e0       	ldi	r24, 0x01	; 1
    33bc:	0e 94 83 0c 	call	0x1906	; 0x1906 <LCD_Goto>
                                        LCD_Write_String("Closed");
    33c0:	82 e5       	ldi	r24, 0x52	; 82
    33c2:	94 e0       	ldi	r25, 0x04	; 4
    33c4:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                                }
                        }
                        // If there is no keypad user, using LCD to write & clear the operating device
                        if (!eme_check)
    33c8:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    33cc:	81 11       	cpse	r24, r1
    33ce:	4b c1       	rjmp	.+662    	; 0x3666 <__vector_13+0x15f0>
                                Timer2_SetDelay(2000); // Clearing LCD after 2 seconds using timer 2
    33d0:	60 ed       	ldi	r22, 0xD0	; 208
    33d2:	77 e0       	ldi	r23, 0x07	; 7
    33d4:	80 e0       	ldi	r24, 0x00	; 0
    33d6:	90 e0       	ldi	r25, 0x00	; 0
    33d8:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <Timer2_SetDelay>
    33dc:	44 c1       	rjmp	.+648    	; 0x3666 <__vector_13+0x15f0>
                } else if (UART_GetValue == '3') {
    33de:	83 33       	cpi	r24, 0x33	; 51
    33e0:	09 f0       	breq	.+2      	; 0x33e4 <__vector_13+0x136e>
    33e2:	cf c0       	rjmp	.+414    	; 0x3582 <__vector_13+0x150c>
                        /*Dimmer circuit*/
                        UART_TX_Str("\r\n");
    33e4:	8a ed       	ldi	r24, 0xDA	; 218
    33e6:	92 e0       	ldi	r25, 0x02	; 2
    33e8:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    33ec:	8a ed       	ldi	r24, 0xDA	; 218
    33ee:	92 e0       	ldi	r25, 0x02	; 2
    33f0:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("Please enter the percentage of the lamp\r\n");
    33f4:	85 e9       	ldi	r24, 0x95	; 149
    33f6:	94 e0       	ldi	r25, 0x04	; 4
    33f8:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    33fc:	8a ed       	ldi	r24, 0xDA	; 218
    33fe:	92 e0       	ldi	r25, 0x02	; 2
    3400:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>

                        Dimmer_Value = 0; // making sure that dimmer value equal 0
    3404:	10 92 e9 07 	sts	0x07E9, r1	; 0x8007e9 <Dimmer_Value>
    3408:	10 92 ea 07 	sts	0x07EA, r1	; 0x8007ea <Dimmer_Value+0x1>
    340c:	10 92 eb 07 	sts	0x07EB, r1	; 0x8007eb <Dimmer_Value+0x2>
    3410:	10 92 ec 07 	sts	0x07EC, r1	; 0x8007ec <Dimmer_Value+0x3>

                        // Taking the dimmer value as characters
                        for (Uint8 i = 0; i < 3; i++) {
    3414:	00 e0       	ldi	r16, 0x00	; 0
    3416:	38 c0       	rjmp	.+112    	; 0x3488 <__vector_13+0x1412>
                                while (!Get_Bit(UCSRA, 7)); // Polling until the user enter a character
    3418:	5f 9b       	sbis	0x0b, 7	; 11
    341a:	fe cf       	rjmp	.-4      	; 0x3418 <__vector_13+0x13a2>
                                Dimmer_Array[i] = UART_RX_Char(); // Receiving dimmer character values
    341c:	e0 2e       	mov	r14, r16
    341e:	f1 2c       	mov	r15, r1
    3420:	0e 94 37 10 	call	0x206e	; 0x206e <UART_RX_Char>
    3424:	18 2f       	mov	r17, r24
    3426:	f7 01       	movw	r30, r14
    3428:	e3 51       	subi	r30, 0x13	; 19
    342a:	f8 4f       	sbci	r31, 0xF8	; 248
    342c:	80 83       	st	Z, r24

                                // Converting Dimmer value from characters to integer to send it as duty cycle to timer(0)
                                if (Dimmer_Array[i] >= 48 && Dimmer_Array[i] <= 57) {
    342e:	80 ed       	ldi	r24, 0xD0	; 208
    3430:	81 0f       	add	r24, r17
    3432:	8a 30       	cpi	r24, 0x0A	; 10
    3434:	38 f5       	brcc	.+78     	; 0x3484 <__vector_13+0x140e>
                                        Dimmer_Value = Dimmer_Value * 10 + (Dimmer_Array[i] - 48);
    3436:	20 e0       	ldi	r18, 0x00	; 0
    3438:	30 e0       	ldi	r19, 0x00	; 0
    343a:	40 e2       	ldi	r20, 0x20	; 32
    343c:	51 e4       	ldi	r21, 0x41	; 65
    343e:	60 91 e9 07 	lds	r22, 0x07E9	; 0x8007e9 <Dimmer_Value>
    3442:	70 91 ea 07 	lds	r23, 0x07EA	; 0x8007ea <Dimmer_Value+0x1>
    3446:	80 91 eb 07 	lds	r24, 0x07EB	; 0x8007eb <Dimmer_Value+0x2>
    344a:	90 91 ec 07 	lds	r25, 0x07EC	; 0x8007ec <Dimmer_Value+0x3>
    344e:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <__mulsf3>
    3452:	6b 01       	movw	r12, r22
    3454:	7c 01       	movw	r14, r24
    3456:	61 2f       	mov	r22, r17
    3458:	70 e0       	ldi	r23, 0x00	; 0
    345a:	60 53       	subi	r22, 0x30	; 48
    345c:	71 09       	sbc	r23, r1
    345e:	07 2e       	mov	r0, r23
    3460:	00 0c       	add	r0, r0
    3462:	88 0b       	sbc	r24, r24
    3464:	99 0b       	sbc	r25, r25
    3466:	0e 94 b6 1c 	call	0x396c	; 0x396c <__floatsisf>
    346a:	a7 01       	movw	r20, r14
    346c:	96 01       	movw	r18, r12
    346e:	0e 94 a2 1b 	call	0x3744	; 0x3744 <__addsf3>
    3472:	60 93 e9 07 	sts	0x07E9, r22	; 0x8007e9 <Dimmer_Value>
    3476:	70 93 ea 07 	sts	0x07EA, r23	; 0x8007ea <Dimmer_Value+0x1>
    347a:	80 93 eb 07 	sts	0x07EB, r24	; 0x8007eb <Dimmer_Value+0x2>
    347e:	90 93 ec 07 	sts	0x07EC, r25	; 0x8007ec <Dimmer_Value+0x3>
    3482:	01 c0       	rjmp	.+2      	; 0x3486 <__vector_13+0x1410>
                                }
                                // if the value of character not from 48 to 57 (which is the number characters in ASCII table) these means that user entered the desired value and want to  escape other values
                                else {
                                        i = 5; // Exiting the for loop in which user enter the character values of dimmer circuit
    3484:	05 e0       	ldi	r16, 0x05	; 5
                        UART_TX_Str("\r\n");

                        Dimmer_Value = 0; // making sure that dimmer value equal 0

                        // Taking the dimmer value as characters
                        for (Uint8 i = 0; i < 3; i++) {
    3486:	0f 5f       	subi	r16, 0xFF	; 255
    3488:	03 30       	cpi	r16, 0x03	; 3
    348a:	30 f2       	brcs	.-116    	; 0x3418 <__vector_13+0x13a2>
                                }

                        }

                        // If there is no keypad user, using LCD to write the operating device
                        if (!eme_check) {
    348c:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    3490:	81 11       	cpse	r24, r1
    3492:	23 c0       	rjmp	.+70     	; 0x34da <__vector_13+0x1464>
                                LCD_Clear();
    3494:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                LCD_Write_String("Lamp ON!");
    3498:	8f eb       	ldi	r24, 0xBF	; 191
    349a:	94 e0       	ldi	r25, 0x04	; 4
    349c:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                                LCD_Goto(1, 0);
    34a0:	60 e0       	ldi	r22, 0x00	; 0
    34a2:	81 e0       	ldi	r24, 0x01	; 1
    34a4:	0e 94 83 0c 	call	0x1906	; 0x1906 <LCD_Goto>
                                LCD_Write_String("Percentage:");
    34a8:	88 ec       	ldi	r24, 0xC8	; 200
    34aa:	94 e0       	ldi	r25, 0x04	; 4
    34ac:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                                LCD_Write_Integer(Dimmer_Value);
    34b0:	60 91 e9 07 	lds	r22, 0x07E9	; 0x8007e9 <Dimmer_Value>
    34b4:	70 91 ea 07 	lds	r23, 0x07EA	; 0x8007ea <Dimmer_Value+0x1>
    34b8:	80 91 eb 07 	lds	r24, 0x07EB	; 0x8007eb <Dimmer_Value+0x2>
    34bc:	90 91 ec 07 	lds	r25, 0x07EC	; 0x8007ec <Dimmer_Value+0x3>
    34c0:	0e 94 85 1c 	call	0x390a	; 0x390a <__fixunssfsi>
    34c4:	0e 94 0c 0c 	call	0x1818	; 0x1818 <LCD_Write_Integer>
                                LCD_Write_Char('%');
    34c8:	85 e2       	ldi	r24, 0x25	; 37
    34ca:	0e 94 b8 0b 	call	0x1770	; 0x1770 <LCD_Write_Char>
                                Timer2_SetDelay(2000);
    34ce:	60 ed       	ldi	r22, 0xD0	; 208
    34d0:	77 e0       	ldi	r23, 0x07	; 7
    34d2:	80 e0       	ldi	r24, 0x00	; 0
    34d4:	90 e0       	ldi	r25, 0x00	; 0
    34d6:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <Timer2_SetDelay>
                        }

                        // To avoid twitch of dimmer lamp
                        if (Dimmer_Value >= 58 && Dimmer_Value <= 60) {
    34da:	c0 90 e9 07 	lds	r12, 0x07E9	; 0x8007e9 <Dimmer_Value>
    34de:	d0 90 ea 07 	lds	r13, 0x07EA	; 0x8007ea <Dimmer_Value+0x1>
    34e2:	e0 90 eb 07 	lds	r14, 0x07EB	; 0x8007eb <Dimmer_Value+0x2>
    34e6:	f0 90 ec 07 	lds	r15, 0x07EC	; 0x8007ec <Dimmer_Value+0x3>
    34ea:	20 e0       	ldi	r18, 0x00	; 0
    34ec:	30 e0       	ldi	r19, 0x00	; 0
    34ee:	48 e6       	ldi	r20, 0x68	; 104
    34f0:	52 e4       	ldi	r21, 0x42	; 66
    34f2:	c7 01       	movw	r24, r14
    34f4:	b6 01       	movw	r22, r12
    34f6:	0e 94 66 1d 	call	0x3acc	; 0x3acc <__gesf2>
    34fa:	88 23       	and	r24, r24
    34fc:	bc f0       	brlt	.+46     	; 0x352c <__vector_13+0x14b6>
    34fe:	20 e0       	ldi	r18, 0x00	; 0
    3500:	30 e0       	ldi	r19, 0x00	; 0
    3502:	40 e7       	ldi	r20, 0x70	; 112
    3504:	52 e4       	ldi	r21, 0x42	; 66
    3506:	c7 01       	movw	r24, r14
    3508:	b6 01       	movw	r22, r12
    350a:	0e 94 0e 1c 	call	0x381c	; 0x381c <__cmpsf2>
    350e:	18 16       	cp	r1, r24
    3510:	6c f0       	brlt	.+26     	; 0x352c <__vector_13+0x14b6>
                                Dimmer_Value = 55;
    3512:	80 e0       	ldi	r24, 0x00	; 0
    3514:	90 e0       	ldi	r25, 0x00	; 0
    3516:	ac e5       	ldi	r26, 0x5C	; 92
    3518:	b2 e4       	ldi	r27, 0x42	; 66
    351a:	80 93 e9 07 	sts	0x07E9, r24	; 0x8007e9 <Dimmer_Value>
    351e:	90 93 ea 07 	sts	0x07EA, r25	; 0x8007ea <Dimmer_Value+0x1>
    3522:	a0 93 eb 07 	sts	0x07EB, r26	; 0x8007eb <Dimmer_Value+0x2>
    3526:	b0 93 ec 07 	sts	0x07EC, r27	; 0x8007ec <Dimmer_Value+0x3>
    352a:	20 c0       	rjmp	.+64     	; 0x356c <__vector_13+0x14f6>
                        } else if (Dimmer_Value > 60 && Dimmer_Value <= 62) {
    352c:	20 e0       	ldi	r18, 0x00	; 0
    352e:	30 e0       	ldi	r19, 0x00	; 0
    3530:	40 e7       	ldi	r20, 0x70	; 112
    3532:	52 e4       	ldi	r21, 0x42	; 66
    3534:	c7 01       	movw	r24, r14
    3536:	b6 01       	movw	r22, r12
    3538:	0e 94 66 1d 	call	0x3acc	; 0x3acc <__gesf2>
    353c:	18 16       	cp	r1, r24
    353e:	b4 f4       	brge	.+44     	; 0x356c <__vector_13+0x14f6>
    3540:	20 e0       	ldi	r18, 0x00	; 0
    3542:	30 e0       	ldi	r19, 0x00	; 0
    3544:	48 e7       	ldi	r20, 0x78	; 120
    3546:	52 e4       	ldi	r21, 0x42	; 66
    3548:	c7 01       	movw	r24, r14
    354a:	b6 01       	movw	r22, r12
    354c:	0e 94 0e 1c 	call	0x381c	; 0x381c <__cmpsf2>
    3550:	18 16       	cp	r1, r24
    3552:	64 f0       	brlt	.+24     	; 0x356c <__vector_13+0x14f6>
                                Dimmer_Value = 65;
    3554:	80 e0       	ldi	r24, 0x00	; 0
    3556:	90 e0       	ldi	r25, 0x00	; 0
    3558:	a2 e8       	ldi	r26, 0x82	; 130
    355a:	b2 e4       	ldi	r27, 0x42	; 66
    355c:	80 93 e9 07 	sts	0x07E9, r24	; 0x8007e9 <Dimmer_Value>
    3560:	90 93 ea 07 	sts	0x07EA, r25	; 0x8007ea <Dimmer_Value+0x1>
    3564:	a0 93 eb 07 	sts	0x07EB, r26	; 0x8007eb <Dimmer_Value+0x2>
    3568:	b0 93 ec 07 	sts	0x07EC, r27	; 0x8007ec <Dimmer_Value+0x3>
                        }

                        PWM0_Gen(Dimmer_Value); // Sending dimmer as duty cycle to timer(0)
    356c:	60 91 e9 07 	lds	r22, 0x07E9	; 0x8007e9 <Dimmer_Value>
    3570:	70 91 ea 07 	lds	r23, 0x07EA	; 0x8007ea <Dimmer_Value+0x1>
    3574:	80 91 eb 07 	lds	r24, 0x07EB	; 0x8007eb <Dimmer_Value+0x2>
    3578:	90 91 ec 07 	lds	r25, 0x07EC	; 0x8007ec <Dimmer_Value+0x3>
    357c:	0e 94 ed 0d 	call	0x1bda	; 0x1bda <PWM0_Gen>
    3580:	72 c0       	rjmp	.+228    	; 0x3666 <__vector_13+0x15f0>
                } else if (UART_GetValue == '4') {
    3582:	84 33       	cpi	r24, 0x34	; 52
    3584:	09 f0       	breq	.+2      	; 0x3588 <__vector_13+0x1512>
    3586:	50 c0       	rjmp	.+160    	; 0x3628 <__vector_13+0x15b2>
                        /*--------------->Display temperature<----------------*/
                        // Declaring temperature array which take the temperature value from temperature integer that take its value from the temperature
                        Uint8 Temp_array[2] = {
    3588:	1a 86       	std	Y+10, r1	; 0x0a
    358a:	19 86       	std	Y+9, r1	; 0x09
                                0
                        };
                        Uint8 Temp_Divide = Temp; // Saving the value in other variable to do some operations
    358c:	90 91 ce 07 	lds	r25, 0x07CE	; 0x8007ce <__data_end>

                        // Converting the integer value to characters and saved in the temperature array
                        for (Uint8 i = 0; i < 2; i++) {
    3590:	20 e0       	ldi	r18, 0x00	; 0
    3592:	17 c0       	rjmp	.+46     	; 0x35c2 <__vector_13+0x154c>
                                Temp_array[i] = Temp_Divide % 10;
    3594:	e9 e0       	ldi	r30, 0x09	; 9
    3596:	f0 e0       	ldi	r31, 0x00	; 0
    3598:	ec 0f       	add	r30, r28
    359a:	fd 1f       	adc	r31, r29
    359c:	e2 0f       	add	r30, r18
    359e:	f1 1d       	adc	r31, r1
    35a0:	8d ec       	ldi	r24, 0xCD	; 205
    35a2:	98 9f       	mul	r25, r24
    35a4:	81 2d       	mov	r24, r1
    35a6:	11 24       	eor	r1, r1
    35a8:	86 95       	lsr	r24
    35aa:	86 95       	lsr	r24
    35ac:	86 95       	lsr	r24
    35ae:	48 2f       	mov	r20, r24
    35b0:	44 0f       	add	r20, r20
    35b2:	34 2f       	mov	r19, r20
    35b4:	33 0f       	add	r19, r19
    35b6:	33 0f       	add	r19, r19
    35b8:	34 0f       	add	r19, r20
    35ba:	93 1b       	sub	r25, r19
    35bc:	90 83       	st	Z, r25
                                Temp_Divide /= 10;
    35be:	98 2f       	mov	r25, r24
                                0
                        };
                        Uint8 Temp_Divide = Temp; // Saving the value in other variable to do some operations

                        // Converting the integer value to characters and saved in the temperature array
                        for (Uint8 i = 0; i < 2; i++) {
    35c0:	2f 5f       	subi	r18, 0xFF	; 255
    35c2:	22 30       	cpi	r18, 0x02	; 2
    35c4:	38 f3       	brcs	.-50     	; 0x3594 <__vector_13+0x151e>
                                Temp_array[i] = Temp_Divide % 10;
                                Temp_Divide /= 10;
                        }

                        // Display the temperature
                        UART_TX_Str("\r\n");
    35c6:	8a ed       	ldi	r24, 0xDA	; 218
    35c8:	92 e0       	ldi	r25, 0x02	; 2
    35ca:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    35ce:	8a ed       	ldi	r24, 0xDA	; 218
    35d0:	92 e0       	ldi	r25, 0x02	; 2
    35d2:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("Temperature:\r\n");
    35d6:	84 ed       	ldi	r24, 0xD4	; 212
    35d8:	94 e0       	ldi	r25, 0x04	; 4
    35da:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Char(Temp_array[1] + 48);
    35de:	8a 85       	ldd	r24, Y+10	; 0x0a
    35e0:	80 5d       	subi	r24, 0xD0	; 208
    35e2:	0e 94 20 10 	call	0x2040	; 0x2040 <UART_TX_Char>
                        UART_TX_Char(Temp_array[0] + 48);
    35e6:	89 85       	ldd	r24, Y+9	; 0x09
    35e8:	80 5d       	subi	r24, 0xD0	; 208
    35ea:	0e 94 20 10 	call	0x2040	; 0x2040 <UART_TX_Char>
                        UART_TX_Str("\r\n");
    35ee:	8a ed       	ldi	r24, 0xDA	; 218
    35f0:	92 e0       	ldi	r25, 0x02	; 2
    35f2:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>

                        // If there is no keypad user, using LCD to write the operating device
                        if (!eme_check) {
    35f6:	80 91 d1 07 	lds	r24, 0x07D1	; 0x8007d1 <eme_check>
    35fa:	81 11       	cpse	r24, r1
    35fc:	34 c0       	rjmp	.+104    	; 0x3666 <__vector_13+0x15f0>
                                LCD_Clear();
    35fe:	0e 94 7f 0c 	call	0x18fe	; 0x18fe <LCD_Clear>
                                LCD_Write_String("Temperature:");
    3602:	8e e0       	ldi	r24, 0x0E	; 14
    3604:	91 e0       	ldi	r25, 0x01	; 1
    3606:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <LCD_Write_String>
                                LCD_Write_Integer(Temp);
    360a:	60 91 ce 07 	lds	r22, 0x07CE	; 0x8007ce <__data_end>
    360e:	70 91 cf 07 	lds	r23, 0x07CF	; 0x8007cf <__data_end+0x1>
    3612:	80 e0       	ldi	r24, 0x00	; 0
    3614:	90 e0       	ldi	r25, 0x00	; 0
    3616:	0e 94 0c 0c 	call	0x1818	; 0x1818 <LCD_Write_Integer>
                                Timer2_SetDelay(2000);
    361a:	60 ed       	ldi	r22, 0xD0	; 208
    361c:	77 e0       	ldi	r23, 0x07	; 7
    361e:	80 e0       	ldi	r24, 0x00	; 0
    3620:	90 e0       	ldi	r25, 0x00	; 0
    3622:	0e 94 f4 0e 	call	0x1de8	; 0x1de8 <Timer2_SetDelay>
    3626:	1f c0       	rjmp	.+62     	; 0x3666 <__vector_13+0x15f0>
                        }
                } else if (UART_GetValue == '0') {
    3628:	80 33       	cpi	r24, 0x30	; 48
    362a:	79 f4       	brne	.+30     	; 0x364a <__vector_13+0x15d4>
                        /*------------->Loging-Out From The System<--------------*/
                        SYS_Check = 0; // 0 is the value that take the system to the login operation
    362c:	10 92 f4 07 	sts	0x07F4, r1	; 0x8007f4 <SYS_Check>
                        UART_TX_Str("\r\n");
    3630:	8a ed       	ldi	r24, 0xDA	; 218
    3632:	92 e0       	ldi	r25, 0x02	; 2
    3634:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    3638:	8a ed       	ldi	r24, 0xDA	; 218
    363a:	92 e0       	ldi	r25, 0x02	; 2
    363c:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("Bye-Bye user\r\n");
    3640:	80 e6       	ldi	r24, 0x60	; 96
    3642:	96 e0       	ldi	r25, 0x06	; 6
    3644:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
    3648:	0e c0       	rjmp	.+28     	; 0x3666 <__vector_13+0x15f0>
                }
                // *Not Important to Know* where the CMD_Check take the system to do nothing and avoid any complicated link between login operation and admin logged-in oparation
                else if (UART_GetValue == 8) {
    364a:	88 30       	cpi	r24, 0x08	; 8
    364c:	61 f0       	breq	.+24     	; 0x3666 <__vector_13+0x15f0>

                }
                // Entering wrong command
                else {
                        UART_TX_Str("\r\n");
    364e:	8a ed       	ldi	r24, 0xDA	; 218
    3650:	92 e0       	ldi	r25, 0x02	; 2
    3652:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    3656:	8a ed       	ldi	r24, 0xDA	; 218
    3658:	92 e0       	ldi	r25, 0x02	; 2
    365a:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("Please enter command number\r\n");
    365e:	85 e4       	ldi	r24, 0x45	; 69
    3660:	93 e0       	ldi	r25, 0x03	; 3
    3662:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                }
                /*----------->Command List<--------------*/
                // If there is a user
                if (SYS_Check) {
    3666:	80 91 f4 07 	lds	r24, 0x07F4	; 0x8007f4 <SYS_Check>
    366a:	88 23       	and	r24, r24
    366c:	69 f1       	breq	.+90     	; 0x36c8 <__vector_13+0x1652>
                        UART_TX_Str("\r\n");
    366e:	8a ed       	ldi	r24, 0xDA	; 218
    3670:	92 e0       	ldi	r25, 0x02	; 2
    3672:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    3676:	8a ed       	ldi	r24, 0xDA	; 218
    3678:	92 e0       	ldi	r25, 0x02	; 2
    367a:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("Waiting for your command\r\n");
    367e:	88 e8       	ldi	r24, 0x88	; 136
    3680:	96 e0       	ldi	r25, 0x06	; 6
    3682:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    3686:	8a ed       	ldi	r24, 0xDA	; 218
    3688:	92 e0       	ldi	r25, 0x02	; 2
    368a:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("1.Open lamps\r\n");
    368e:	82 e8       	ldi	r24, 0x82	; 130
    3690:	97 e0       	ldi	r25, 0x07	; 7
    3692:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("2.Close lamps\r\n");
    3696:	81 e9       	ldi	r24, 0x91	; 145
    3698:	97 e0       	ldi	r25, 0x07	; 7
    369a:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("3.Variant lamp\r\n");
    369e:	81 ea       	ldi	r24, 0xA1	; 161
    36a0:	97 e0       	ldi	r25, 0x07	; 7
    36a2:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("4.Display the temperature\r\n");
    36a6:	82 eb       	ldi	r24, 0xB2	; 178
    36a8:	97 e0       	ldi	r25, 0x07	; 7
    36aa:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("0.Logout\r\n");
    36ae:	80 e5       	ldi	r24, 0x50	; 80
    36b0:	97 e0       	ldi	r25, 0x07	; 7
    36b2:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("Reply with the number of the command\r\n");
    36b6:	8b e5       	ldi	r24, 0x5B	; 91
    36b8:	97 e0       	ldi	r25, 0x07	; 7
    36ba:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    36be:	8a ed       	ldi	r24, 0xDA	; 218
    36c0:	92 e0       	ldi	r25, 0x02	; 2
    36c2:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
    36c6:	0c c0       	rjmp	.+24     	; 0x36e0 <__vector_13+0x166a>
                }
                // if there is not user
                else {
                        UART_TX_Str("1.Enter Admin\r\n");
    36c8:	8c e6       	ldi	r24, 0x6C	; 108
    36ca:	92 e0       	ldi	r25, 0x02	; 2
    36cc:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("2.Enter User\r\n");
    36d0:	8c e7       	ldi	r24, 0x7C	; 124
    36d2:	92 e0       	ldi	r25, 0x02	; 2
    36d4:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                        UART_TX_Str("\r\n");
    36d8:	8a ed       	ldi	r24, 0xDA	; 218
    36da:	92 e0       	ldi	r25, 0x02	; 2
    36dc:	0e 94 24 10 	call	0x2048	; 0x2048 <UART_TX_Str>
                }
        }
}
    36e0:	2a 96       	adiw	r28, 0x0a	; 10
    36e2:	0f b6       	in	r0, 0x3f	; 63
    36e4:	f8 94       	cli
    36e6:	de bf       	out	0x3e, r29	; 62
    36e8:	0f be       	out	0x3f, r0	; 63
    36ea:	cd bf       	out	0x3d, r28	; 61
    36ec:	df 91       	pop	r29
    36ee:	cf 91       	pop	r28
    36f0:	ff 91       	pop	r31
    36f2:	ef 91       	pop	r30
    36f4:	bf 91       	pop	r27
    36f6:	af 91       	pop	r26
    36f8:	9f 91       	pop	r25
    36fa:	8f 91       	pop	r24
    36fc:	7f 91       	pop	r23
    36fe:	6f 91       	pop	r22
    3700:	5f 91       	pop	r21
    3702:	4f 91       	pop	r20
    3704:	3f 91       	pop	r19
    3706:	2f 91       	pop	r18
    3708:	1f 91       	pop	r17
    370a:	0f 91       	pop	r16
    370c:	ff 90       	pop	r15
    370e:	ef 90       	pop	r14
    3710:	df 90       	pop	r13
    3712:	cf 90       	pop	r12
    3714:	bf 90       	pop	r11
    3716:	af 90       	pop	r10
    3718:	9f 90       	pop	r9
    371a:	8f 90       	pop	r8
    371c:	7f 90       	pop	r7
    371e:	6f 90       	pop	r6
    3720:	5f 90       	pop	r5
    3722:	4f 90       	pop	r4
    3724:	0f 90       	pop	r0
    3726:	0f be       	out	0x3f, r0	; 63
    3728:	0f 90       	pop	r0
    372a:	1f 90       	pop	r1
    372c:	18 95       	reti

0000372e <__vector_15>:

ISR(USART_TXC_vect) {
    372e:	1f 92       	push	r1
    3730:	0f 92       	push	r0
    3732:	0f b6       	in	r0, 0x3f	; 63
    3734:	0f 92       	push	r0
    3736:	11 24       	eor	r1, r1
        // Write UART transmit handler here

    3738:	0f 90       	pop	r0
    373a:	0f be       	out	0x3f, r0	; 63
    373c:	0f 90       	pop	r0
    373e:	1f 90       	pop	r1
    3740:	18 95       	reti

00003742 <__subsf3>:
    3742:	50 58       	subi	r21, 0x80	; 128

00003744 <__addsf3>:
    3744:	bb 27       	eor	r27, r27
    3746:	aa 27       	eor	r26, r26
    3748:	0e 94 b9 1b 	call	0x3772	; 0x3772 <__addsf3x>
    374c:	0c 94 2c 1d 	jmp	0x3a58	; 0x3a58 <__fp_round>
    3750:	0e 94 1e 1d 	call	0x3a3c	; 0x3a3c <__fp_pscA>
    3754:	38 f0       	brcs	.+14     	; 0x3764 <__addsf3+0x20>
    3756:	0e 94 25 1d 	call	0x3a4a	; 0x3a4a <__fp_pscB>
    375a:	20 f0       	brcs	.+8      	; 0x3764 <__addsf3+0x20>
    375c:	39 f4       	brne	.+14     	; 0x376c <__addsf3+0x28>
    375e:	9f 3f       	cpi	r25, 0xFF	; 255
    3760:	19 f4       	brne	.+6      	; 0x3768 <__addsf3+0x24>
    3762:	26 f4       	brtc	.+8      	; 0x376c <__addsf3+0x28>
    3764:	0c 94 1b 1d 	jmp	0x3a36	; 0x3a36 <__fp_nan>
    3768:	0e f4       	brtc	.+2      	; 0x376c <__addsf3+0x28>
    376a:	e0 95       	com	r30
    376c:	e7 fb       	bst	r30, 7
    376e:	0c 94 15 1d 	jmp	0x3a2a	; 0x3a2a <__fp_inf>

00003772 <__addsf3x>:
    3772:	e9 2f       	mov	r30, r25
    3774:	0e 94 3d 1d 	call	0x3a7a	; 0x3a7a <__fp_split3>
    3778:	58 f3       	brcs	.-42     	; 0x3750 <__addsf3+0xc>
    377a:	ba 17       	cp	r27, r26
    377c:	62 07       	cpc	r22, r18
    377e:	73 07       	cpc	r23, r19
    3780:	84 07       	cpc	r24, r20
    3782:	95 07       	cpc	r25, r21
    3784:	20 f0       	brcs	.+8      	; 0x378e <__addsf3x+0x1c>
    3786:	79 f4       	brne	.+30     	; 0x37a6 <__addsf3x+0x34>
    3788:	a6 f5       	brtc	.+104    	; 0x37f2 <__addsf3x+0x80>
    378a:	0c 94 5f 1d 	jmp	0x3abe	; 0x3abe <__fp_zero>
    378e:	0e f4       	brtc	.+2      	; 0x3792 <__addsf3x+0x20>
    3790:	e0 95       	com	r30
    3792:	0b 2e       	mov	r0, r27
    3794:	ba 2f       	mov	r27, r26
    3796:	a0 2d       	mov	r26, r0
    3798:	0b 01       	movw	r0, r22
    379a:	b9 01       	movw	r22, r18
    379c:	90 01       	movw	r18, r0
    379e:	0c 01       	movw	r0, r24
    37a0:	ca 01       	movw	r24, r20
    37a2:	a0 01       	movw	r20, r0
    37a4:	11 24       	eor	r1, r1
    37a6:	ff 27       	eor	r31, r31
    37a8:	59 1b       	sub	r21, r25
    37aa:	99 f0       	breq	.+38     	; 0x37d2 <__addsf3x+0x60>
    37ac:	59 3f       	cpi	r21, 0xF9	; 249
    37ae:	50 f4       	brcc	.+20     	; 0x37c4 <__addsf3x+0x52>
    37b0:	50 3e       	cpi	r21, 0xE0	; 224
    37b2:	68 f1       	brcs	.+90     	; 0x380e <__addsf3x+0x9c>
    37b4:	1a 16       	cp	r1, r26
    37b6:	f0 40       	sbci	r31, 0x00	; 0
    37b8:	a2 2f       	mov	r26, r18
    37ba:	23 2f       	mov	r18, r19
    37bc:	34 2f       	mov	r19, r20
    37be:	44 27       	eor	r20, r20
    37c0:	58 5f       	subi	r21, 0xF8	; 248
    37c2:	f3 cf       	rjmp	.-26     	; 0x37aa <__addsf3x+0x38>
    37c4:	46 95       	lsr	r20
    37c6:	37 95       	ror	r19
    37c8:	27 95       	ror	r18
    37ca:	a7 95       	ror	r26
    37cc:	f0 40       	sbci	r31, 0x00	; 0
    37ce:	53 95       	inc	r21
    37d0:	c9 f7       	brne	.-14     	; 0x37c4 <__addsf3x+0x52>
    37d2:	7e f4       	brtc	.+30     	; 0x37f2 <__addsf3x+0x80>
    37d4:	1f 16       	cp	r1, r31
    37d6:	ba 0b       	sbc	r27, r26
    37d8:	62 0b       	sbc	r22, r18
    37da:	73 0b       	sbc	r23, r19
    37dc:	84 0b       	sbc	r24, r20
    37de:	ba f0       	brmi	.+46     	; 0x380e <__addsf3x+0x9c>
    37e0:	91 50       	subi	r25, 0x01	; 1
    37e2:	a1 f0       	breq	.+40     	; 0x380c <__addsf3x+0x9a>
    37e4:	ff 0f       	add	r31, r31
    37e6:	bb 1f       	adc	r27, r27
    37e8:	66 1f       	adc	r22, r22
    37ea:	77 1f       	adc	r23, r23
    37ec:	88 1f       	adc	r24, r24
    37ee:	c2 f7       	brpl	.-16     	; 0x37e0 <__addsf3x+0x6e>
    37f0:	0e c0       	rjmp	.+28     	; 0x380e <__addsf3x+0x9c>
    37f2:	ba 0f       	add	r27, r26
    37f4:	62 1f       	adc	r22, r18
    37f6:	73 1f       	adc	r23, r19
    37f8:	84 1f       	adc	r24, r20
    37fa:	48 f4       	brcc	.+18     	; 0x380e <__addsf3x+0x9c>
    37fc:	87 95       	ror	r24
    37fe:	77 95       	ror	r23
    3800:	67 95       	ror	r22
    3802:	b7 95       	ror	r27
    3804:	f7 95       	ror	r31
    3806:	9e 3f       	cpi	r25, 0xFE	; 254
    3808:	08 f0       	brcs	.+2      	; 0x380c <__addsf3x+0x9a>
    380a:	b0 cf       	rjmp	.-160    	; 0x376c <__addsf3+0x28>
    380c:	93 95       	inc	r25
    380e:	88 0f       	add	r24, r24
    3810:	08 f0       	brcs	.+2      	; 0x3814 <__addsf3x+0xa2>
    3812:	99 27       	eor	r25, r25
    3814:	ee 0f       	add	r30, r30
    3816:	97 95       	ror	r25
    3818:	87 95       	ror	r24
    381a:	08 95       	ret

0000381c <__cmpsf2>:
    381c:	0e 94 f1 1c 	call	0x39e2	; 0x39e2 <__fp_cmp>
    3820:	08 f4       	brcc	.+2      	; 0x3824 <__cmpsf2+0x8>
    3822:	81 e0       	ldi	r24, 0x01	; 1
    3824:	08 95       	ret

00003826 <__divsf3>:
    3826:	0e 94 27 1c 	call	0x384e	; 0x384e <__divsf3x>
    382a:	0c 94 2c 1d 	jmp	0x3a58	; 0x3a58 <__fp_round>
    382e:	0e 94 25 1d 	call	0x3a4a	; 0x3a4a <__fp_pscB>
    3832:	58 f0       	brcs	.+22     	; 0x384a <__divsf3+0x24>
    3834:	0e 94 1e 1d 	call	0x3a3c	; 0x3a3c <__fp_pscA>
    3838:	40 f0       	brcs	.+16     	; 0x384a <__divsf3+0x24>
    383a:	29 f4       	brne	.+10     	; 0x3846 <__divsf3+0x20>
    383c:	5f 3f       	cpi	r21, 0xFF	; 255
    383e:	29 f0       	breq	.+10     	; 0x384a <__divsf3+0x24>
    3840:	0c 94 15 1d 	jmp	0x3a2a	; 0x3a2a <__fp_inf>
    3844:	51 11       	cpse	r21, r1
    3846:	0c 94 60 1d 	jmp	0x3ac0	; 0x3ac0 <__fp_szero>
    384a:	0c 94 1b 1d 	jmp	0x3a36	; 0x3a36 <__fp_nan>

0000384e <__divsf3x>:
    384e:	0e 94 3d 1d 	call	0x3a7a	; 0x3a7a <__fp_split3>
    3852:	68 f3       	brcs	.-38     	; 0x382e <__divsf3+0x8>

00003854 <__divsf3_pse>:
    3854:	99 23       	and	r25, r25
    3856:	b1 f3       	breq	.-20     	; 0x3844 <__divsf3+0x1e>
    3858:	55 23       	and	r21, r21
    385a:	91 f3       	breq	.-28     	; 0x3840 <__divsf3+0x1a>
    385c:	95 1b       	sub	r25, r21
    385e:	55 0b       	sbc	r21, r21
    3860:	bb 27       	eor	r27, r27
    3862:	aa 27       	eor	r26, r26
    3864:	62 17       	cp	r22, r18
    3866:	73 07       	cpc	r23, r19
    3868:	84 07       	cpc	r24, r20
    386a:	38 f0       	brcs	.+14     	; 0x387a <__divsf3_pse+0x26>
    386c:	9f 5f       	subi	r25, 0xFF	; 255
    386e:	5f 4f       	sbci	r21, 0xFF	; 255
    3870:	22 0f       	add	r18, r18
    3872:	33 1f       	adc	r19, r19
    3874:	44 1f       	adc	r20, r20
    3876:	aa 1f       	adc	r26, r26
    3878:	a9 f3       	breq	.-22     	; 0x3864 <__divsf3_pse+0x10>
    387a:	35 d0       	rcall	.+106    	; 0x38e6 <__divsf3_pse+0x92>
    387c:	0e 2e       	mov	r0, r30
    387e:	3a f0       	brmi	.+14     	; 0x388e <__divsf3_pse+0x3a>
    3880:	e0 e8       	ldi	r30, 0x80	; 128
    3882:	32 d0       	rcall	.+100    	; 0x38e8 <__divsf3_pse+0x94>
    3884:	91 50       	subi	r25, 0x01	; 1
    3886:	50 40       	sbci	r21, 0x00	; 0
    3888:	e6 95       	lsr	r30
    388a:	00 1c       	adc	r0, r0
    388c:	ca f7       	brpl	.-14     	; 0x3880 <__divsf3_pse+0x2c>
    388e:	2b d0       	rcall	.+86     	; 0x38e6 <__divsf3_pse+0x92>
    3890:	fe 2f       	mov	r31, r30
    3892:	29 d0       	rcall	.+82     	; 0x38e6 <__divsf3_pse+0x92>
    3894:	66 0f       	add	r22, r22
    3896:	77 1f       	adc	r23, r23
    3898:	88 1f       	adc	r24, r24
    389a:	bb 1f       	adc	r27, r27
    389c:	26 17       	cp	r18, r22
    389e:	37 07       	cpc	r19, r23
    38a0:	48 07       	cpc	r20, r24
    38a2:	ab 07       	cpc	r26, r27
    38a4:	b0 e8       	ldi	r27, 0x80	; 128
    38a6:	09 f0       	breq	.+2      	; 0x38aa <__divsf3_pse+0x56>
    38a8:	bb 0b       	sbc	r27, r27
    38aa:	80 2d       	mov	r24, r0
    38ac:	bf 01       	movw	r22, r30
    38ae:	ff 27       	eor	r31, r31
    38b0:	93 58       	subi	r25, 0x83	; 131
    38b2:	5f 4f       	sbci	r21, 0xFF	; 255
    38b4:	3a f0       	brmi	.+14     	; 0x38c4 <__divsf3_pse+0x70>
    38b6:	9e 3f       	cpi	r25, 0xFE	; 254
    38b8:	51 05       	cpc	r21, r1
    38ba:	78 f0       	brcs	.+30     	; 0x38da <__divsf3_pse+0x86>
    38bc:	0c 94 15 1d 	jmp	0x3a2a	; 0x3a2a <__fp_inf>
    38c0:	0c 94 60 1d 	jmp	0x3ac0	; 0x3ac0 <__fp_szero>
    38c4:	5f 3f       	cpi	r21, 0xFF	; 255
    38c6:	e4 f3       	brlt	.-8      	; 0x38c0 <__divsf3_pse+0x6c>
    38c8:	98 3e       	cpi	r25, 0xE8	; 232
    38ca:	d4 f3       	brlt	.-12     	; 0x38c0 <__divsf3_pse+0x6c>
    38cc:	86 95       	lsr	r24
    38ce:	77 95       	ror	r23
    38d0:	67 95       	ror	r22
    38d2:	b7 95       	ror	r27
    38d4:	f7 95       	ror	r31
    38d6:	9f 5f       	subi	r25, 0xFF	; 255
    38d8:	c9 f7       	brne	.-14     	; 0x38cc <__divsf3_pse+0x78>
    38da:	88 0f       	add	r24, r24
    38dc:	91 1d       	adc	r25, r1
    38de:	96 95       	lsr	r25
    38e0:	87 95       	ror	r24
    38e2:	97 f9       	bld	r25, 7
    38e4:	08 95       	ret
    38e6:	e1 e0       	ldi	r30, 0x01	; 1
    38e8:	66 0f       	add	r22, r22
    38ea:	77 1f       	adc	r23, r23
    38ec:	88 1f       	adc	r24, r24
    38ee:	bb 1f       	adc	r27, r27
    38f0:	62 17       	cp	r22, r18
    38f2:	73 07       	cpc	r23, r19
    38f4:	84 07       	cpc	r24, r20
    38f6:	ba 07       	cpc	r27, r26
    38f8:	20 f0       	brcs	.+8      	; 0x3902 <__divsf3_pse+0xae>
    38fa:	62 1b       	sub	r22, r18
    38fc:	73 0b       	sbc	r23, r19
    38fe:	84 0b       	sbc	r24, r20
    3900:	ba 0b       	sbc	r27, r26
    3902:	ee 1f       	adc	r30, r30
    3904:	88 f7       	brcc	.-30     	; 0x38e8 <__divsf3_pse+0x94>
    3906:	e0 95       	com	r30
    3908:	08 95       	ret

0000390a <__fixunssfsi>:
    390a:	0e 94 45 1d 	call	0x3a8a	; 0x3a8a <__fp_splitA>
    390e:	88 f0       	brcs	.+34     	; 0x3932 <__fixunssfsi+0x28>
    3910:	9f 57       	subi	r25, 0x7F	; 127
    3912:	98 f0       	brcs	.+38     	; 0x393a <__fixunssfsi+0x30>
    3914:	b9 2f       	mov	r27, r25
    3916:	99 27       	eor	r25, r25
    3918:	b7 51       	subi	r27, 0x17	; 23
    391a:	b0 f0       	brcs	.+44     	; 0x3948 <__fixunssfsi+0x3e>
    391c:	e1 f0       	breq	.+56     	; 0x3956 <__fixunssfsi+0x4c>
    391e:	66 0f       	add	r22, r22
    3920:	77 1f       	adc	r23, r23
    3922:	88 1f       	adc	r24, r24
    3924:	99 1f       	adc	r25, r25
    3926:	1a f0       	brmi	.+6      	; 0x392e <__fixunssfsi+0x24>
    3928:	ba 95       	dec	r27
    392a:	c9 f7       	brne	.-14     	; 0x391e <__fixunssfsi+0x14>
    392c:	14 c0       	rjmp	.+40     	; 0x3956 <__fixunssfsi+0x4c>
    392e:	b1 30       	cpi	r27, 0x01	; 1
    3930:	91 f0       	breq	.+36     	; 0x3956 <__fixunssfsi+0x4c>
    3932:	0e 94 5f 1d 	call	0x3abe	; 0x3abe <__fp_zero>
    3936:	b1 e0       	ldi	r27, 0x01	; 1
    3938:	08 95       	ret
    393a:	0c 94 5f 1d 	jmp	0x3abe	; 0x3abe <__fp_zero>
    393e:	67 2f       	mov	r22, r23
    3940:	78 2f       	mov	r23, r24
    3942:	88 27       	eor	r24, r24
    3944:	b8 5f       	subi	r27, 0xF8	; 248
    3946:	39 f0       	breq	.+14     	; 0x3956 <__fixunssfsi+0x4c>
    3948:	b9 3f       	cpi	r27, 0xF9	; 249
    394a:	cc f3       	brlt	.-14     	; 0x393e <__fixunssfsi+0x34>
    394c:	86 95       	lsr	r24
    394e:	77 95       	ror	r23
    3950:	67 95       	ror	r22
    3952:	b3 95       	inc	r27
    3954:	d9 f7       	brne	.-10     	; 0x394c <__fixunssfsi+0x42>
    3956:	3e f4       	brtc	.+14     	; 0x3966 <__fixunssfsi+0x5c>
    3958:	90 95       	com	r25
    395a:	80 95       	com	r24
    395c:	70 95       	com	r23
    395e:	61 95       	neg	r22
    3960:	7f 4f       	sbci	r23, 0xFF	; 255
    3962:	8f 4f       	sbci	r24, 0xFF	; 255
    3964:	9f 4f       	sbci	r25, 0xFF	; 255
    3966:	08 95       	ret

00003968 <__floatunsisf>:
    3968:	e8 94       	clt
    396a:	09 c0       	rjmp	.+18     	; 0x397e <__floatsisf+0x12>

0000396c <__floatsisf>:
    396c:	97 fb       	bst	r25, 7
    396e:	3e f4       	brtc	.+14     	; 0x397e <__floatsisf+0x12>
    3970:	90 95       	com	r25
    3972:	80 95       	com	r24
    3974:	70 95       	com	r23
    3976:	61 95       	neg	r22
    3978:	7f 4f       	sbci	r23, 0xFF	; 255
    397a:	8f 4f       	sbci	r24, 0xFF	; 255
    397c:	9f 4f       	sbci	r25, 0xFF	; 255
    397e:	99 23       	and	r25, r25
    3980:	a9 f0       	breq	.+42     	; 0x39ac <__floatsisf+0x40>
    3982:	f9 2f       	mov	r31, r25
    3984:	96 e9       	ldi	r25, 0x96	; 150
    3986:	bb 27       	eor	r27, r27
    3988:	93 95       	inc	r25
    398a:	f6 95       	lsr	r31
    398c:	87 95       	ror	r24
    398e:	77 95       	ror	r23
    3990:	67 95       	ror	r22
    3992:	b7 95       	ror	r27
    3994:	f1 11       	cpse	r31, r1
    3996:	f8 cf       	rjmp	.-16     	; 0x3988 <__floatsisf+0x1c>
    3998:	fa f4       	brpl	.+62     	; 0x39d8 <__floatsisf+0x6c>
    399a:	bb 0f       	add	r27, r27
    399c:	11 f4       	brne	.+4      	; 0x39a2 <__floatsisf+0x36>
    399e:	60 ff       	sbrs	r22, 0
    39a0:	1b c0       	rjmp	.+54     	; 0x39d8 <__floatsisf+0x6c>
    39a2:	6f 5f       	subi	r22, 0xFF	; 255
    39a4:	7f 4f       	sbci	r23, 0xFF	; 255
    39a6:	8f 4f       	sbci	r24, 0xFF	; 255
    39a8:	9f 4f       	sbci	r25, 0xFF	; 255
    39aa:	16 c0       	rjmp	.+44     	; 0x39d8 <__floatsisf+0x6c>
    39ac:	88 23       	and	r24, r24
    39ae:	11 f0       	breq	.+4      	; 0x39b4 <__floatsisf+0x48>
    39b0:	96 e9       	ldi	r25, 0x96	; 150
    39b2:	11 c0       	rjmp	.+34     	; 0x39d6 <__floatsisf+0x6a>
    39b4:	77 23       	and	r23, r23
    39b6:	21 f0       	breq	.+8      	; 0x39c0 <__floatsisf+0x54>
    39b8:	9e e8       	ldi	r25, 0x8E	; 142
    39ba:	87 2f       	mov	r24, r23
    39bc:	76 2f       	mov	r23, r22
    39be:	05 c0       	rjmp	.+10     	; 0x39ca <__floatsisf+0x5e>
    39c0:	66 23       	and	r22, r22
    39c2:	71 f0       	breq	.+28     	; 0x39e0 <__floatsisf+0x74>
    39c4:	96 e8       	ldi	r25, 0x86	; 134
    39c6:	86 2f       	mov	r24, r22
    39c8:	70 e0       	ldi	r23, 0x00	; 0
    39ca:	60 e0       	ldi	r22, 0x00	; 0
    39cc:	2a f0       	brmi	.+10     	; 0x39d8 <__floatsisf+0x6c>
    39ce:	9a 95       	dec	r25
    39d0:	66 0f       	add	r22, r22
    39d2:	77 1f       	adc	r23, r23
    39d4:	88 1f       	adc	r24, r24
    39d6:	da f7       	brpl	.-10     	; 0x39ce <__floatsisf+0x62>
    39d8:	88 0f       	add	r24, r24
    39da:	96 95       	lsr	r25
    39dc:	87 95       	ror	r24
    39de:	97 f9       	bld	r25, 7
    39e0:	08 95       	ret

000039e2 <__fp_cmp>:
    39e2:	99 0f       	add	r25, r25
    39e4:	00 08       	sbc	r0, r0
    39e6:	55 0f       	add	r21, r21
    39e8:	aa 0b       	sbc	r26, r26
    39ea:	e0 e8       	ldi	r30, 0x80	; 128
    39ec:	fe ef       	ldi	r31, 0xFE	; 254
    39ee:	16 16       	cp	r1, r22
    39f0:	17 06       	cpc	r1, r23
    39f2:	e8 07       	cpc	r30, r24
    39f4:	f9 07       	cpc	r31, r25
    39f6:	c0 f0       	brcs	.+48     	; 0x3a28 <__fp_cmp+0x46>
    39f8:	12 16       	cp	r1, r18
    39fa:	13 06       	cpc	r1, r19
    39fc:	e4 07       	cpc	r30, r20
    39fe:	f5 07       	cpc	r31, r21
    3a00:	98 f0       	brcs	.+38     	; 0x3a28 <__fp_cmp+0x46>
    3a02:	62 1b       	sub	r22, r18
    3a04:	73 0b       	sbc	r23, r19
    3a06:	84 0b       	sbc	r24, r20
    3a08:	95 0b       	sbc	r25, r21
    3a0a:	39 f4       	brne	.+14     	; 0x3a1a <__fp_cmp+0x38>
    3a0c:	0a 26       	eor	r0, r26
    3a0e:	61 f0       	breq	.+24     	; 0x3a28 <__fp_cmp+0x46>
    3a10:	23 2b       	or	r18, r19
    3a12:	24 2b       	or	r18, r20
    3a14:	25 2b       	or	r18, r21
    3a16:	21 f4       	brne	.+8      	; 0x3a20 <__fp_cmp+0x3e>
    3a18:	08 95       	ret
    3a1a:	0a 26       	eor	r0, r26
    3a1c:	09 f4       	brne	.+2      	; 0x3a20 <__fp_cmp+0x3e>
    3a1e:	a1 40       	sbci	r26, 0x01	; 1
    3a20:	a6 95       	lsr	r26
    3a22:	8f ef       	ldi	r24, 0xFF	; 255
    3a24:	81 1d       	adc	r24, r1
    3a26:	81 1d       	adc	r24, r1
    3a28:	08 95       	ret

00003a2a <__fp_inf>:
    3a2a:	97 f9       	bld	r25, 7
    3a2c:	9f 67       	ori	r25, 0x7F	; 127
    3a2e:	80 e8       	ldi	r24, 0x80	; 128
    3a30:	70 e0       	ldi	r23, 0x00	; 0
    3a32:	60 e0       	ldi	r22, 0x00	; 0
    3a34:	08 95       	ret

00003a36 <__fp_nan>:
    3a36:	9f ef       	ldi	r25, 0xFF	; 255
    3a38:	80 ec       	ldi	r24, 0xC0	; 192
    3a3a:	08 95       	ret

00003a3c <__fp_pscA>:
    3a3c:	00 24       	eor	r0, r0
    3a3e:	0a 94       	dec	r0
    3a40:	16 16       	cp	r1, r22
    3a42:	17 06       	cpc	r1, r23
    3a44:	18 06       	cpc	r1, r24
    3a46:	09 06       	cpc	r0, r25
    3a48:	08 95       	ret

00003a4a <__fp_pscB>:
    3a4a:	00 24       	eor	r0, r0
    3a4c:	0a 94       	dec	r0
    3a4e:	12 16       	cp	r1, r18
    3a50:	13 06       	cpc	r1, r19
    3a52:	14 06       	cpc	r1, r20
    3a54:	05 06       	cpc	r0, r21
    3a56:	08 95       	ret

00003a58 <__fp_round>:
    3a58:	09 2e       	mov	r0, r25
    3a5a:	03 94       	inc	r0
    3a5c:	00 0c       	add	r0, r0
    3a5e:	11 f4       	brne	.+4      	; 0x3a64 <__fp_round+0xc>
    3a60:	88 23       	and	r24, r24
    3a62:	52 f0       	brmi	.+20     	; 0x3a78 <__fp_round+0x20>
    3a64:	bb 0f       	add	r27, r27
    3a66:	40 f4       	brcc	.+16     	; 0x3a78 <__fp_round+0x20>
    3a68:	bf 2b       	or	r27, r31
    3a6a:	11 f4       	brne	.+4      	; 0x3a70 <__fp_round+0x18>
    3a6c:	60 ff       	sbrs	r22, 0
    3a6e:	04 c0       	rjmp	.+8      	; 0x3a78 <__fp_round+0x20>
    3a70:	6f 5f       	subi	r22, 0xFF	; 255
    3a72:	7f 4f       	sbci	r23, 0xFF	; 255
    3a74:	8f 4f       	sbci	r24, 0xFF	; 255
    3a76:	9f 4f       	sbci	r25, 0xFF	; 255
    3a78:	08 95       	ret

00003a7a <__fp_split3>:
    3a7a:	57 fd       	sbrc	r21, 7
    3a7c:	90 58       	subi	r25, 0x80	; 128
    3a7e:	44 0f       	add	r20, r20
    3a80:	55 1f       	adc	r21, r21
    3a82:	59 f0       	breq	.+22     	; 0x3a9a <__fp_splitA+0x10>
    3a84:	5f 3f       	cpi	r21, 0xFF	; 255
    3a86:	71 f0       	breq	.+28     	; 0x3aa4 <__fp_splitA+0x1a>
    3a88:	47 95       	ror	r20

00003a8a <__fp_splitA>:
    3a8a:	88 0f       	add	r24, r24
    3a8c:	97 fb       	bst	r25, 7
    3a8e:	99 1f       	adc	r25, r25
    3a90:	61 f0       	breq	.+24     	; 0x3aaa <__fp_splitA+0x20>
    3a92:	9f 3f       	cpi	r25, 0xFF	; 255
    3a94:	79 f0       	breq	.+30     	; 0x3ab4 <__fp_splitA+0x2a>
    3a96:	87 95       	ror	r24
    3a98:	08 95       	ret
    3a9a:	12 16       	cp	r1, r18
    3a9c:	13 06       	cpc	r1, r19
    3a9e:	14 06       	cpc	r1, r20
    3aa0:	55 1f       	adc	r21, r21
    3aa2:	f2 cf       	rjmp	.-28     	; 0x3a88 <__fp_split3+0xe>
    3aa4:	46 95       	lsr	r20
    3aa6:	f1 df       	rcall	.-30     	; 0x3a8a <__fp_splitA>
    3aa8:	08 c0       	rjmp	.+16     	; 0x3aba <__fp_splitA+0x30>
    3aaa:	16 16       	cp	r1, r22
    3aac:	17 06       	cpc	r1, r23
    3aae:	18 06       	cpc	r1, r24
    3ab0:	99 1f       	adc	r25, r25
    3ab2:	f1 cf       	rjmp	.-30     	; 0x3a96 <__fp_splitA+0xc>
    3ab4:	86 95       	lsr	r24
    3ab6:	71 05       	cpc	r23, r1
    3ab8:	61 05       	cpc	r22, r1
    3aba:	08 94       	sec
    3abc:	08 95       	ret

00003abe <__fp_zero>:
    3abe:	e8 94       	clt

00003ac0 <__fp_szero>:
    3ac0:	bb 27       	eor	r27, r27
    3ac2:	66 27       	eor	r22, r22
    3ac4:	77 27       	eor	r23, r23
    3ac6:	cb 01       	movw	r24, r22
    3ac8:	97 f9       	bld	r25, 7
    3aca:	08 95       	ret

00003acc <__gesf2>:
    3acc:	0e 94 f1 1c 	call	0x39e2	; 0x39e2 <__fp_cmp>
    3ad0:	08 f4       	brcc	.+2      	; 0x3ad4 <__gesf2+0x8>
    3ad2:	8f ef       	ldi	r24, 0xFF	; 255
    3ad4:	08 95       	ret

00003ad6 <__mulsf3>:
    3ad6:	0e 94 7e 1d 	call	0x3afc	; 0x3afc <__mulsf3x>
    3ada:	0c 94 2c 1d 	jmp	0x3a58	; 0x3a58 <__fp_round>
    3ade:	0e 94 1e 1d 	call	0x3a3c	; 0x3a3c <__fp_pscA>
    3ae2:	38 f0       	brcs	.+14     	; 0x3af2 <__mulsf3+0x1c>
    3ae4:	0e 94 25 1d 	call	0x3a4a	; 0x3a4a <__fp_pscB>
    3ae8:	20 f0       	brcs	.+8      	; 0x3af2 <__mulsf3+0x1c>
    3aea:	95 23       	and	r25, r21
    3aec:	11 f0       	breq	.+4      	; 0x3af2 <__mulsf3+0x1c>
    3aee:	0c 94 15 1d 	jmp	0x3a2a	; 0x3a2a <__fp_inf>
    3af2:	0c 94 1b 1d 	jmp	0x3a36	; 0x3a36 <__fp_nan>
    3af6:	11 24       	eor	r1, r1
    3af8:	0c 94 60 1d 	jmp	0x3ac0	; 0x3ac0 <__fp_szero>

00003afc <__mulsf3x>:
    3afc:	0e 94 3d 1d 	call	0x3a7a	; 0x3a7a <__fp_split3>
    3b00:	70 f3       	brcs	.-36     	; 0x3ade <__mulsf3+0x8>

00003b02 <__mulsf3_pse>:
    3b02:	95 9f       	mul	r25, r21
    3b04:	c1 f3       	breq	.-16     	; 0x3af6 <__mulsf3+0x20>
    3b06:	95 0f       	add	r25, r21
    3b08:	50 e0       	ldi	r21, 0x00	; 0
    3b0a:	55 1f       	adc	r21, r21
    3b0c:	62 9f       	mul	r22, r18
    3b0e:	f0 01       	movw	r30, r0
    3b10:	72 9f       	mul	r23, r18
    3b12:	bb 27       	eor	r27, r27
    3b14:	f0 0d       	add	r31, r0
    3b16:	b1 1d       	adc	r27, r1
    3b18:	63 9f       	mul	r22, r19
    3b1a:	aa 27       	eor	r26, r26
    3b1c:	f0 0d       	add	r31, r0
    3b1e:	b1 1d       	adc	r27, r1
    3b20:	aa 1f       	adc	r26, r26
    3b22:	64 9f       	mul	r22, r20
    3b24:	66 27       	eor	r22, r22
    3b26:	b0 0d       	add	r27, r0
    3b28:	a1 1d       	adc	r26, r1
    3b2a:	66 1f       	adc	r22, r22
    3b2c:	82 9f       	mul	r24, r18
    3b2e:	22 27       	eor	r18, r18
    3b30:	b0 0d       	add	r27, r0
    3b32:	a1 1d       	adc	r26, r1
    3b34:	62 1f       	adc	r22, r18
    3b36:	73 9f       	mul	r23, r19
    3b38:	b0 0d       	add	r27, r0
    3b3a:	a1 1d       	adc	r26, r1
    3b3c:	62 1f       	adc	r22, r18
    3b3e:	83 9f       	mul	r24, r19
    3b40:	a0 0d       	add	r26, r0
    3b42:	61 1d       	adc	r22, r1
    3b44:	22 1f       	adc	r18, r18
    3b46:	74 9f       	mul	r23, r20
    3b48:	33 27       	eor	r19, r19
    3b4a:	a0 0d       	add	r26, r0
    3b4c:	61 1d       	adc	r22, r1
    3b4e:	23 1f       	adc	r18, r19
    3b50:	84 9f       	mul	r24, r20
    3b52:	60 0d       	add	r22, r0
    3b54:	21 1d       	adc	r18, r1
    3b56:	82 2f       	mov	r24, r18
    3b58:	76 2f       	mov	r23, r22
    3b5a:	6a 2f       	mov	r22, r26
    3b5c:	11 24       	eor	r1, r1
    3b5e:	9f 57       	subi	r25, 0x7F	; 127
    3b60:	50 40       	sbci	r21, 0x00	; 0
    3b62:	9a f0       	brmi	.+38     	; 0x3b8a <__mulsf3_pse+0x88>
    3b64:	f1 f0       	breq	.+60     	; 0x3ba2 <__mulsf3_pse+0xa0>
    3b66:	88 23       	and	r24, r24
    3b68:	4a f0       	brmi	.+18     	; 0x3b7c <__mulsf3_pse+0x7a>
    3b6a:	ee 0f       	add	r30, r30
    3b6c:	ff 1f       	adc	r31, r31
    3b6e:	bb 1f       	adc	r27, r27
    3b70:	66 1f       	adc	r22, r22
    3b72:	77 1f       	adc	r23, r23
    3b74:	88 1f       	adc	r24, r24
    3b76:	91 50       	subi	r25, 0x01	; 1
    3b78:	50 40       	sbci	r21, 0x00	; 0
    3b7a:	a9 f7       	brne	.-22     	; 0x3b66 <__mulsf3_pse+0x64>
    3b7c:	9e 3f       	cpi	r25, 0xFE	; 254
    3b7e:	51 05       	cpc	r21, r1
    3b80:	80 f0       	brcs	.+32     	; 0x3ba2 <__mulsf3_pse+0xa0>
    3b82:	0c 94 15 1d 	jmp	0x3a2a	; 0x3a2a <__fp_inf>
    3b86:	0c 94 60 1d 	jmp	0x3ac0	; 0x3ac0 <__fp_szero>
    3b8a:	5f 3f       	cpi	r21, 0xFF	; 255
    3b8c:	e4 f3       	brlt	.-8      	; 0x3b86 <__mulsf3_pse+0x84>
    3b8e:	98 3e       	cpi	r25, 0xE8	; 232
    3b90:	d4 f3       	brlt	.-12     	; 0x3b86 <__mulsf3_pse+0x84>
    3b92:	86 95       	lsr	r24
    3b94:	77 95       	ror	r23
    3b96:	67 95       	ror	r22
    3b98:	b7 95       	ror	r27
    3b9a:	f7 95       	ror	r31
    3b9c:	e7 95       	ror	r30
    3b9e:	9f 5f       	subi	r25, 0xFF	; 255
    3ba0:	c1 f7       	brne	.-16     	; 0x3b92 <__mulsf3_pse+0x90>
    3ba2:	fe 2b       	or	r31, r30
    3ba4:	88 0f       	add	r24, r24
    3ba6:	91 1d       	adc	r25, r1
    3ba8:	96 95       	lsr	r25
    3baa:	87 95       	ror	r24
    3bac:	97 f9       	bld	r25, 7
    3bae:	08 95       	ret

00003bb0 <__divmodhi4>:
    3bb0:	97 fb       	bst	r25, 7
    3bb2:	07 2e       	mov	r0, r23
    3bb4:	16 f4       	brtc	.+4      	; 0x3bba <__divmodhi4+0xa>
    3bb6:	00 94       	com	r0
    3bb8:	07 d0       	rcall	.+14     	; 0x3bc8 <__divmodhi4_neg1>
    3bba:	77 fd       	sbrc	r23, 7
    3bbc:	09 d0       	rcall	.+18     	; 0x3bd0 <__divmodhi4_neg2>
    3bbe:	0e 94 19 1e 	call	0x3c32	; 0x3c32 <__udivmodhi4>
    3bc2:	07 fc       	sbrc	r0, 7
    3bc4:	05 d0       	rcall	.+10     	; 0x3bd0 <__divmodhi4_neg2>
    3bc6:	3e f4       	brtc	.+14     	; 0x3bd6 <__divmodhi4_exit>

00003bc8 <__divmodhi4_neg1>:
    3bc8:	90 95       	com	r25
    3bca:	81 95       	neg	r24
    3bcc:	9f 4f       	sbci	r25, 0xFF	; 255
    3bce:	08 95       	ret

00003bd0 <__divmodhi4_neg2>:
    3bd0:	70 95       	com	r23
    3bd2:	61 95       	neg	r22
    3bd4:	7f 4f       	sbci	r23, 0xFF	; 255

00003bd6 <__divmodhi4_exit>:
    3bd6:	08 95       	ret

00003bd8 <__udivmodsi4>:
    3bd8:	a1 e2       	ldi	r26, 0x21	; 33
    3bda:	1a 2e       	mov	r1, r26
    3bdc:	aa 1b       	sub	r26, r26
    3bde:	bb 1b       	sub	r27, r27
    3be0:	fd 01       	movw	r30, r26
    3be2:	0d c0       	rjmp	.+26     	; 0x3bfe <__udivmodsi4_ep>

00003be4 <__udivmodsi4_loop>:
    3be4:	aa 1f       	adc	r26, r26
    3be6:	bb 1f       	adc	r27, r27
    3be8:	ee 1f       	adc	r30, r30
    3bea:	ff 1f       	adc	r31, r31
    3bec:	a2 17       	cp	r26, r18
    3bee:	b3 07       	cpc	r27, r19
    3bf0:	e4 07       	cpc	r30, r20
    3bf2:	f5 07       	cpc	r31, r21
    3bf4:	20 f0       	brcs	.+8      	; 0x3bfe <__udivmodsi4_ep>
    3bf6:	a2 1b       	sub	r26, r18
    3bf8:	b3 0b       	sbc	r27, r19
    3bfa:	e4 0b       	sbc	r30, r20
    3bfc:	f5 0b       	sbc	r31, r21

00003bfe <__udivmodsi4_ep>:
    3bfe:	66 1f       	adc	r22, r22
    3c00:	77 1f       	adc	r23, r23
    3c02:	88 1f       	adc	r24, r24
    3c04:	99 1f       	adc	r25, r25
    3c06:	1a 94       	dec	r1
    3c08:	69 f7       	brne	.-38     	; 0x3be4 <__udivmodsi4_loop>
    3c0a:	60 95       	com	r22
    3c0c:	70 95       	com	r23
    3c0e:	80 95       	com	r24
    3c10:	90 95       	com	r25
    3c12:	9b 01       	movw	r18, r22
    3c14:	ac 01       	movw	r20, r24
    3c16:	bd 01       	movw	r22, r26
    3c18:	cf 01       	movw	r24, r30
    3c1a:	08 95       	ret

00003c1c <__muluhisi3>:
    3c1c:	0e 94 2d 1e 	call	0x3c5a	; 0x3c5a <__umulhisi3>
    3c20:	a5 9f       	mul	r26, r21
    3c22:	90 0d       	add	r25, r0
    3c24:	b4 9f       	mul	r27, r20
    3c26:	90 0d       	add	r25, r0
    3c28:	a4 9f       	mul	r26, r20
    3c2a:	80 0d       	add	r24, r0
    3c2c:	91 1d       	adc	r25, r1
    3c2e:	11 24       	eor	r1, r1
    3c30:	08 95       	ret

00003c32 <__udivmodhi4>:
    3c32:	aa 1b       	sub	r26, r26
    3c34:	bb 1b       	sub	r27, r27
    3c36:	51 e1       	ldi	r21, 0x11	; 17
    3c38:	07 c0       	rjmp	.+14     	; 0x3c48 <__udivmodhi4_ep>

00003c3a <__udivmodhi4_loop>:
    3c3a:	aa 1f       	adc	r26, r26
    3c3c:	bb 1f       	adc	r27, r27
    3c3e:	a6 17       	cp	r26, r22
    3c40:	b7 07       	cpc	r27, r23
    3c42:	10 f0       	brcs	.+4      	; 0x3c48 <__udivmodhi4_ep>
    3c44:	a6 1b       	sub	r26, r22
    3c46:	b7 0b       	sbc	r27, r23

00003c48 <__udivmodhi4_ep>:
    3c48:	88 1f       	adc	r24, r24
    3c4a:	99 1f       	adc	r25, r25
    3c4c:	5a 95       	dec	r21
    3c4e:	a9 f7       	brne	.-22     	; 0x3c3a <__udivmodhi4_loop>
    3c50:	80 95       	com	r24
    3c52:	90 95       	com	r25
    3c54:	bc 01       	movw	r22, r24
    3c56:	cd 01       	movw	r24, r26
    3c58:	08 95       	ret

00003c5a <__umulhisi3>:
    3c5a:	a2 9f       	mul	r26, r18
    3c5c:	b0 01       	movw	r22, r0
    3c5e:	b3 9f       	mul	r27, r19
    3c60:	c0 01       	movw	r24, r0
    3c62:	a3 9f       	mul	r26, r19
    3c64:	70 0d       	add	r23, r0
    3c66:	81 1d       	adc	r24, r1
    3c68:	11 24       	eor	r1, r1
    3c6a:	91 1d       	adc	r25, r1
    3c6c:	b2 9f       	mul	r27, r18
    3c6e:	70 0d       	add	r23, r0
    3c70:	81 1d       	adc	r24, r1
    3c72:	11 24       	eor	r1, r1
    3c74:	91 1d       	adc	r25, r1
    3c76:	08 95       	ret

00003c78 <_exit>:
    3c78:	f8 94       	cli

00003c7a <__stop_program>:
    3c7a:	ff cf       	rjmp	.-2      	; 0x3c7a <__stop_program>
